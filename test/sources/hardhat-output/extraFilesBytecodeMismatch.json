{
  "id": "792c75f41bf758e0984e16879b7e8dd7",
  "_format": "hh-sol-build-info-1",
  "solcVersion": "0.6.12",
  "solcLongVersion": "0.6.12+commit.27d51765",
  "input": {
    "language": "Solidity",
    "sources": {
      "contracts/adapters/BaseUniswapAdapter.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {PercentageMath} from '../protocol/libraries/math/PercentageMath.sol';\r\nimport {SafeMath} from '../dependencies/openzeppelin/contracts/SafeMath.sol';\r\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\r\nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol';\r\nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol';\r\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\r\nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol';\r\nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol';\r\nimport {IERC20WithPermit} from '../interfaces/IERC20WithPermit.sol';\r\nimport {FlashLoanReceiverBase} from '../flashloan/base/FlashLoanReceiverBase.sol';\r\nimport {IBaseUniswapAdapter} from './interfaces/IBaseUniswapAdapter.sol';\r\n\r\n/**\r\n * @title BaseUniswapAdapter\r\n * @notice Implements the logic for performing assets swaps in Uniswap V2\r\n * @author Aave\r\n **/\r\nabstract contract BaseUniswapAdapter is FlashLoanReceiverBase, IBaseUniswapAdapter, Ownable {\r\n  using SafeMath for uint256;\r\n  using PercentageMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  // Max slippage percent allowed\r\n  uint256 public constant override MAX_SLIPPAGE_PERCENT = 3000; // 30%\r\n  // FLash Loan fee set in lending pool\r\n  uint256 public constant override FLASHLOAN_PREMIUM_TOTAL = 9;\r\n  // USD oracle asset address\r\n  address public constant override USD_ADDRESS = 0x10F7Fc1F91Ba351f9C629c5947AD69bD03C05b96;\r\n\r\n  address public immutable override WETH_ADDRESS;\r\n  IPriceOracleGetter public immutable override ORACLE;\r\n  IUniswapV2Router02 public immutable override UNISWAP_ROUTER;\r\n\r\n  constructor(\r\n    ILendingPoolAddressesProvider addressesProvider,\r\n    IUniswapV2Router02 uniswapRouter,\r\n    address wethAddress\r\n  ) public FlashLoanReceiverBase(addressesProvider) {\r\n    ORACLE = IPriceOracleGetter(addressesProvider.getPriceOracle());\r\n    UNISWAP_ROUTER = uniswapRouter;\r\n    WETH_ADDRESS = wethAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev Given an input asset amount, returns the maximum output amount of the other asset and the prices\r\n   * @param amountIn Amount of reserveIn\r\n   * @param reserveIn Address of the asset to be swap from\r\n   * @param reserveOut Address of the asset to be swap to\r\n   * @return uint256 Amount out of the reserveOut\r\n   * @return uint256 The price of out amount denominated in the reserveIn currency (18 decimals)\r\n   * @return uint256 In amount of reserveIn value denominated in USD (8 decimals)\r\n   * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals)\r\n   */\r\n  function getAmountsOut(\r\n    uint256 amountIn,\r\n    address reserveIn,\r\n    address reserveOut\r\n  )\r\n    external\r\n    view\r\n    override\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      address[] memory\r\n    )\r\n  {\r\n    AmountCalc memory results = _getAmountsOutData(reserveIn, reserveOut, amountIn);\r\n\r\n    return (\r\n      results.calculatedAmount,\r\n      results.relativePrice,\r\n      results.amountInUsd,\r\n      results.amountOutUsd,\r\n      results.path\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the minimum input asset amount required to buy the given output asset amount and the prices\r\n   * @param amountOut Amount of reserveOut\r\n   * @param reserveIn Address of the asset to be swap from\r\n   * @param reserveOut Address of the asset to be swap to\r\n   * @return uint256 Amount in of the reserveIn\r\n   * @return uint256 The price of in amount denominated in the reserveOut currency (18 decimals)\r\n   * @return uint256 In amount of reserveIn value denominated in USD (8 decimals)\r\n   * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals)\r\n   */\r\n  function getAmountsIn(\r\n    uint256 amountOut,\r\n    address reserveIn,\r\n    address reserveOut\r\n  )\r\n    external\r\n    view\r\n    override\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      address[] memory\r\n    )\r\n  {\r\n    AmountCalc memory results = _getAmountsInData(reserveIn, reserveOut, amountOut);\r\n\r\n    return (\r\n      results.calculatedAmount,\r\n      results.relativePrice,\r\n      results.amountInUsd,\r\n      results.amountOutUsd,\r\n      results.path\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Swaps an exact `amountToSwap` of an asset to another\r\n   * @param assetToSwapFrom Origin asset\r\n   * @param assetToSwapTo Destination asset\r\n   * @param amountToSwap Exact amount of `assetToSwapFrom` to be swapped\r\n   * @param minAmountOut the min amount of `assetToSwapTo` to be received from the swap\r\n   * @return the amount received from the swap\r\n   */\r\n  function _swapExactTokensForTokens(\r\n    address assetToSwapFrom,\r\n    address assetToSwapTo,\r\n    uint256 amountToSwap,\r\n    uint256 minAmountOut,\r\n    bool useEthPath\r\n  ) internal returns (uint256) {\r\n    uint256 fromAssetDecimals = _getDecimals(assetToSwapFrom);\r\n    uint256 toAssetDecimals = _getDecimals(assetToSwapTo);\r\n\r\n    uint256 fromAssetPrice = _getPrice(assetToSwapFrom);\r\n    uint256 toAssetPrice = _getPrice(assetToSwapTo);\r\n\r\n    uint256 expectedMinAmountOut =\r\n      amountToSwap\r\n        .mul(fromAssetPrice.mul(10**toAssetDecimals))\r\n        .div(toAssetPrice.mul(10**fromAssetDecimals))\r\n        .percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(MAX_SLIPPAGE_PERCENT));\r\n\r\n    require(expectedMinAmountOut < minAmountOut, 'minAmountOut exceed max slippage');\r\n\r\n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\r\n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), 0);\r\n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), amountToSwap);\r\n\r\n    address[] memory path;\r\n    if (useEthPath) {\r\n      path = new address[](3);\r\n      path[0] = assetToSwapFrom;\r\n      path[1] = WETH_ADDRESS;\r\n      path[2] = assetToSwapTo;\r\n    } else {\r\n      path = new address[](2);\r\n      path[0] = assetToSwapFrom;\r\n      path[1] = assetToSwapTo;\r\n    }\r\n    uint256[] memory amounts =\r\n      UNISWAP_ROUTER.swapExactTokensForTokens(\r\n        amountToSwap,\r\n        minAmountOut,\r\n        path,\r\n        address(this),\r\n        block.timestamp\r\n      );\r\n\r\n    emit Swapped(assetToSwapFrom, assetToSwapTo, amounts[0], amounts[amounts.length - 1]);\r\n\r\n    return amounts[amounts.length - 1];\r\n  }\r\n\r\n  /**\r\n   * @dev Receive an exact amount `amountToReceive` of `assetToSwapTo` tokens for as few `assetToSwapFrom` tokens as\r\n   * possible.\r\n   * @param assetToSwapFrom Origin asset\r\n   * @param assetToSwapTo Destination asset\r\n   * @param maxAmountToSwap Max amount of `assetToSwapFrom` allowed to be swapped\r\n   * @param amountToReceive Exact amount of `assetToSwapTo` to receive\r\n   * @return the amount swapped\r\n   */\r\n  function _swapTokensForExactTokens(\r\n    address assetToSwapFrom,\r\n    address assetToSwapTo,\r\n    uint256 maxAmountToSwap,\r\n    uint256 amountToReceive,\r\n    bool useEthPath\r\n  ) internal returns (uint256) {\r\n    uint256 fromAssetDecimals = _getDecimals(assetToSwapFrom);\r\n    uint256 toAssetDecimals = _getDecimals(assetToSwapTo);\r\n\r\n    uint256 fromAssetPrice = _getPrice(assetToSwapFrom);\r\n    uint256 toAssetPrice = _getPrice(assetToSwapTo);\r\n\r\n    uint256 expectedMaxAmountToSwap =\r\n      amountToReceive\r\n        .mul(toAssetPrice.mul(10**fromAssetDecimals))\r\n        .div(fromAssetPrice.mul(10**toAssetDecimals))\r\n        .percentMul(PercentageMath.PERCENTAGE_FACTOR.add(MAX_SLIPPAGE_PERCENT));\r\n\r\n    require(maxAmountToSwap < expectedMaxAmountToSwap, 'maxAmountToSwap exceed max slippage');\r\n\r\n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\r\n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), 0);\r\n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), maxAmountToSwap);\r\n\r\n    address[] memory path;\r\n    if (useEthPath) {\r\n      path = new address[](3);\r\n      path[0] = assetToSwapFrom;\r\n      path[1] = WETH_ADDRESS;\r\n      path[2] = assetToSwapTo;\r\n    } else {\r\n      path = new address[](2);\r\n      path[0] = assetToSwapFrom;\r\n      path[1] = assetToSwapTo;\r\n    }\r\n\r\n    uint256[] memory amounts =\r\n      UNISWAP_ROUTER.swapTokensForExactTokens(\r\n        amountToReceive,\r\n        maxAmountToSwap,\r\n        path,\r\n        address(this),\r\n        block.timestamp\r\n      );\r\n\r\n    emit Swapped(assetToSwapFrom, assetToSwapTo, amounts[0], amounts[amounts.length - 1]);\r\n\r\n    return amounts[0];\r\n  }\r\n\r\n  /**\r\n   * @dev Get the price of the asset from the oracle denominated in eth\r\n   * @param asset address\r\n   * @return eth price for the asset\r\n   */\r\n  function _getPrice(address asset) internal view returns (uint256) {\r\n    return ORACLE.getAssetPrice(asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Get the decimals of an asset\r\n   * @return number of decimals of the asset\r\n   */\r\n  function _getDecimals(address asset) internal view returns (uint256) {\r\n    return IERC20Detailed(asset).decimals();\r\n  }\r\n\r\n  /**\r\n   * @dev Get the aToken associated to the asset\r\n   * @return address of the aToken\r\n   */\r\n  function _getReserveData(address asset) internal view returns (DataTypes.ReserveData memory) {\r\n    return LENDING_POOL.getReserveData(asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Pull the ATokens from the user\r\n   * @param reserve address of the asset\r\n   * @param reserveAToken address of the aToken of the reserve\r\n   * @param user address\r\n   * @param amount of tokens to be transferred to the contract\r\n   * @param permitSignature struct containing the permit signature\r\n   */\r\n  function _pullAToken(\r\n    address reserve,\r\n    address reserveAToken,\r\n    address user,\r\n    uint256 amount,\r\n    PermitSignature memory permitSignature\r\n  ) internal {\r\n    if (_usePermit(permitSignature)) {\r\n      IERC20WithPermit(reserveAToken).permit(\r\n        user,\r\n        address(this),\r\n        permitSignature.amount,\r\n        permitSignature.deadline,\r\n        permitSignature.v,\r\n        permitSignature.r,\r\n        permitSignature.s\r\n      );\r\n    }\r\n\r\n    // transfer from user to adapter\r\n    IERC20(reserveAToken).safeTransferFrom(user, address(this), amount);\r\n\r\n    // withdraw reserve\r\n    LENDING_POOL.withdraw(reserve, amount, address(this));\r\n  }\r\n\r\n  /**\r\n   * @dev Tells if the permit method should be called by inspecting if there is a valid signature.\r\n   * If signature params are set to 0, then permit won't be called.\r\n   * @param signature struct containing the permit signature\r\n   * @return whether or not permit should be called\r\n   */\r\n  function _usePermit(PermitSignature memory signature) internal pure returns (bool) {\r\n    return\r\n      !(uint256(signature.deadline) == uint256(signature.v) && uint256(signature.deadline) == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the value denominated in USD\r\n   * @param reserve Address of the reserve\r\n   * @param amount Amount of the reserve\r\n   * @param decimals Decimals of the reserve\r\n   * @return whether or not permit should be called\r\n   */\r\n  function _calcUsdValue(\r\n    address reserve,\r\n    uint256 amount,\r\n    uint256 decimals\r\n  ) internal view returns (uint256) {\r\n    uint256 ethUsdPrice = _getPrice(USD_ADDRESS);\r\n    uint256 reservePrice = _getPrice(reserve);\r\n\r\n    return amount.mul(reservePrice).div(10**decimals).mul(ethUsdPrice).div(10**18);\r\n  }\r\n\r\n  /**\r\n   * @dev Given an input asset amount, returns the maximum output amount of the other asset\r\n   * @param reserveIn Address of the asset to be swap from\r\n   * @param reserveOut Address of the asset to be swap to\r\n   * @param amountIn Amount of reserveIn\r\n   * @return Struct containing the following information:\r\n   *   uint256 Amount out of the reserveOut\r\n   *   uint256 The price of out amount denominated in the reserveIn currency (18 decimals)\r\n   *   uint256 In amount of reserveIn value denominated in USD (8 decimals)\r\n   *   uint256 Out amount of reserveOut value denominated in USD (8 decimals)\r\n   */\r\n  function _getAmountsOutData(\r\n    address reserveIn,\r\n    address reserveOut,\r\n    uint256 amountIn\r\n  ) internal view returns (AmountCalc memory) {\r\n    // Subtract flash loan fee\r\n    uint256 finalAmountIn = amountIn.sub(amountIn.mul(FLASHLOAN_PREMIUM_TOTAL).div(10000));\r\n\r\n    if (reserveIn == reserveOut) {\r\n      uint256 reserveDecimals = _getDecimals(reserveIn);\r\n      address[] memory path = new address[](1);\r\n      path[0] = reserveIn;\r\n\r\n      return\r\n        AmountCalc(\r\n          finalAmountIn,\r\n          finalAmountIn.mul(10**18).div(amountIn),\r\n          _calcUsdValue(reserveIn, amountIn, reserveDecimals),\r\n          _calcUsdValue(reserveIn, finalAmountIn, reserveDecimals),\r\n          path\r\n        );\r\n    }\r\n\r\n    address[] memory simplePath = new address[](2);\r\n    simplePath[0] = reserveIn;\r\n    simplePath[1] = reserveOut;\r\n\r\n    uint256[] memory amountsWithoutWeth;\r\n    uint256[] memory amountsWithWeth;\r\n\r\n    address[] memory pathWithWeth = new address[](3);\r\n    if (reserveIn != WETH_ADDRESS && reserveOut != WETH_ADDRESS) {\r\n      pathWithWeth[0] = reserveIn;\r\n      pathWithWeth[1] = WETH_ADDRESS;\r\n      pathWithWeth[2] = reserveOut;\r\n\r\n      try UNISWAP_ROUTER.getAmountsOut(finalAmountIn, pathWithWeth) returns (\r\n        uint256[] memory resultsWithWeth\r\n      ) {\r\n        amountsWithWeth = resultsWithWeth;\r\n      } catch {\r\n        amountsWithWeth = new uint256[](3);\r\n      }\r\n    } else {\r\n      amountsWithWeth = new uint256[](3);\r\n    }\r\n\r\n    uint256 bestAmountOut;\r\n    try UNISWAP_ROUTER.getAmountsOut(finalAmountIn, simplePath) returns (\r\n      uint256[] memory resultAmounts\r\n    ) {\r\n      amountsWithoutWeth = resultAmounts;\r\n\r\n      bestAmountOut = (amountsWithWeth[2] > amountsWithoutWeth[1])\r\n        ? amountsWithWeth[2]\r\n        : amountsWithoutWeth[1];\r\n    } catch {\r\n      amountsWithoutWeth = new uint256[](2);\r\n      bestAmountOut = amountsWithWeth[2];\r\n    }\r\n\r\n    uint256 reserveInDecimals = _getDecimals(reserveIn);\r\n    uint256 reserveOutDecimals = _getDecimals(reserveOut);\r\n\r\n    uint256 outPerInPrice =\r\n      finalAmountIn.mul(10**18).mul(10**reserveOutDecimals).div(\r\n        bestAmountOut.mul(10**reserveInDecimals)\r\n      );\r\n\r\n    return\r\n      AmountCalc(\r\n        bestAmountOut,\r\n        outPerInPrice,\r\n        _calcUsdValue(reserveIn, amountIn, reserveInDecimals),\r\n        _calcUsdValue(reserveOut, bestAmountOut, reserveOutDecimals),\r\n        (bestAmountOut == 0) ? new address[](2) : (bestAmountOut == amountsWithoutWeth[1])\r\n          ? simplePath\r\n          : pathWithWeth\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the minimum input asset amount required to buy the given output asset amount\r\n   * @param reserveIn Address of the asset to be swap from\r\n   * @param reserveOut Address of the asset to be swap to\r\n   * @param amountOut Amount of reserveOut\r\n   * @return Struct containing the following information:\r\n   *   uint256 Amount in of the reserveIn\r\n   *   uint256 The price of in amount denominated in the reserveOut currency (18 decimals)\r\n   *   uint256 In amount of reserveIn value denominated in USD (8 decimals)\r\n   *   uint256 Out amount of reserveOut value denominated in USD (8 decimals)\r\n   */\r\n  function _getAmountsInData(\r\n    address reserveIn,\r\n    address reserveOut,\r\n    uint256 amountOut\r\n  ) internal view returns (AmountCalc memory) {\r\n    if (reserveIn == reserveOut) {\r\n      // Add flash loan fee\r\n      uint256 amountIn = amountOut.add(amountOut.mul(FLASHLOAN_PREMIUM_TOTAL).div(10000));\r\n      uint256 reserveDecimals = _getDecimals(reserveIn);\r\n      address[] memory path = new address[](1);\r\n      path[0] = reserveIn;\r\n\r\n      return\r\n        AmountCalc(\r\n          amountIn,\r\n          amountOut.mul(10**18).div(amountIn),\r\n          _calcUsdValue(reserveIn, amountIn, reserveDecimals),\r\n          _calcUsdValue(reserveIn, amountOut, reserveDecimals),\r\n          path\r\n        );\r\n    }\r\n\r\n    (uint256[] memory amounts, address[] memory path) =\r\n      _getAmountsInAndPath(reserveIn, reserveOut, amountOut);\r\n\r\n    // Add flash loan fee\r\n    uint256 finalAmountIn = amounts[0].add(amounts[0].mul(FLASHLOAN_PREMIUM_TOTAL).div(10000));\r\n\r\n    uint256 reserveInDecimals = _getDecimals(reserveIn);\r\n    uint256 reserveOutDecimals = _getDecimals(reserveOut);\r\n\r\n    uint256 inPerOutPrice =\r\n      amountOut.mul(10**18).mul(10**reserveInDecimals).div(\r\n        finalAmountIn.mul(10**reserveOutDecimals)\r\n      );\r\n\r\n    return\r\n      AmountCalc(\r\n        finalAmountIn,\r\n        inPerOutPrice,\r\n        _calcUsdValue(reserveIn, finalAmountIn, reserveInDecimals),\r\n        _calcUsdValue(reserveOut, amountOut, reserveOutDecimals),\r\n        path\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the input asset amount required to buy the given output asset amount\r\n   * @param reserveIn Address of the asset to be swap from\r\n   * @param reserveOut Address of the asset to be swap to\r\n   * @param amountOut Amount of reserveOut\r\n   * @return uint256[] amounts Array containing the amountIn and amountOut for a swap\r\n   */\r\n  function _getAmountsInAndPath(\r\n    address reserveIn,\r\n    address reserveOut,\r\n    uint256 amountOut\r\n  ) internal view returns (uint256[] memory, address[] memory) {\r\n    address[] memory simplePath = new address[](2);\r\n    simplePath[0] = reserveIn;\r\n    simplePath[1] = reserveOut;\r\n\r\n    uint256[] memory amountsWithoutWeth;\r\n    uint256[] memory amountsWithWeth;\r\n    address[] memory pathWithWeth = new address[](3);\r\n\r\n    if (reserveIn != WETH_ADDRESS && reserveOut != WETH_ADDRESS) {\r\n      pathWithWeth[0] = reserveIn;\r\n      pathWithWeth[1] = WETH_ADDRESS;\r\n      pathWithWeth[2] = reserveOut;\r\n\r\n      try UNISWAP_ROUTER.getAmountsIn(amountOut, pathWithWeth) returns (\r\n        uint256[] memory resultsWithWeth\r\n      ) {\r\n        amountsWithWeth = resultsWithWeth;\r\n      } catch {\r\n        amountsWithWeth = new uint256[](3);\r\n      }\r\n    } else {\r\n      amountsWithWeth = new uint256[](3);\r\n    }\r\n\r\n    try UNISWAP_ROUTER.getAmountsIn(amountOut, simplePath) returns (\r\n      uint256[] memory resultAmounts\r\n    ) {\r\n      amountsWithoutWeth = resultAmounts;\r\n\r\n      return\r\n        (amountsWithWeth[0] < amountsWithoutWeth[0] && amountsWithWeth[0] != 0)\r\n          ? (amountsWithWeth, pathWithWeth)\r\n          : (amountsWithoutWeth, simplePath);\r\n    } catch {\r\n      return (amountsWithWeth, pathWithWeth);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the input asset amount required to buy the given output asset amount\r\n   * @param reserveIn Address of the asset to be swap from\r\n   * @param reserveOut Address of the asset to be swap to\r\n   * @param amountOut Amount of reserveOut\r\n   * @return uint256[] amounts Array containing the amountIn and amountOut for a swap\r\n   */\r\n  function _getAmountsIn(\r\n    address reserveIn,\r\n    address reserveOut,\r\n    uint256 amountOut,\r\n    bool useEthPath\r\n  ) internal view returns (uint256[] memory) {\r\n    address[] memory path;\r\n\r\n    if (useEthPath) {\r\n      path = new address[](3);\r\n      path[0] = reserveIn;\r\n      path[1] = WETH_ADDRESS;\r\n      path[2] = reserveOut;\r\n    } else {\r\n      path = new address[](2);\r\n      path[0] = reserveIn;\r\n      path[1] = reserveOut;\r\n    }\r\n\r\n    return UNISWAP_ROUTER.getAmountsIn(amountOut, path);\r\n  }\r\n\r\n  /**\r\n   * @dev Emergency rescue for token stucked on this contract, as failsafe mechanism\r\n   * - Funds should never remain in this contract more time than during transactions\r\n   * - Only callable by the owner\r\n   **/\r\n  function rescueTokens(IERC20 token) external onlyOwner {\r\n    token.transfer(owner(), token.balanceOf(address(this)));\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/libraries/math/PercentageMath.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {Errors} from '../helpers/Errors.sol';\r\n\r\n/**\r\n * @title PercentageMath library\r\n * @author Aave\r\n * @notice Provides functions to perform percentage calculations\r\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\r\n * @dev Operations are rounded half up\r\n **/\r\n\r\nlibrary PercentageMath {\r\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\r\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\r\n\r\n  /**\r\n   * @dev Executes a percentage multiplication\r\n   * @param value The value of which the percentage needs to be calculated\r\n   * @param percentage The percentage of the value to be calculated\r\n   * @return The percentage of value\r\n   **/\r\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\r\n    if (value == 0 || percentage == 0) {\r\n      return 0;\r\n    }\r\n\r\n    require(\r\n      value <= (type(uint256).max - HALF_PERCENT) / percentage,\r\n      Errors.MATH_MULTIPLICATION_OVERFLOW\r\n    );\r\n\r\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\r\n  }\r\n\r\n  /**\r\n   * @dev Executes a percentage division\r\n   * @param value The value of which the percentage needs to be calculated\r\n   * @param percentage The percentage of the value to be calculated\r\n   * @return The value divided the percentage\r\n   **/\r\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\r\n    require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);\r\n    uint256 halfPercentage = percentage / 2;\r\n\r\n    require(\r\n      value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\r\n      Errors.MATH_MULTIPLICATION_OVERFLOW\r\n    );\r\n\r\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/contracts/SafeMath.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/contracts/IERC20Detailed.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {IERC20} from './IERC20.sol';\r\n\r\ninterface IERC20Detailed is IERC20 {\r\n  function name() external view returns (string memory);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function decimals() external view returns (uint8);\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/contracts/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport {IERC20} from './IERC20.sol';\r\nimport {SafeMath} from './SafeMath.sol';\r\nimport {Address} from './Address.sol';\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n  }\r\n\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    require(\r\n      (value == 0) || (token.allowance(address(this), spender) == 0),\r\n      'SafeERC20: approve from non-zero to non-zero allowance'\r\n    );\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n  }\r\n\r\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = address(token).call(data);\r\n    require(success, 'SafeERC20: low-level call failed');\r\n\r\n    if (returndata.length > 0) {\r\n      // Return data is optional\r\n      // solhint-disable-next-line max-line-length\r\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\r\n    }\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/contracts/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nimport './Context.sol';\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() internal {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n"
      },
      "contracts/interfaces/ILendingPoolAddressesProvider.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ninterface ILendingPoolAddressesProvider {\r\n  event MarketIdSet(string newMarketId);\r\n  event LendingPoolUpdated(address indexed newAddress);\r\n  event ConfigurationAdminUpdated(address indexed newAddress);\r\n  event EmergencyAdminUpdated(address indexed newAddress);\r\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n  event PriceOracleUpdated(address indexed newAddress);\r\n  event LendingRateOracleUpdated(address indexed newAddress);\r\n  event ProxyCreated(bytes32 id, address indexed newAddress);\r\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n  function getMarketId() external view returns (string memory);\r\n\r\n  function setMarketId(string calldata marketId) external;\r\n\r\n  function setAddress(bytes32 id, address newAddress) external;\r\n\r\n  function setAddressAsProxy(bytes32 id, address impl) external;\r\n\r\n  function getAddress(bytes32 id) external view returns (address);\r\n\r\n  function getLendingPool() external view returns (address);\r\n\r\n  function setLendingPoolImpl(address pool) external;\r\n\r\n  function getLendingPoolConfigurator() external view returns (address);\r\n\r\n  function setLendingPoolConfiguratorImpl(address configurator) external;\r\n\r\n  function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n  function setLendingPoolCollateralManager(address manager) external;\r\n\r\n  function getPoolAdmin() external view returns (address);\r\n\r\n  function setPoolAdmin(address admin) external;\r\n\r\n  function getEmergencyAdmin() external view returns (address);\r\n\r\n  function setEmergencyAdmin(address admin) external;\r\n\r\n  function getPriceOracle() external view returns (address);\r\n\r\n  function setPriceOracle(address priceOracle) external;\r\n\r\n  function getLendingRateOracle() external view returns (address);\r\n\r\n  function setLendingRateOracle(address lendingRateOracle) external;\r\n}\r\n"
      },
      "contracts/protocol/libraries/types/DataTypes.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nlibrary DataTypes {\r\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n  struct ReserveData {\r\n    //stores the reserve configuration\r\n    ReserveConfigurationMap configuration;\r\n    //the liquidity index. Expressed in ray\r\n    uint128 liquidityIndex;\r\n    //variable borrow index. Expressed in ray\r\n    uint128 variableBorrowIndex;\r\n    //the current supply rate. Expressed in ray\r\n    uint128 currentLiquidityRate;\r\n    //the current variable borrow rate. Expressed in ray\r\n    uint128 currentVariableBorrowRate;\r\n    //the current stable borrow rate. Expressed in ray\r\n    uint128 currentStableBorrowRate;\r\n    uint40 lastUpdateTimestamp;\r\n    //tokens addresses\r\n    address aTokenAddress;\r\n    address stableDebtTokenAddress;\r\n    address variableDebtTokenAddress;\r\n    //address of the interest rate strategy\r\n    address interestRateStrategyAddress;\r\n    //the id of the reserve. Represents the position in the list of the active reserves\r\n    uint8 id;\r\n  }\r\n\r\n  struct ReserveConfigurationMap {\r\n    //bit 0-15: LTV\r\n    //bit 16-31: Liq. threshold\r\n    //bit 32-47: Liq. bonus\r\n    //bit 48-55: Decimals\r\n    //bit 56: Reserve is active\r\n    //bit 57: reserve is frozen\r\n    //bit 58: borrowing is enabled\r\n    //bit 59: stable rate borrowing enabled\r\n    //bit 60-63: reserved\r\n    //bit 64-79: reserve factor\r\n    uint256 data;\r\n  }\r\n\r\n  struct UserConfigurationMap {\r\n    uint256 data;\r\n  }\r\n\r\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\r\n}\r\n"
      },
      "contracts/interfaces/IUniswapV2Router02.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\ninterface IUniswapV2Router02 {\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactTokens(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n\r\n  function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n}\r\n"
      },
      "contracts/interfaces/IPriceOracleGetter.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title IPriceOracleGetter interface\r\n * @notice Interface for the Aave price oracle.\r\n **/\r\n\r\ninterface IPriceOracleGetter {\r\n  /**\r\n   * @dev returns the asset price in ETH\r\n   * @param asset the address of the asset\r\n   * @return the ETH price of the asset\r\n   **/\r\n  function getAssetPrice(address asset) external view returns (uint256);\r\n}\r\n"
      },
      "contracts/interfaces/IERC20WithPermit.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\r\n\r\ninterface IERC20WithPermit is IERC20 {\r\n  function permit(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n}\r\n"
      },
      "contracts/flashloan/base/FlashLoanReceiverBase.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\r\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol';\r\nimport {IFlashLoanReceiver} from '../interfaces/IFlashLoanReceiver.sol';\r\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\r\n\r\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\r\n  using SafeERC20 for IERC20;\r\n  using SafeMath for uint256;\r\n\r\n  ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\r\n  ILendingPool public immutable override LENDING_POOL;\r\n\r\n  constructor(ILendingPoolAddressesProvider provider) public {\r\n    ADDRESSES_PROVIDER = provider;\r\n    LENDING_POOL = ILendingPool(provider.getLendingPool());\r\n  }\r\n}\r\n"
      },
      "contracts/adapters/interfaces/IBaseUniswapAdapter.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\r\nimport {IUniswapV2Router02} from '../../interfaces/IUniswapV2Router02.sol';\r\n\r\ninterface IBaseUniswapAdapter {\r\n  event Swapped(address fromAsset, address toAsset, uint256 fromAmount, uint256 receivedAmount);\r\n\r\n  struct PermitSignature {\r\n    uint256 amount;\r\n    uint256 deadline;\r\n    uint8 v;\r\n    bytes32 r;\r\n    bytes32 s;\r\n  }\r\n\r\n  struct AmountCalc {\r\n    uint256 calculatedAmount;\r\n    uint256 relativePrice;\r\n    uint256 amountInUsd;\r\n    uint256 amountOutUsd;\r\n    address[] path;\r\n  }\r\n\r\n  function WETH_ADDRESS() external returns (address);\r\n\r\n  function MAX_SLIPPAGE_PERCENT() external returns (uint256);\r\n\r\n  function FLASHLOAN_PREMIUM_TOTAL() external returns (uint256);\r\n\r\n  function USD_ADDRESS() external returns (address);\r\n\r\n  function ORACLE() external returns (IPriceOracleGetter);\r\n\r\n  function UNISWAP_ROUTER() external returns (IUniswapV2Router02);\r\n\r\n  /**\r\n   * @dev Given an input asset amount, returns the maximum output amount of the other asset and the prices\r\n   * @param amountIn Amount of reserveIn\r\n   * @param reserveIn Address of the asset to be swap from\r\n   * @param reserveOut Address of the asset to be swap to\r\n   * @return uint256 Amount out of the reserveOut\r\n   * @return uint256 The price of out amount denominated in the reserveIn currency (18 decimals)\r\n   * @return uint256 In amount of reserveIn value denominated in USD (8 decimals)\r\n   * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals)\r\n   * @return address[] The exchange path\r\n   */\r\n  function getAmountsOut(\r\n    uint256 amountIn,\r\n    address reserveIn,\r\n    address reserveOut\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      address[] memory\r\n    );\r\n\r\n  /**\r\n   * @dev Returns the minimum input asset amount required to buy the given output asset amount and the prices\r\n   * @param amountOut Amount of reserveOut\r\n   * @param reserveIn Address of the asset to be swap from\r\n   * @param reserveOut Address of the asset to be swap to\r\n   * @return uint256 Amount in of the reserveIn\r\n   * @return uint256 The price of in amount denominated in the reserveOut currency (18 decimals)\r\n   * @return uint256 In amount of reserveIn value denominated in USD (8 decimals)\r\n   * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals)\r\n   * @return address[] The exchange path\r\n   */\r\n  function getAmountsIn(\r\n    uint256 amountOut,\r\n    address reserveIn,\r\n    address reserveOut\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      address[] memory\r\n    );\r\n}\r\n"
      },
      "contracts/protocol/libraries/helpers/Errors.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title Errors library\r\n * @author Aave\r\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\r\n * @dev Error messages prefix glossary:\r\n *  - VL = ValidationLogic\r\n *  - MATH = Math libraries\r\n *  - CT = Common errors between tokens (AToken, VariableDebtToken and StableDebtToken)\r\n *  - AT = AToken\r\n *  - SDT = StableDebtToken\r\n *  - VDT = VariableDebtToken\r\n *  - LP = LendingPool\r\n *  - LPAPR = LendingPoolAddressesProviderRegistry\r\n *  - LPC = LendingPoolConfiguration\r\n *  - RL = ReserveLogic\r\n *  - LPCM = LendingPoolCollateralManager\r\n *  - P = Pausable\r\n */\r\nlibrary Errors {\r\n  //common errors\r\n  string public constant CALLER_NOT_POOL_ADMIN = '33'; // 'The caller must be the pool admin'\r\n  string public constant BORROW_ALLOWANCE_NOT_ENOUGH = '59'; // User borrows on behalf, but allowance are too small\r\n\r\n  //contract specific errors\r\n  string public constant VL_INVALID_AMOUNT = '1'; // 'Amount must be greater than 0'\r\n  string public constant VL_NO_ACTIVE_RESERVE = '2'; // 'Action requires an active reserve'\r\n  string public constant VL_RESERVE_FROZEN = '3'; // 'Action cannot be performed because the reserve is frozen'\r\n  string public constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = '4'; // 'The current liquidity is not enough'\r\n  string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = '5'; // 'User cannot withdraw more than the available balance'\r\n  string public constant VL_TRANSFER_NOT_ALLOWED = '6'; // 'Transfer cannot be allowed.'\r\n  string public constant VL_BORROWING_NOT_ENABLED = '7'; // 'Borrowing is not enabled'\r\n  string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = '8'; // 'Invalid interest rate mode selected'\r\n  string public constant VL_COLLATERAL_BALANCE_IS_0 = '9'; // 'The collateral balance is 0'\r\n  string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '10'; // 'Health factor is lesser than the liquidation threshold'\r\n  string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = '11'; // 'There is not enough collateral to cover a new borrow'\r\n  string public constant VL_STABLE_BORROWING_NOT_ENABLED = '12'; // stable borrowing not enabled\r\n  string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = '13'; // collateral is (mostly) the same currency that is being borrowed\r\n  string public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '14'; // 'The requested amount is greater than the max loan size in stable rate mode\r\n  string public constant VL_NO_DEBT_OF_SELECTED_TYPE = '15'; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\r\n  string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '16'; // 'To repay on behalf of an user an explicit amount to repay is needed'\r\n  string public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = '17'; // 'User does not have a stable rate loan in progress on this reserve'\r\n  string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = '18'; // 'User does not have a variable rate loan in progress on this reserve'\r\n  string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = '19'; // 'The underlying balance needs to be greater than 0'\r\n  string public constant VL_DEPOSIT_ALREADY_IN_USE = '20'; // 'User deposit is already being used as collateral'\r\n  string public constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = '21'; // 'User does not have any stable rate loan for this reserve'\r\n  string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '22'; // 'Interest rate rebalance conditions were not met'\r\n  string public constant LP_LIQUIDATION_CALL_FAILED = '23'; // 'Liquidation call failed'\r\n  string public constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = '24'; // 'There is not enough liquidity available to borrow'\r\n  string public constant LP_REQUESTED_AMOUNT_TOO_SMALL = '25'; // 'The requested amount is too small for a FlashLoan.'\r\n  string public constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = '26'; // 'The actual balance of the protocol is inconsistent'\r\n  string public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = '27'; // 'The caller of the function is not the lending pool configurator'\r\n  string public constant LP_INCONSISTENT_FLASHLOAN_PARAMS = '28';\r\n  string public constant CT_CALLER_MUST_BE_LENDING_POOL = '29'; // 'The caller of this function must be a lending pool'\r\n  string public constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = '30'; // 'User cannot give allowance to himself'\r\n  string public constant CT_TRANSFER_AMOUNT_NOT_GT_0 = '31'; // 'Transferred amount needs to be greater than zero'\r\n  string public constant RL_RESERVE_ALREADY_INITIALIZED = '32'; // 'Reserve has already been initialized'\r\n  string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = '34'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_ATOKEN_POOL_ADDRESS = '35'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = '36'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = '37'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '38'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '39'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_ADDRESSES_PROVIDER_ID = '40'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_CONFIGURATION = '75'; // 'Invalid risk parameters for the reserve'\r\n  string public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = '76'; // 'The caller must be the emergency admin'\r\n  string public constant LPAPR_PROVIDER_NOT_REGISTERED = '41'; // 'Provider is not registered'\r\n  string public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '42'; // 'Health factor is not below the threshold'\r\n  string public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = '43'; // 'The collateral chosen cannot be liquidated'\r\n  string public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '44'; // 'User did not borrow the specified currency'\r\n  string public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = '45'; // \"There isn't enough liquidity available to liquidate\"\r\n  string public constant LPCM_NO_ERRORS = '46'; // 'No errors'\r\n  string public constant LP_INVALID_FLASHLOAN_MODE = '47'; //Invalid flashloan mode selected\r\n  string public constant MATH_MULTIPLICATION_OVERFLOW = '48';\r\n  string public constant MATH_ADDITION_OVERFLOW = '49';\r\n  string public constant MATH_DIVISION_BY_ZERO = '50';\r\n  string public constant RL_LIQUIDITY_INDEX_OVERFLOW = '51'; //  Liquidity index overflows uint128\r\n  string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = '52'; //  Variable borrow index overflows uint128\r\n  string public constant RL_LIQUIDITY_RATE_OVERFLOW = '53'; //  Liquidity rate overflows uint128\r\n  string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = '54'; //  Variable borrow rate overflows uint128\r\n  string public constant RL_STABLE_BORROW_RATE_OVERFLOW = '55'; //  Stable borrow rate overflows uint128\r\n  string public constant CT_INVALID_MINT_AMOUNT = '56'; //invalid amount to mint\r\n  string public constant LP_FAILED_REPAY_WITH_COLLATERAL = '57';\r\n  string public constant CT_INVALID_BURN_AMOUNT = '58'; //invalid amount to burn\r\n  string public constant LP_FAILED_COLLATERAL_SWAP = '60';\r\n  string public constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = '61';\r\n  string public constant LP_REENTRANCY_NOT_ALLOWED = '62';\r\n  string public constant LP_CALLER_MUST_BE_AN_ATOKEN = '63';\r\n  string public constant LP_IS_PAUSED = '64'; // 'Pool is paused'\r\n  string public constant LP_NO_MORE_RESERVES_ALLOWED = '65';\r\n  string public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = '66';\r\n  string public constant RC_INVALID_LTV = '67';\r\n  string public constant RC_INVALID_LIQ_THRESHOLD = '68';\r\n  string public constant RC_INVALID_LIQ_BONUS = '69';\r\n  string public constant RC_INVALID_DECIMALS = '70';\r\n  string public constant RC_INVALID_RESERVE_FACTOR = '71';\r\n  string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = '72';\r\n  string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = '73';\r\n  string public constant LP_INCONSISTENT_PARAMS_LENGTH = '74';\r\n  string public constant UL_INVALID_INDEX = '77';\r\n  string public constant LP_NOT_CONTRACT = '78';\r\n  string public constant SDT_STABLE_DEBT_OVERFLOW = '79';\r\n  string public constant SDT_BURN_EXCEEDS_BALANCE = '80';\r\n\r\n  enum CollateralManagerErrors {\r\n    NO_ERROR,\r\n    NO_COLLATERAL_AVAILABLE,\r\n    COLLATERAL_CANNOT_BE_LIQUIDATED,\r\n    CURRRENCY_NOT_BORROWED,\r\n    HEALTH_FACTOR_ABOVE_THRESHOLD,\r\n    NOT_ENOUGH_LIQUIDITY,\r\n    NO_ACTIVE_RESERVE,\r\n    HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\r\n    INVALID_EQUAL_ASSETS_TO_SWAP,\r\n    FROZEN_RESERVE\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/contracts/Address.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * It is unsafe to assume that an address for which this function returns\r\n   * false is an externally-owned account (EOA) and not a contract.\r\n   *\r\n   * Among others, `isContract` will return false for the following\r\n   * types of addresses:\r\n   *\r\n   *  - an externally-owned account\r\n   *  - a contract in construction\r\n   *  - an address where a contract will be created\r\n   *  - an address where a contract lived, but was destroyed\r\n   * ====\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256('')`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      codehash := extcodehash(account)\r\n    }\r\n    return (codehash != accountHash && codehash != 0x0);\r\n  }\r\n\r\n  /**\r\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n   * `recipient`, forwarding all available gas and reverting on errors.\r\n   *\r\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n   * imposed by `transfer`, making them unable to receive funds via\r\n   * `transfer`. {sendValue} removes this limitation.\r\n   *\r\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n   *\r\n   * IMPORTANT: because control is transferred to `recipient`, care must be\r\n   * taken to not create reentrancy vulnerabilities. Consider using\r\n   * {ReentrancyGuard} or the\r\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n   */\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n    (bool success, ) = recipient.call{value: amount}('');\r\n    require(success, 'Address: unable to send value, recipient may have reverted');\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/contracts/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n"
      },
      "contracts/flashloan/interfaces/IFlashLoanReceiver.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\r\n\r\n/**\r\n * @title IFlashLoanReceiver interface\r\n * @notice Interface for the Aave fee IFlashLoanReceiver.\r\n * @author Aave\r\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\r\n **/\r\ninterface IFlashLoanReceiver {\r\n  function executeOperation(\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata premiums,\r\n    address initiator,\r\n    bytes calldata params\r\n  ) external returns (bool);\r\n\r\n  function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\r\n\r\n  function LENDING_POOL() external view returns (ILendingPool);\r\n}\r\n"
      },
      "contracts/interfaces/ILendingPool.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\r\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\r\n\r\ninterface ILendingPool {\r\n  /**\r\n   * @dev Emitted on deposit()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address initiating the deposit\r\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\r\n   * @param amount The amount deposited\r\n   * @param referral The referral code used\r\n   **/\r\n  event Deposit(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint16 indexed referral\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on withdraw()\r\n   * @param reserve The address of the underlyng asset being withdrawn\r\n   * @param user The address initiating the withdrawal, owner of aTokens\r\n   * @param to Address that will receive the underlying\r\n   * @param amount The amount to be withdrawn\r\n   **/\r\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\r\n\r\n  /**\r\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n   * @param reserve The address of the underlying asset being borrowed\r\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n   * initiator of the transaction on flashLoan()\r\n   * @param onBehalfOf The address that will be getting the debt\r\n   * @param amount The amount borrowed out\r\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\r\n   * @param borrowRate The numeric rate at which the user has borrowed\r\n   * @param referral The referral code used\r\n   **/\r\n  event Borrow(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint256 borrowRateMode,\r\n    uint256 borrowRate,\r\n    uint16 indexed referral\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on repay()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The beneficiary of the repayment, getting his debt reduced\r\n   * @param repayer The address of the user initiating the repay(), providing the funds\r\n   * @param amount The amount repaid\r\n   **/\r\n  event Repay(\r\n    address indexed reserve,\r\n    address indexed user,\r\n    address indexed repayer,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on swapBorrowRateMode()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user swapping his rate mode\r\n   * @param rateMode The rate mode that the user wants to swap to\r\n   **/\r\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   **/\r\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   **/\r\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on rebalanceStableBorrowRate()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user for which the rebalance has been executed\r\n   **/\r\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on flashLoan()\r\n   * @param target The address of the flash loan receiver contract\r\n   * @param initiator The address initiating the flash loan\r\n   * @param asset The address of the asset being flash borrowed\r\n   * @param amount The amount flash borrowed\r\n   * @param premium The fee flash borrowed\r\n   * @param referralCode The referral code used\r\n   **/\r\n  event FlashLoan(\r\n    address indexed target,\r\n    address indexed initiator,\r\n    address indexed asset,\r\n    uint256 amount,\r\n    uint256 premium,\r\n    uint16 referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the pause is triggered.\r\n   */\r\n  event Paused();\r\n\r\n  /**\r\n   * @dev Emitted when the pause is lifted.\r\n   */\r\n  event Unpaused();\r\n\r\n  /**\r\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\r\n   * LendingPoolCollateral manager using a DELEGATECALL\r\n   * This allows to have the events in the generated ABI for LendingPool.\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\r\n   * @param liquidator The address of the liquidator\r\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  event LiquidationCall(\r\n    address indexed collateralAsset,\r\n    address indexed debtAsset,\r\n    address indexed user,\r\n    uint256 debtToCover,\r\n    uint256 liquidatedCollateralAmount,\r\n    address liquidator,\r\n    bool receiveAToken\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\r\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\r\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\r\n   * gets added to the LendingPool ABI\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param liquidityRate The new liquidity rate\r\n   * @param stableBorrowRate The new stable borrow rate\r\n   * @param variableBorrowRate The new variable borrow rate\r\n   * @param liquidityIndex The new liquidity index\r\n   * @param variableBorrowIndex The new variable borrow index\r\n   **/\r\n  event ReserveDataUpdated(\r\n    address indexed reserve,\r\n    uint256 liquidityRate,\r\n    uint256 stableBorrowRate,\r\n    uint256 variableBorrowRate,\r\n    uint256 liquidityIndex,\r\n    uint256 variableBorrowIndex\r\n  );\r\n\r\n  /**\r\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n   * @param asset The address of the underlying asset to deposit\r\n   * @param amount The amount to be deposited\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function deposit(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n   * @param asset The address of the underlying asset to withdraw\r\n   * @param amount The underlying amount to be withdrawn\r\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n   * @param to Address that will receive the underlying, same as msg.sender if the user\r\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n   *   different wallet\r\n   * @return The final amount withdrawn\r\n   **/\r\n  function withdraw(\r\n    address asset,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n   * @param asset The address of the underlying asset to borrow\r\n   * @param amount The amount to be borrowed\r\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n   * if he has been given credit delegation allowance\r\n   **/\r\n  function borrow(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    uint16 referralCode,\r\n    address onBehalfOf\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n   * other borrower whose debt should be removed\r\n   * @return The final amount repaid\r\n   **/\r\n  function repay(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 rateMode,\r\n    address onBehalfOf\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param rateMode The rate mode that the user wants to swap to\r\n   **/\r\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\r\n\r\n  /**\r\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n   * - Users can be rebalanced if the following conditions are satisfied:\r\n   *     1. Usage ratio is above 95%\r\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\r\n   *        borrowed at a stable rate and depositors are not earning enough\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param user The address of the user to be rebalanced\r\n   **/\r\n  function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n  /**\r\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n   * @param asset The address of the underlying asset deposited\r\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n   **/\r\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\r\n\r\n  /**\r\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  function liquidationCall(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool receiveAToken\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n   * as long as the amount taken plus a fee is returned.\r\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n   * For further details please visit https://developers.aave.com\r\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n   * @param assets The addresses of the assets being flash-borrowed\r\n   * @param amounts The amounts amounts being flash-borrowed\r\n   * @param modes Types of the debt to open if the flash loan is not returned:\r\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n   * @param params Variadic packed params to pass to the receiver as extra information\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function flashLoan(\r\n    address receiverAddress,\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata modes,\r\n    address onBehalfOf,\r\n    bytes calldata params,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns the user account data across all the reserves\r\n   * @param user The address of the user\r\n   * @return totalCollateralETH the total collateral in ETH of the user\r\n   * @return totalDebtETH the total debt in ETH of the user\r\n   * @return availableBorrowsETH the borrowing power left of the user\r\n   * @return currentLiquidationThreshold the liquidation threshold of the user\r\n   * @return ltv the loan to value of the user\r\n   * @return healthFactor the current health factor of the user\r\n   **/\r\n  function getUserAccountData(address user)\r\n    external\r\n    view\r\n    returns (\r\n      uint256 totalCollateralETH,\r\n      uint256 totalDebtETH,\r\n      uint256 availableBorrowsETH,\r\n      uint256 currentLiquidationThreshold,\r\n      uint256 ltv,\r\n      uint256 healthFactor\r\n    );\r\n\r\n  function initReserve(\r\n    address reserve,\r\n    address aTokenAddress,\r\n    address stableDebtAddress,\r\n    address variableDebtAddress,\r\n    address interestRateStrategyAddress\r\n  ) external;\r\n\r\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\r\n    external;\r\n\r\n  function setConfiguration(address reserve, uint256 configuration) external;\r\n\r\n  /**\r\n   * @dev Returns the configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The configuration of the reserve\r\n   **/\r\n  function getConfiguration(address asset)\r\n    external\r\n    view\r\n    returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n  /**\r\n   * @dev Returns the configuration of the user across all the reserves\r\n   * @param user The user address\r\n   * @return The configuration of the user\r\n   **/\r\n  function getUserConfiguration(address user)\r\n    external\r\n    view\r\n    returns (DataTypes.UserConfigurationMap memory);\r\n\r\n  /**\r\n   * @dev Returns the normalized income normalized income of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve's normalized income\r\n   */\r\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the normalized variable debt per unit of asset\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve normalized variable debt\r\n   */\r\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the state and configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The state of the reserve\r\n   **/\r\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\r\n\r\n  function finalizeTransfer(\r\n    address asset,\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    uint256 balanceFromAfter,\r\n    uint256 balanceToBefore\r\n  ) external;\r\n\r\n  function getReservesList() external view returns (address[] memory);\r\n\r\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\r\n\r\n  function setPause(bool val) external;\r\n\r\n  function paused() external view returns (bool);\r\n}\r\n"
      },
      "contracts/adapters/UniswapRepayAdapter.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {BaseUniswapAdapter} from './BaseUniswapAdapter.sol';\r\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol';\r\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\r\n\r\n/**\r\n * @title UniswapRepayAdapter\r\n * @notice Uniswap V2 Adapter to perform a repay of a debt with collateral.\r\n * @author Aave\r\n **/\r\ncontract UniswapRepayAdapter is BaseUniswapAdapter {\r\n  struct RepayParams {\r\n    address collateralAsset;\r\n    uint256 collateralAmount;\r\n    uint256 rateMode;\r\n    PermitSignature permitSignature;\r\n    bool useEthPath;\r\n  }\r\n\r\n  constructor(\r\n    ILendingPoolAddressesProvider addressesProvider,\r\n    IUniswapV2Router02 uniswapRouter,\r\n    address wethAddress\r\n  ) public BaseUniswapAdapter(addressesProvider, uniswapRouter, wethAddress) {}\r\n\r\n  /**\r\n   * @dev Uses the received funds from the flash loan to repay a debt on the protocol on behalf of the user. Then pulls\r\n   * the collateral from the user and swaps it to the debt asset to repay the flash loan.\r\n   * The user should give this contract allowance to pull the ATokens in order to withdraw the underlying asset, swap it\r\n   * and repay the flash loan.\r\n   * Supports only one asset on the flash loan.\r\n   * @param assets Address of debt asset\r\n   * @param amounts Amount of the debt to be repaid\r\n   * @param premiums Fee of the flash loan\r\n   * @param initiator Address of the user\r\n   * @param params Additional variadic field to include extra params. Expected parameters:\r\n   *   address collateralAsset Address of the reserve to be swapped\r\n   *   uint256 collateralAmount Amount of reserve to be swapped\r\n   *   uint256 rateMode Rate modes of the debt to be repaid\r\n   *   uint256 permitAmount Amount for the permit signature\r\n   *   uint256 deadline Deadline for the permit signature\r\n   *   uint8 v V param for the permit signature\r\n   *   bytes32 r R param for the permit signature\r\n   *   bytes32 s S param for the permit signature\r\n   */\r\n  function executeOperation(\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata premiums,\r\n    address initiator,\r\n    bytes calldata params\r\n  ) external override returns (bool) {\r\n    require(msg.sender == address(LENDING_POOL), 'CALLER_MUST_BE_LENDING_POOL');\r\n\r\n    RepayParams memory decodedParams = _decodeParams(params);\r\n\r\n    _swapAndRepay(\r\n      decodedParams.collateralAsset,\r\n      assets[0],\r\n      amounts[0],\r\n      decodedParams.collateralAmount,\r\n      decodedParams.rateMode,\r\n      initiator,\r\n      premiums[0],\r\n      decodedParams.permitSignature,\r\n      decodedParams.useEthPath\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Swaps the user collateral for the debt asset and then repay the debt on the protocol on behalf of the user\r\n   * without using flash loans. This method can be used when the temporary transfer of the collateral asset to this\r\n   * contract does not affect the user position.\r\n   * The user should give this contract allowance to pull the ATokens in order to withdraw the underlying asset\r\n   * @param collateralAsset Address of asset to be swapped\r\n   * @param debtAsset Address of debt asset\r\n   * @param collateralAmount Amount of the collateral to be swapped\r\n   * @param debtRepayAmount Amount of the debt to be repaid\r\n   * @param debtRateMode Rate mode of the debt to be repaid\r\n   * @param permitSignature struct containing the permit signature\r\n   * @param useEthPath struct containing the permit signature\r\n\r\n   */\r\n  function swapAndRepay(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    uint256 collateralAmount,\r\n    uint256 debtRepayAmount,\r\n    uint256 debtRateMode,\r\n    PermitSignature calldata permitSignature,\r\n    bool useEthPath\r\n  ) external {\r\n    DataTypes.ReserveData memory collateralReserveData = _getReserveData(collateralAsset);\r\n    DataTypes.ReserveData memory debtReserveData = _getReserveData(debtAsset);\r\n\r\n    address debtToken =\r\n      DataTypes.InterestRateMode(debtRateMode) == DataTypes.InterestRateMode.STABLE\r\n        ? debtReserveData.stableDebtTokenAddress\r\n        : debtReserveData.variableDebtTokenAddress;\r\n\r\n    uint256 currentDebt = IERC20(debtToken).balanceOf(msg.sender);\r\n    uint256 amountToRepay = debtRepayAmount <= currentDebt ? debtRepayAmount : currentDebt;\r\n\r\n    if (collateralAsset != debtAsset) {\r\n      uint256 maxCollateralToSwap = collateralAmount;\r\n      if (amountToRepay < debtRepayAmount) {\r\n        maxCollateralToSwap = maxCollateralToSwap.mul(amountToRepay).div(debtRepayAmount);\r\n      }\r\n\r\n      // Get exact collateral needed for the swap to avoid leftovers\r\n      uint256[] memory amounts =\r\n        _getAmountsIn(collateralAsset, debtAsset, amountToRepay, useEthPath);\r\n      require(amounts[0] <= maxCollateralToSwap, 'slippage too high');\r\n\r\n      // Pull aTokens from user\r\n      _pullAToken(\r\n        collateralAsset,\r\n        collateralReserveData.aTokenAddress,\r\n        msg.sender,\r\n        amounts[0],\r\n        permitSignature\r\n      );\r\n\r\n      // Swap collateral for debt asset\r\n      _swapTokensForExactTokens(collateralAsset, debtAsset, amounts[0], amountToRepay, useEthPath);\r\n    } else {\r\n      // Pull aTokens from user\r\n      _pullAToken(\r\n        collateralAsset,\r\n        collateralReserveData.aTokenAddress,\r\n        msg.sender,\r\n        amountToRepay,\r\n        permitSignature\r\n      );\r\n    }\r\n\r\n    // Repay debt. Approves 0 first to comply with tokens that implement the anti frontrunning approval fix\r\n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), 0);\r\n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), amountToRepay);\r\n    LENDING_POOL.repay(debtAsset, amountToRepay, debtRateMode, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Perform the repay of the debt, pulls the initiator collateral and swaps to repay the flash loan\r\n   *\r\n   * @param collateralAsset Address of token to be swapped\r\n   * @param debtAsset Address of debt token to be received from the swap\r\n   * @param amount Amount of the debt to be repaid\r\n   * @param collateralAmount Amount of the reserve to be swapped\r\n   * @param rateMode Rate mode of the debt to be repaid\r\n   * @param initiator Address of the user\r\n   * @param premium Fee of the flash loan\r\n   * @param permitSignature struct containing the permit signature\r\n   */\r\n  function _swapAndRepay(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    uint256 amount,\r\n    uint256 collateralAmount,\r\n    uint256 rateMode,\r\n    address initiator,\r\n    uint256 premium,\r\n    PermitSignature memory permitSignature,\r\n    bool useEthPath\r\n  ) internal {\r\n    DataTypes.ReserveData memory collateralReserveData = _getReserveData(collateralAsset);\r\n\r\n    // Repay debt. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\r\n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), 0);\r\n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), amount);\r\n    uint256 repaidAmount = IERC20(debtAsset).balanceOf(address(this));\r\n    LENDING_POOL.repay(debtAsset, amount, rateMode, initiator);\r\n    repaidAmount = repaidAmount.sub(IERC20(debtAsset).balanceOf(address(this)));\r\n\r\n    if (collateralAsset != debtAsset) {\r\n      uint256 maxCollateralToSwap = collateralAmount;\r\n      if (repaidAmount < amount) {\r\n        maxCollateralToSwap = maxCollateralToSwap.mul(repaidAmount).div(amount);\r\n      }\r\n\r\n      uint256 neededForFlashLoanDebt = repaidAmount.add(premium);\r\n      uint256[] memory amounts =\r\n        _getAmountsIn(collateralAsset, debtAsset, neededForFlashLoanDebt, useEthPath);\r\n      require(amounts[0] <= maxCollateralToSwap, 'slippage too high');\r\n\r\n      // Pull aTokens from user\r\n      _pullAToken(\r\n        collateralAsset,\r\n        collateralReserveData.aTokenAddress,\r\n        initiator,\r\n        amounts[0],\r\n        permitSignature\r\n      );\r\n\r\n      // Swap collateral asset to the debt asset\r\n      _swapTokensForExactTokens(\r\n        collateralAsset,\r\n        debtAsset,\r\n        amounts[0],\r\n        neededForFlashLoanDebt,\r\n        useEthPath\r\n      );\r\n    } else {\r\n      // Pull aTokens from user\r\n      _pullAToken(\r\n        collateralAsset,\r\n        collateralReserveData.aTokenAddress,\r\n        initiator,\r\n        repaidAmount.add(premium),\r\n        permitSignature\r\n      );\r\n    }\r\n\r\n    // Repay flashloan. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\r\n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), 0);\r\n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), amount.add(premium));\r\n  }\r\n\r\n  /**\r\n   * @dev Decodes debt information encoded in the flash loan params\r\n   * @param params Additional variadic field to include extra params. Expected parameters:\r\n   *   address collateralAsset Address of the reserve to be swapped\r\n   *   uint256 collateralAmount Amount of reserve to be swapped\r\n   *   uint256 rateMode Rate modes of the debt to be repaid\r\n   *   uint256 permitAmount Amount for the permit signature\r\n   *   uint256 deadline Deadline for the permit signature\r\n   *   uint8 v V param for the permit signature\r\n   *   bytes32 r R param for the permit signature\r\n   *   bytes32 s S param for the permit signature\r\n   *   bool useEthPath use WETH path route\r\n   * @return RepayParams struct containing decoded params\r\n   */\r\n  function _decodeParams(bytes memory params) internal pure returns (RepayParams memory) {\r\n    (\r\n      address collateralAsset,\r\n      uint256 collateralAmount,\r\n      uint256 rateMode,\r\n      uint256 permitAmount,\r\n      uint256 deadline,\r\n      uint8 v,\r\n      bytes32 r,\r\n      bytes32 s,\r\n      bool useEthPath\r\n    ) =\r\n      abi.decode(\r\n        params,\r\n        (address, uint256, uint256, uint256, uint256, uint8, bytes32, bytes32, bool)\r\n      );\r\n\r\n    return\r\n      RepayParams(\r\n        collateralAsset,\r\n        collateralAmount,\r\n        rateMode,\r\n        PermitSignature(permitAmount, deadline, v, r, s),\r\n        useEthPath\r\n      );\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/lendingpool/LendingPoolCollateralManager.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts//SafeMath.sol';\r\nimport {IERC20} from '../../dependencies/openzeppelin/contracts//IERC20.sol';\r\nimport {IAToken} from '../../interfaces/IAToken.sol';\r\nimport {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol';\r\nimport {IVariableDebtToken} from '../../interfaces/IVariableDebtToken.sol';\r\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\r\nimport {ILendingPoolCollateralManager} from '../../interfaces/ILendingPoolCollateralManager.sol';\r\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\r\nimport {GenericLogic} from '../libraries/logic/GenericLogic.sol';\r\nimport {Helpers} from '../libraries/helpers/Helpers.sol';\r\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\r\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\r\nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol';\r\nimport {Errors} from '../libraries/helpers/Errors.sol';\r\nimport {ValidationLogic} from '../libraries/logic/ValidationLogic.sol';\r\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\r\nimport {LendingPoolStorage} from './LendingPoolStorage.sol';\r\n\r\n/**\r\n * @title LendingPoolCollateralManager contract\r\n * @author Aave\r\n * @dev Implements actions involving management of collateral in the protocol, the main one being the liquidations\r\n * IMPORTANT This contract will run always via DELEGATECALL, through the LendingPool, so the chain of inheritance\r\n * is the same as the LendingPool, to have compatible storage layouts\r\n **/\r\ncontract LendingPoolCollateralManager is\r\n  ILendingPoolCollateralManager,\r\n  VersionedInitializable,\r\n  LendingPoolStorage\r\n{\r\n  using SafeERC20 for IERC20;\r\n  using SafeMath for uint256;\r\n  using WadRayMath for uint256;\r\n  using PercentageMath for uint256;\r\n\r\n  uint256 internal constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 5000;\r\n\r\n  struct LiquidationCallLocalVars {\r\n    uint256 userCollateralBalance;\r\n    uint256 userStableDebt;\r\n    uint256 userVariableDebt;\r\n    uint256 maxLiquidatableDebt;\r\n    uint256 actualDebtToLiquidate;\r\n    uint256 liquidationRatio;\r\n    uint256 maxAmountCollateralToLiquidate;\r\n    uint256 userStableRate;\r\n    uint256 maxCollateralToLiquidate;\r\n    uint256 debtAmountNeeded;\r\n    uint256 healthFactor;\r\n    uint256 liquidatorPreviousATokenBalance;\r\n    IAToken collateralAtoken;\r\n    bool isCollateralEnabled;\r\n    DataTypes.InterestRateMode borrowRateMode;\r\n    uint256 errorCode;\r\n    string errorMsg;\r\n  }\r\n\r\n  /**\r\n   * @dev As thIS contract extends the VersionedInitializable contract to match the state\r\n   * of the LendingPool contract, the getRevision() function is needed, but the value is not\r\n   * important, as the initialize() function will never be called here\r\n   */\r\n  function getRevision() internal pure override returns (uint256) {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to liquidate a position if its Health Factor drops below 1\r\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  function liquidationCall(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool receiveAToken\r\n  ) external override returns (uint256, string memory) {\r\n    DataTypes.ReserveData storage collateralReserve = _reserves[collateralAsset];\r\n    DataTypes.ReserveData storage debtReserve = _reserves[debtAsset];\r\n    DataTypes.UserConfigurationMap storage userConfig = _usersConfig[user];\r\n\r\n    LiquidationCallLocalVars memory vars;\r\n\r\n    (, , , , vars.healthFactor) = GenericLogic.calculateUserAccountData(\r\n      user,\r\n      _reserves,\r\n      userConfig,\r\n      _reservesList,\r\n      _reservesCount,\r\n      _addressesProvider.getPriceOracle()\r\n    );\r\n\r\n    (vars.userStableDebt, vars.userVariableDebt) = Helpers.getUserCurrentDebt(user, debtReserve);\r\n\r\n    (vars.errorCode, vars.errorMsg) = ValidationLogic.validateLiquidationCall(\r\n      collateralReserve,\r\n      debtReserve,\r\n      userConfig,\r\n      vars.healthFactor,\r\n      vars.userStableDebt,\r\n      vars.userVariableDebt\r\n    );\r\n\r\n    if (Errors.CollateralManagerErrors(vars.errorCode) != Errors.CollateralManagerErrors.NO_ERROR) {\r\n      return (vars.errorCode, vars.errorMsg);\r\n    }\r\n\r\n    vars.collateralAtoken = IAToken(collateralReserve.aTokenAddress);\r\n\r\n    vars.userCollateralBalance = vars.collateralAtoken.balanceOf(user);\r\n\r\n    vars.maxLiquidatableDebt = vars.userStableDebt.add(vars.userVariableDebt).percentMul(\r\n      LIQUIDATION_CLOSE_FACTOR_PERCENT\r\n    );\r\n\r\n    vars.actualDebtToLiquidate = debtToCover > vars.maxLiquidatableDebt\r\n      ? vars.maxLiquidatableDebt\r\n      : debtToCover;\r\n\r\n    (\r\n      vars.maxCollateralToLiquidate,\r\n      vars.debtAmountNeeded\r\n    ) = _calculateAvailableCollateralToLiquidate(\r\n      collateralReserve,\r\n      debtReserve,\r\n      collateralAsset,\r\n      debtAsset,\r\n      vars.actualDebtToLiquidate,\r\n      vars.userCollateralBalance\r\n    );\r\n\r\n    // If debtAmountNeeded < actualDebtToLiquidate, there isn't enough\r\n    // collateral to cover the actual amount that is being liquidated, hence we liquidate\r\n    // a smaller amount\r\n\r\n    if (vars.debtAmountNeeded < vars.actualDebtToLiquidate) {\r\n      vars.actualDebtToLiquidate = vars.debtAmountNeeded;\r\n    }\r\n\r\n    // If the liquidator reclaims the underlying asset, we make sure there is enough available liquidity in the\r\n    // collateral reserve\r\n    if (!receiveAToken) {\r\n      uint256 currentAvailableCollateral =\r\n        IERC20(collateralAsset).balanceOf(address(vars.collateralAtoken));\r\n      if (currentAvailableCollateral < vars.maxCollateralToLiquidate) {\r\n        return (\r\n          uint256(Errors.CollateralManagerErrors.NOT_ENOUGH_LIQUIDITY),\r\n          Errors.LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE\r\n        );\r\n      }\r\n    }\r\n\r\n    debtReserve.updateState();\r\n\r\n    if (vars.userVariableDebt >= vars.actualDebtToLiquidate) {\r\n      IVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\r\n        user,\r\n        vars.actualDebtToLiquidate,\r\n        debtReserve.variableBorrowIndex\r\n      );\r\n    } else {\r\n      // If the user doesn't have variable debt, no need to try to burn variable debt tokens\r\n      if (vars.userVariableDebt > 0) {\r\n        IVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\r\n          user,\r\n          vars.userVariableDebt,\r\n          debtReserve.variableBorrowIndex\r\n        );\r\n      }\r\n      IStableDebtToken(debtReserve.stableDebtTokenAddress).burn(\r\n        user,\r\n        vars.actualDebtToLiquidate.sub(vars.userVariableDebt)\r\n      );\r\n    }\r\n\r\n    debtReserve.updateInterestRates(\r\n      debtAsset,\r\n      debtReserve.aTokenAddress,\r\n      vars.actualDebtToLiquidate,\r\n      0\r\n    );\r\n\r\n    if (receiveAToken) {\r\n      vars.liquidatorPreviousATokenBalance = IERC20(vars.collateralAtoken).balanceOf(msg.sender);\r\n      vars.collateralAtoken.transferOnLiquidation(user, msg.sender, vars.maxCollateralToLiquidate);\r\n\r\n      if (vars.liquidatorPreviousATokenBalance == 0) {\r\n        DataTypes.UserConfigurationMap storage liquidatorConfig = _usersConfig[msg.sender];\r\n        liquidatorConfig.setUsingAsCollateral(collateralReserve.id, true);\r\n        emit ReserveUsedAsCollateralEnabled(collateralAsset, msg.sender);\r\n      }\r\n    } else {\r\n      collateralReserve.updateState();\r\n      collateralReserve.updateInterestRates(\r\n        collateralAsset,\r\n        address(vars.collateralAtoken),\r\n        0,\r\n        vars.maxCollateralToLiquidate\r\n      );\r\n\r\n      // Burn the equivalent amount of aToken, sending the underlying to the liquidator\r\n      vars.collateralAtoken.burn(\r\n        user,\r\n        msg.sender,\r\n        vars.maxCollateralToLiquidate,\r\n        collateralReserve.liquidityIndex\r\n      );\r\n    }\r\n\r\n    // If the collateral being liquidated is equal to the user balance,\r\n    // we set the currency as not being used as collateral anymore\r\n    if (vars.maxCollateralToLiquidate == vars.userCollateralBalance) {\r\n      userConfig.setUsingAsCollateral(collateralReserve.id, false);\r\n      emit ReserveUsedAsCollateralDisabled(collateralAsset, user);\r\n    }\r\n\r\n    // Transfers the debt asset being repaid to the aToken, where the liquidity is kept\r\n    IERC20(debtAsset).safeTransferFrom(\r\n      msg.sender,\r\n      debtReserve.aTokenAddress,\r\n      vars.actualDebtToLiquidate\r\n    );\r\n\r\n    emit LiquidationCall(\r\n      collateralAsset,\r\n      debtAsset,\r\n      user,\r\n      vars.actualDebtToLiquidate,\r\n      vars.maxCollateralToLiquidate,\r\n      msg.sender,\r\n      receiveAToken\r\n    );\r\n\r\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS);\r\n  }\r\n\r\n  struct AvailableCollateralToLiquidateLocalVars {\r\n    uint256 userCompoundedBorrowBalance;\r\n    uint256 liquidationBonus;\r\n    uint256 collateralPrice;\r\n    uint256 debtAssetPrice;\r\n    uint256 maxAmountCollateralToLiquidate;\r\n    uint256 debtAssetDecimals;\r\n    uint256 collateralDecimals;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates how much of a specific collateral can be liquidated, given\r\n   * a certain amount of debt asset.\r\n   * - This function needs to be called after all the checks to validate the liquidation have been performed,\r\n   *   otherwise it might fail.\r\n   * @param collateralReserve The data of the collateral reserve\r\n   * @param debtReserve The data of the debt reserve\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param userCollateralBalance The collateral balance for the specific `collateralAsset` of the user being liquidated\r\n   * @return collateralAmount: The maximum amount that is possible to liquidate given all the liquidation constraints\r\n   *                           (user balance, close factor)\r\n   *         debtAmountNeeded: The amount to repay with the liquidation\r\n   **/\r\n  function _calculateAvailableCollateralToLiquidate(\r\n    DataTypes.ReserveData storage collateralReserve,\r\n    DataTypes.ReserveData storage debtReserve,\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    uint256 debtToCover,\r\n    uint256 userCollateralBalance\r\n  ) internal view returns (uint256, uint256) {\r\n    uint256 collateralAmount = 0;\r\n    uint256 debtAmountNeeded = 0;\r\n    IPriceOracleGetter oracle = IPriceOracleGetter(_addressesProvider.getPriceOracle());\r\n\r\n    AvailableCollateralToLiquidateLocalVars memory vars;\r\n\r\n    vars.collateralPrice = oracle.getAssetPrice(collateralAsset);\r\n    vars.debtAssetPrice = oracle.getAssetPrice(debtAsset);\r\n\r\n    (, , vars.liquidationBonus, vars.collateralDecimals, ) = collateralReserve\r\n      .configuration\r\n      .getParams();\r\n    vars.debtAssetDecimals = debtReserve.configuration.getDecimals();\r\n\r\n    // This is the maximum possible amount of the selected collateral that can be liquidated, given the\r\n    // max amount of liquidatable debt\r\n    vars.maxAmountCollateralToLiquidate = vars\r\n      .debtAssetPrice\r\n      .mul(debtToCover)\r\n      .mul(10**vars.collateralDecimals)\r\n      .percentMul(vars.liquidationBonus)\r\n      .div(vars.collateralPrice.mul(10**vars.debtAssetDecimals));\r\n\r\n    if (vars.maxAmountCollateralToLiquidate > userCollateralBalance) {\r\n      collateralAmount = userCollateralBalance;\r\n      debtAmountNeeded = vars\r\n        .collateralPrice\r\n        .mul(collateralAmount)\r\n        .mul(10**vars.debtAssetDecimals)\r\n        .div(vars.debtAssetPrice.mul(10**vars.collateralDecimals))\r\n        .percentDiv(vars.liquidationBonus);\r\n    } else {\r\n      collateralAmount = vars.maxAmountCollateralToLiquidate;\r\n      debtAmountNeeded = debtToCover;\r\n    }\r\n    return (collateralAmount, debtAmountNeeded);\r\n  }\r\n}\r\n"
      },
      "contracts/interfaces/IAToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\r\nimport {IInitializableAToken} from './IInitializableAToken.sol';\r\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\r\n\r\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\r\n  /**\r\n   * @dev Emitted after the mint action\r\n   * @param from The address performing the mint\r\n   * @param value The amount being\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event Mint(address indexed from, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Mints `amount` aTokens to `user`\r\n   * @param user The address receiving the minted tokens\r\n   * @param amount The amount of tokens getting minted\r\n   * @param index The new liquidity index of the reserve\r\n   * @return `true` if the the previous balance of the user was 0\r\n   */\r\n  function mint(\r\n    address user,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted after aTokens are burned\r\n   * @param from The owner of the aTokens, getting them burned\r\n   * @param target The address that will receive the underlying\r\n   * @param value The amount being burned\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Emitted during the transfer action\r\n   * @param from The user whose tokens are being transferred\r\n   * @param to The recipient\r\n   * @param value The amount being transferred\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\r\n   * @param user The owner of the aTokens, getting them burned\r\n   * @param receiverOfUnderlying The address that will receive the underlying\r\n   * @param amount The amount being burned\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  function burn(\r\n    address user,\r\n    address receiverOfUnderlying,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Mints aTokens to the reserve treasury\r\n   * @param amount The amount of tokens getting minted\r\n   * @param index The new liquidity index of the reserve\r\n   */\r\n  function mintToTreasury(uint256 amount, uint256 index) external;\r\n\r\n  /**\r\n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\r\n   * @param from The address getting liquidated, current owner of the aTokens\r\n   * @param to The recipient\r\n   * @param value The amount of tokens getting transferred\r\n   **/\r\n  function transferOnLiquidation(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\r\n   * assets in borrow(), withdraw() and flashLoan()\r\n   * @param user The recipient of the underlying\r\n   * @param amount The amount getting transferred\r\n   * @return The amount transferred\r\n   **/\r\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Invoked to execute actions on the aToken side after a repayment.\r\n   * @param user The user executing the repayment\r\n   * @param amount The amount getting repaid\r\n   **/\r\n  function handleRepayment(address user, uint256 amount) external;\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view returns (IAaveIncentivesController);\r\n}\r\n"
      },
      "contracts/interfaces/IStableDebtToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol';\r\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\r\n\r\n/**\r\n * @title IStableDebtToken\r\n * @notice Defines the interface for the stable debt token\r\n * @dev It does not inherit from IERC20 to save in code size\r\n * @author Aave\r\n **/\r\n\r\ninterface IStableDebtToken is IInitializableDebtToken {\r\n  /**\r\n   * @dev Emitted when new stable debt is minted\r\n   * @param user The address of the user who triggered the minting\r\n   * @param onBehalfOf The recipient of stable debt tokens\r\n   * @param amount The amount minted\r\n   * @param currentBalance The current balance of the user\r\n   * @param balanceIncrease The increase in balance since the last action of the user\r\n   * @param newRate The rate of the debt after the minting\r\n   * @param avgStableRate The new average stable rate after the minting\r\n   * @param newTotalSupply The new total supply of the stable debt token after the action\r\n   **/\r\n  event Mint(\r\n    address indexed user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint256 currentBalance,\r\n    uint256 balanceIncrease,\r\n    uint256 newRate,\r\n    uint256 avgStableRate,\r\n    uint256 newTotalSupply\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when new stable debt is burned\r\n   * @param user The address of the user\r\n   * @param amount The amount being burned\r\n   * @param currentBalance The current balance of the user\r\n   * @param balanceIncrease The the increase in balance since the last action of the user\r\n   * @param avgStableRate The new average stable rate after the burning\r\n   * @param newTotalSupply The new total supply of the stable debt token after the action\r\n   **/\r\n  event Burn(\r\n    address indexed user,\r\n    uint256 amount,\r\n    uint256 currentBalance,\r\n    uint256 balanceIncrease,\r\n    uint256 avgStableRate,\r\n    uint256 newTotalSupply\r\n  );\r\n\r\n  /**\r\n   * @dev Mints debt token to the `onBehalfOf` address.\r\n   * - The resulting rate is the weighted average between the rate of the new debt\r\n   * and the rate of the previous debt\r\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\r\n   * of credit delegate, or same as `onBehalfOf` otherwise\r\n   * @param onBehalfOf The address receiving the debt tokens\r\n   * @param amount The amount of debt tokens to mint\r\n   * @param rate The rate of the debt being minted\r\n   **/\r\n  function mint(\r\n    address user,\r\n    address onBehalfOf,\r\n    uint256 amount,\r\n    uint256 rate\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Burns debt of `user`\r\n   * - The resulting rate is the weighted average between the rate of the new debt\r\n   * and the rate of the previous debt\r\n   * @param user The address of the user getting his debt burned\r\n   * @param amount The amount of debt tokens getting burned\r\n   **/\r\n  function burn(address user, uint256 amount) external;\r\n\r\n  /**\r\n   * @dev Returns the average rate of all the stable rate loans.\r\n   * @return The average stable rate\r\n   **/\r\n  function getAverageStableRate() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the stable rate of the user debt\r\n   * @return The stable rate of the user\r\n   **/\r\n  function getUserStableRate(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the timestamp of the last update of the user\r\n   * @return The timestamp\r\n   **/\r\n  function getUserLastUpdated(address user) external view returns (uint40);\r\n\r\n  /**\r\n   * @dev Returns the principal, the total supply and the average stable rate\r\n   **/\r\n  function getSupplyData()\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint40\r\n    );\r\n\r\n  /**\r\n   * @dev Returns the timestamp of the last update of the total supply\r\n   * @return The timestamp\r\n   **/\r\n  function getTotalSupplyLastUpdated() external view returns (uint40);\r\n\r\n  /**\r\n   * @dev Returns the total supply and the average stable rate\r\n   **/\r\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\r\n\r\n  /**\r\n   * @dev Returns the principal debt balance of the user\r\n   * @return The debt balance of the user since the last burn/mint action\r\n   **/\r\n  function principalBalanceOf(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view returns (IAaveIncentivesController);\r\n}\r\n"
      },
      "contracts/interfaces/IVariableDebtToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\r\nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol';\r\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\r\n\r\n/**\r\n * @title IVariableDebtToken\r\n * @author Aave\r\n * @notice Defines the basic interface for a variable debt token.\r\n **/\r\ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {\r\n  /**\r\n   * @dev Emitted after the mint action\r\n   * @param from The address performing the mint\r\n   * @param onBehalfOf The address of the user on which behalf minting has been performed\r\n   * @param value The amount to be minted\r\n   * @param index The last index of the reserve\r\n   **/\r\n  event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Mints debt token to the `onBehalfOf` address\r\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\r\n   * of credit delegate, or same as `onBehalfOf` otherwise\r\n   * @param onBehalfOf The address receiving the debt tokens\r\n   * @param amount The amount of debt being minted\r\n   * @param index The variable debt index of the reserve\r\n   * @return `true` if the the previous balance of the user is 0\r\n   **/\r\n  function mint(\r\n    address user,\r\n    address onBehalfOf,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when variable debt is burnt\r\n   * @param user The user which debt has been burned\r\n   * @param amount The amount of debt being burned\r\n   * @param index The index of the user\r\n   **/\r\n  event Burn(address indexed user, uint256 amount, uint256 index);\r\n\r\n  /**\r\n   * @dev Burns user variable debt\r\n   * @param user The user which debt is burnt\r\n   * @param index The variable debt index of the reserve\r\n   **/\r\n  function burn(\r\n    address user,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view returns (IAaveIncentivesController);\r\n}\r\n"
      },
      "contracts/interfaces/ILendingPoolCollateralManager.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title ILendingPoolCollateralManager\r\n * @author Aave\r\n * @notice Defines the actions involving management of collateral in the protocol.\r\n **/\r\ninterface ILendingPoolCollateralManager {\r\n  /**\r\n   * @dev Emitted when a borrower is liquidated\r\n   * @param collateral The address of the collateral being liquidated\r\n   * @param principal The address of the reserve\r\n   * @param user The address of the user being liquidated\r\n   * @param debtToCover The total amount liquidated\r\n   * @param liquidatedCollateralAmount The amount of collateral being liquidated\r\n   * @param liquidator The address of the liquidator\r\n   * @param receiveAToken true if the liquidator wants to receive aTokens, false otherwise\r\n   **/\r\n  event LiquidationCall(\r\n    address indexed collateral,\r\n    address indexed principal,\r\n    address indexed user,\r\n    uint256 debtToCover,\r\n    uint256 liquidatedCollateralAmount,\r\n    address liquidator,\r\n    bool receiveAToken\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when a reserve is disabled as collateral for an user\r\n   * @param reserve The address of the reserve\r\n   * @param user The address of the user\r\n   **/\r\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve is enabled as collateral for an user\r\n   * @param reserve The address of the reserve\r\n   * @param user The address of the user\r\n   **/\r\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Users can invoke this function to liquidate an undercollateralized position.\r\n   * @param collateral The address of the collateral to liquidated\r\n   * @param principal The address of the principal reserve\r\n   * @param user The address of the borrower\r\n   * @param debtToCover The amount of principal that the liquidator wants to repay\r\n   * @param receiveAToken true if the liquidators wants to receive the aTokens, false if\r\n   * he wants to receive the underlying asset directly\r\n   **/\r\n  function liquidationCall(\r\n    address collateral,\r\n    address principal,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool receiveAToken\r\n  ) external returns (uint256, string memory);\r\n}\r\n"
      },
      "contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title VersionedInitializable\r\n *\r\n * @dev Helper contract to implement initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n *\r\n * @author Aave, inspired by the OpenZeppelin Initializable contract\r\n */\r\nabstract contract VersionedInitializable {\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  uint256 private lastInitializedRevision = 0;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    uint256 revision = getRevision();\r\n    require(\r\n      initializing || isConstructor() || revision > lastInitializedRevision,\r\n      'Contract instance has already been initialized'\r\n    );\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      lastInitializedRevision = revision;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev returns the revision number of the contract\r\n   * Needs to be defined in the inherited class as a constant.\r\n   **/\r\n  function getRevision() internal pure virtual returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns true if and only if the function is running in the constructor\r\n   **/\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    //solium-disable-next-line\r\n    assembly {\r\n      cs := extcodesize(address())\r\n    }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n"
      },
      "contracts/protocol/libraries/logic/GenericLogic.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol';\r\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {ReserveLogic} from './ReserveLogic.sol';\r\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\r\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\r\nimport {WadRayMath} from '../math/WadRayMath.sol';\r\nimport {PercentageMath} from '../math/PercentageMath.sol';\r\nimport {IPriceOracleGetter} from '../../../interfaces/IPriceOracleGetter.sol';\r\nimport {DataTypes} from '../types/DataTypes.sol';\r\n\r\n/**\r\n * @title GenericLogic library\r\n * @author Aave\r\n * @title Implements protocol-level logic to calculate and validate the state of a user\r\n */\r\nlibrary GenericLogic {\r\n  using ReserveLogic for DataTypes.ReserveData;\r\n  using SafeMath for uint256;\r\n  using WadRayMath for uint256;\r\n  using PercentageMath for uint256;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n  using UserConfiguration for DataTypes.UserConfigurationMap;\r\n\r\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\r\n\r\n  struct balanceDecreaseAllowedLocalVars {\r\n    uint256 decimals;\r\n    uint256 liquidationThreshold;\r\n    uint256 totalCollateralInETH;\r\n    uint256 totalDebtInETH;\r\n    uint256 avgLiquidationThreshold;\r\n    uint256 amountToDecreaseInETH;\r\n    uint256 collateralBalanceAfterDecrease;\r\n    uint256 liquidationThresholdAfterDecrease;\r\n    uint256 healthFactorAfterDecrease;\r\n    bool reserveUsageAsCollateralEnabled;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if a specific balance decrease is allowed\r\n   * (i.e. doesn't bring the user borrow position health factor under HEALTH_FACTOR_LIQUIDATION_THRESHOLD)\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param user The address of the user\r\n   * @param amount The amount to decrease\r\n   * @param reservesData The data of all the reserves\r\n   * @param userConfig The user configuration\r\n   * @param reserves The list of all the active reserves\r\n   * @param oracle The address of the oracle contract\r\n   * @return true if the decrease of the balance is allowed\r\n   **/\r\n  function balanceDecreaseAllowed(\r\n    address asset,\r\n    address user,\r\n    uint256 amount,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap calldata userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  ) external view returns (bool) {\r\n    if (!userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral(reservesData[asset].id)) {\r\n      return true;\r\n    }\r\n\r\n    balanceDecreaseAllowedLocalVars memory vars;\r\n\r\n    (, vars.liquidationThreshold, , vars.decimals, ) = reservesData[asset]\r\n      .configuration\r\n      .getParams();\r\n\r\n    if (vars.liquidationThreshold == 0) {\r\n      return true;\r\n    }\r\n\r\n    (\r\n      vars.totalCollateralInETH,\r\n      vars.totalDebtInETH,\r\n      ,\r\n      vars.avgLiquidationThreshold,\r\n\r\n    ) = calculateUserAccountData(user, reservesData, userConfig, reserves, reservesCount, oracle);\r\n\r\n    if (vars.totalDebtInETH == 0) {\r\n      return true;\r\n    }\r\n\r\n    vars.amountToDecreaseInETH = IPriceOracleGetter(oracle).getAssetPrice(asset).mul(amount).div(\r\n      10**vars.decimals\r\n    );\r\n\r\n    vars.collateralBalanceAfterDecrease = vars.totalCollateralInETH.sub(vars.amountToDecreaseInETH);\r\n\r\n    //if there is a borrow, there can't be 0 collateral\r\n    if (vars.collateralBalanceAfterDecrease == 0) {\r\n      return false;\r\n    }\r\n\r\n    vars.liquidationThresholdAfterDecrease = vars\r\n      .totalCollateralInETH\r\n      .mul(vars.avgLiquidationThreshold)\r\n      .sub(vars.amountToDecreaseInETH.mul(vars.liquidationThreshold))\r\n      .div(vars.collateralBalanceAfterDecrease);\r\n\r\n    uint256 healthFactorAfterDecrease =\r\n      calculateHealthFactorFromBalances(\r\n        vars.collateralBalanceAfterDecrease,\r\n        vars.totalDebtInETH,\r\n        vars.liquidationThresholdAfterDecrease\r\n      );\r\n\r\n    return healthFactorAfterDecrease >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\r\n  }\r\n\r\n  struct CalculateUserAccountDataVars {\r\n    uint256 reserveUnitPrice;\r\n    uint256 tokenUnit;\r\n    uint256 compoundedLiquidityBalance;\r\n    uint256 compoundedBorrowBalance;\r\n    uint256 decimals;\r\n    uint256 ltv;\r\n    uint256 liquidationThreshold;\r\n    uint256 i;\r\n    uint256 healthFactor;\r\n    uint256 totalCollateralInETH;\r\n    uint256 totalDebtInETH;\r\n    uint256 avgLtv;\r\n    uint256 avgLiquidationThreshold;\r\n    uint256 reservesLength;\r\n    bool healthFactorBelowThreshold;\r\n    address currentReserveAddress;\r\n    bool usageAsCollateralEnabled;\r\n    bool userUsesReserveAsCollateral;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the user data across the reserves.\r\n   * this includes the total liquidity/collateral/borrow balances in ETH,\r\n   * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\r\n   * @param user The address of the user\r\n   * @param reservesData Data of all the reserves\r\n   * @param userConfig The configuration of the user\r\n   * @param reserves The list of the available reserves\r\n   * @param oracle The price oracle address\r\n   * @return The total collateral and total debt of the user in ETH, the avg ltv, liquidation threshold and the HF\r\n   **/\r\n  function calculateUserAccountData(\r\n    address user,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap memory userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  )\r\n    internal\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    CalculateUserAccountDataVars memory vars;\r\n\r\n    if (userConfig.isEmpty()) {\r\n      return (0, 0, 0, 0, uint256(-1));\r\n    }\r\n    for (vars.i = 0; vars.i < reservesCount; vars.i++) {\r\n      if (!userConfig.isUsingAsCollateralOrBorrowing(vars.i)) {\r\n        continue;\r\n      }\r\n\r\n      vars.currentReserveAddress = reserves[vars.i];\r\n      DataTypes.ReserveData storage currentReserve = reservesData[vars.currentReserveAddress];\r\n\r\n      (vars.ltv, vars.liquidationThreshold, , vars.decimals, ) = currentReserve\r\n        .configuration\r\n        .getParams();\r\n\r\n      vars.tokenUnit = 10**vars.decimals;\r\n      vars.reserveUnitPrice = IPriceOracleGetter(oracle).getAssetPrice(vars.currentReserveAddress);\r\n\r\n      if (vars.liquidationThreshold != 0 && userConfig.isUsingAsCollateral(vars.i)) {\r\n        vars.compoundedLiquidityBalance = IERC20(currentReserve.aTokenAddress).balanceOf(user);\r\n\r\n        uint256 liquidityBalanceETH =\r\n          vars.reserveUnitPrice.mul(vars.compoundedLiquidityBalance).div(vars.tokenUnit);\r\n\r\n        vars.totalCollateralInETH = vars.totalCollateralInETH.add(liquidityBalanceETH);\r\n\r\n        vars.avgLtv = vars.avgLtv.add(liquidityBalanceETH.mul(vars.ltv));\r\n        vars.avgLiquidationThreshold = vars.avgLiquidationThreshold.add(\r\n          liquidityBalanceETH.mul(vars.liquidationThreshold)\r\n        );\r\n      }\r\n\r\n      if (userConfig.isBorrowing(vars.i)) {\r\n        vars.compoundedBorrowBalance = IERC20(currentReserve.stableDebtTokenAddress).balanceOf(\r\n          user\r\n        );\r\n        vars.compoundedBorrowBalance = vars.compoundedBorrowBalance.add(\r\n          IERC20(currentReserve.variableDebtTokenAddress).balanceOf(user)\r\n        );\r\n\r\n        vars.totalDebtInETH = vars.totalDebtInETH.add(\r\n          vars.reserveUnitPrice.mul(vars.compoundedBorrowBalance).div(vars.tokenUnit)\r\n        );\r\n      }\r\n    }\r\n\r\n    vars.avgLtv = vars.totalCollateralInETH > 0 ? vars.avgLtv.div(vars.totalCollateralInETH) : 0;\r\n    vars.avgLiquidationThreshold = vars.totalCollateralInETH > 0\r\n      ? vars.avgLiquidationThreshold.div(vars.totalCollateralInETH)\r\n      : 0;\r\n\r\n    vars.healthFactor = calculateHealthFactorFromBalances(\r\n      vars.totalCollateralInETH,\r\n      vars.totalDebtInETH,\r\n      vars.avgLiquidationThreshold\r\n    );\r\n    return (\r\n      vars.totalCollateralInETH,\r\n      vars.totalDebtInETH,\r\n      vars.avgLtv,\r\n      vars.avgLiquidationThreshold,\r\n      vars.healthFactor\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the health factor from the corresponding balances\r\n   * @param totalCollateralInETH The total collateral in ETH\r\n   * @param totalDebtInETH The total debt in ETH\r\n   * @param liquidationThreshold The avg liquidation threshold\r\n   * @return The health factor calculated from the balances provided\r\n   **/\r\n  function calculateHealthFactorFromBalances(\r\n    uint256 totalCollateralInETH,\r\n    uint256 totalDebtInETH,\r\n    uint256 liquidationThreshold\r\n  ) internal pure returns (uint256) {\r\n    if (totalDebtInETH == 0) return uint256(-1);\r\n\r\n    return (totalCollateralInETH.percentMul(liquidationThreshold)).wadDiv(totalDebtInETH);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\r\n   * average Loan To Value\r\n   * @param totalCollateralInETH The total collateral in ETH\r\n   * @param totalDebtInETH The total borrow balance\r\n   * @param ltv The average loan to value\r\n   * @return the amount available to borrow in ETH for the user\r\n   **/\r\n\r\n  function calculateAvailableBorrowsETH(\r\n    uint256 totalCollateralInETH,\r\n    uint256 totalDebtInETH,\r\n    uint256 ltv\r\n  ) internal pure returns (uint256) {\r\n    uint256 availableBorrowsETH = totalCollateralInETH.percentMul(ltv);\r\n\r\n    if (availableBorrowsETH < totalDebtInETH) {\r\n      return 0;\r\n    }\r\n\r\n    availableBorrowsETH = availableBorrowsETH.sub(totalDebtInETH);\r\n    return availableBorrowsETH;\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/libraries/helpers/Helpers.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {DataTypes} from '../types/DataTypes.sol';\r\n\r\n/**\r\n * @title Helpers library\r\n * @author Aave\r\n */\r\nlibrary Helpers {\r\n  /**\r\n   * @dev Fetches the user current stable and variable debt balances\r\n   * @param user The user address\r\n   * @param reserve The reserve data object\r\n   * @return The stable and variable debt balance\r\n   **/\r\n  function getUserCurrentDebt(address user, DataTypes.ReserveData storage reserve)\r\n    internal\r\n    view\r\n    returns (uint256, uint256)\r\n  {\r\n    return (\r\n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user),\r\n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user)\r\n    );\r\n  }\r\n\r\n  function getUserCurrentDebtMemory(address user, DataTypes.ReserveData memory reserve)\r\n    internal\r\n    view\r\n    returns (uint256, uint256)\r\n  {\r\n    return (\r\n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user),\r\n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user)\r\n    );\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/libraries/math/WadRayMath.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {Errors} from '../helpers/Errors.sol';\r\n\r\n/**\r\n * @title WadRayMath library\r\n * @author Aave\r\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\r\n **/\r\n\r\nlibrary WadRayMath {\r\n  uint256 internal constant WAD = 1e18;\r\n  uint256 internal constant halfWAD = WAD / 2;\r\n\r\n  uint256 internal constant RAY = 1e27;\r\n  uint256 internal constant halfRAY = RAY / 2;\r\n\r\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\r\n\r\n  /**\r\n   * @return One ray, 1e27\r\n   **/\r\n  function ray() internal pure returns (uint256) {\r\n    return RAY;\r\n  }\r\n\r\n  /**\r\n   * @return One wad, 1e18\r\n   **/\r\n\r\n  function wad() internal pure returns (uint256) {\r\n    return WAD;\r\n  }\r\n\r\n  /**\r\n   * @return Half ray, 1e27/2\r\n   **/\r\n  function halfRay() internal pure returns (uint256) {\r\n    return halfRAY;\r\n  }\r\n\r\n  /**\r\n   * @return Half ray, 1e18/2\r\n   **/\r\n  function halfWad() internal pure returns (uint256) {\r\n    return halfWAD;\r\n  }\r\n\r\n  /**\r\n   * @dev Multiplies two wad, rounding half up to the nearest wad\r\n   * @param a Wad\r\n   * @param b Wad\r\n   * @return The result of a*b, in wad\r\n   **/\r\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0 || b == 0) {\r\n      return 0;\r\n    }\r\n\r\n    require(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\r\n\r\n    return (a * b + halfWAD) / WAD;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two wad, rounding half up to the nearest wad\r\n   * @param a Wad\r\n   * @param b Wad\r\n   * @return The result of a/b, in wad\r\n   **/\r\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\r\n    uint256 halfB = b / 2;\r\n\r\n    require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\r\n\r\n    return (a * WAD + halfB) / b;\r\n  }\r\n\r\n  /**\r\n   * @dev Multiplies two ray, rounding half up to the nearest ray\r\n   * @param a Ray\r\n   * @param b Ray\r\n   * @return The result of a*b, in ray\r\n   **/\r\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0 || b == 0) {\r\n      return 0;\r\n    }\r\n\r\n    require(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\r\n\r\n    return (a * b + halfRAY) / RAY;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two ray, rounding half up to the nearest ray\r\n   * @param a Ray\r\n   * @param b Ray\r\n   * @return The result of a/b, in ray\r\n   **/\r\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\r\n    uint256 halfB = b / 2;\r\n\r\n    require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\r\n\r\n    return (a * RAY + halfB) / b;\r\n  }\r\n\r\n  /**\r\n   * @dev Casts ray down to wad\r\n   * @param a Ray\r\n   * @return a casted to wad, rounded half up to the nearest wad\r\n   **/\r\n  function rayToWad(uint256 a) internal pure returns (uint256) {\r\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\r\n    uint256 result = halfRatio + a;\r\n    require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\r\n\r\n    return result / WAD_RAY_RATIO;\r\n  }\r\n\r\n  /**\r\n   * @dev Converts wad up to ray\r\n   * @param a Wad\r\n   * @return a converted in ray\r\n   **/\r\n  function wadToRay(uint256 a) internal pure returns (uint256) {\r\n    uint256 result = a * WAD_RAY_RATIO;\r\n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\r\n    return result;\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/libraries/logic/ValidationLogic.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol';\r\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {ReserveLogic} from './ReserveLogic.sol';\r\nimport {GenericLogic} from './GenericLogic.sol';\r\nimport {WadRayMath} from '../math/WadRayMath.sol';\r\nimport {PercentageMath} from '../math/PercentageMath.sol';\r\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\r\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\r\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\r\nimport {Errors} from '../helpers/Errors.sol';\r\nimport {Helpers} from '../helpers/Helpers.sol';\r\nimport {IReserveInterestRateStrategy} from '../../../interfaces/IReserveInterestRateStrategy.sol';\r\nimport {DataTypes} from '../types/DataTypes.sol';\r\n\r\n/**\r\n * @title ReserveLogic library\r\n * @author Aave\r\n * @notice Implements functions to validate the different actions of the protocol\r\n */\r\nlibrary ValidationLogic {\r\n  using ReserveLogic for DataTypes.ReserveData;\r\n  using SafeMath for uint256;\r\n  using WadRayMath for uint256;\r\n  using PercentageMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n  using UserConfiguration for DataTypes.UserConfigurationMap;\r\n\r\n  uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 4000;\r\n  uint256 public constant REBALANCE_UP_USAGE_RATIO_THRESHOLD = 0.95 * 1e27; //usage ratio of 95%\r\n\r\n  /**\r\n   * @dev Validates a deposit action\r\n   * @param reserve The reserve object on which the user is depositing\r\n   * @param amount The amount to be deposited\r\n   */\r\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\r\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\r\n\r\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\r\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a withdraw action\r\n   * @param reserveAddress The address of the reserve\r\n   * @param amount The amount to be withdrawn\r\n   * @param userBalance The balance of the user\r\n   * @param reservesData The reserves state\r\n   * @param userConfig The user configuration\r\n   * @param reserves The addresses of the reserves\r\n   * @param reservesCount The number of reserves\r\n   * @param oracle The price oracle\r\n   */\r\n  function validateWithdraw(\r\n    address reserveAddress,\r\n    uint256 amount,\r\n    uint256 userBalance,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  ) external view {\r\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\r\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\r\n\r\n    (bool isActive, , , ) = reservesData[reserveAddress].configuration.getFlags();\r\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n\r\n    require(\r\n      GenericLogic.balanceDecreaseAllowed(\r\n        reserveAddress,\r\n        msg.sender,\r\n        amount,\r\n        reservesData,\r\n        userConfig,\r\n        reserves,\r\n        reservesCount,\r\n        oracle\r\n      ),\r\n      Errors.VL_TRANSFER_NOT_ALLOWED\r\n    );\r\n  }\r\n\r\n  struct ValidateBorrowLocalVars {\r\n    uint256 currentLtv;\r\n    uint256 currentLiquidationThreshold;\r\n    uint256 amountOfCollateralNeededETH;\r\n    uint256 userCollateralBalanceETH;\r\n    uint256 userBorrowBalanceETH;\r\n    uint256 availableLiquidity;\r\n    uint256 healthFactor;\r\n    bool isActive;\r\n    bool isFrozen;\r\n    bool borrowingEnabled;\r\n    bool stableRateBorrowingEnabled;\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a borrow action\r\n   * @param asset The address of the asset to borrow\r\n   * @param reserve The reserve state from which the user is borrowing\r\n   * @param userAddress The address of the user\r\n   * @param amount The amount to be borrowed\r\n   * @param amountInETH The amount to be borrowed, in ETH\r\n   * @param interestRateMode The interest rate mode at which the user is borrowing\r\n   * @param maxStableLoanPercent The max amount of the liquidity that can be borrowed at stable rate, in percentage\r\n   * @param reservesData The state of all the reserves\r\n   * @param userConfig The state of the user for the specific reserve\r\n   * @param reserves The addresses of all the active reserves\r\n   * @param oracle The price oracle\r\n   */\r\n\r\n  function validateBorrow(\r\n    address asset,\r\n    DataTypes.ReserveData storage reserve,\r\n    address userAddress,\r\n    uint256 amount,\r\n    uint256 amountInETH,\r\n    uint256 interestRateMode,\r\n    uint256 maxStableLoanPercent,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  ) external view {\r\n    ValidateBorrowLocalVars memory vars;\r\n\r\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserve\r\n      .configuration\r\n      .getFlags();\r\n\r\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\r\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\r\n\r\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\r\n\r\n    //validate interest rate mode\r\n    require(\r\n      uint256(DataTypes.InterestRateMode.VARIABLE) == interestRateMode ||\r\n        uint256(DataTypes.InterestRateMode.STABLE) == interestRateMode,\r\n      Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED\r\n    );\r\n\r\n    (\r\n      vars.userCollateralBalanceETH,\r\n      vars.userBorrowBalanceETH,\r\n      vars.currentLtv,\r\n      vars.currentLiquidationThreshold,\r\n      vars.healthFactor\r\n    ) = GenericLogic.calculateUserAccountData(\r\n      userAddress,\r\n      reservesData,\r\n      userConfig,\r\n      reserves,\r\n      reservesCount,\r\n      oracle\r\n    );\r\n\r\n    require(vars.userCollateralBalanceETH > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\r\n\r\n    require(\r\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\r\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\r\n    );\r\n\r\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\r\n    vars.amountOfCollateralNeededETH = vars.userBorrowBalanceETH.add(amountInETH).percentDiv(\r\n      vars.currentLtv\r\n    ); //LTV is calculated in percentage\r\n\r\n    require(\r\n      vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\r\n      Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW\r\n    );\r\n\r\n    /**\r\n     * Following conditions need to be met if the user is borrowing at a stable rate:\r\n     * 1. Reserve must be enabled for stable rate borrowing\r\n     * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\r\n     *    they are borrowing, to prevent abuses.\r\n     * 3. Users will be able to borrow only a portion of the total available liquidity\r\n     **/\r\n\r\n    if (interestRateMode == uint256(DataTypes.InterestRateMode.STABLE)) {\r\n      //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\r\n\r\n      require(vars.stableRateBorrowingEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\r\n\r\n      require(\r\n        !userConfig.isUsingAsCollateral(reserve.id) ||\r\n          reserve.configuration.getLtv() == 0 ||\r\n          amount > IERC20(reserve.aTokenAddress).balanceOf(userAddress),\r\n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\r\n      );\r\n\r\n      vars.availableLiquidity = IERC20(asset).balanceOf(reserve.aTokenAddress);\r\n\r\n      //calculate the max available loan size in stable rate mode as a percentage of the\r\n      //available liquidity\r\n      uint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(maxStableLoanPercent);\r\n\r\n      require(amount <= maxLoanSizeStable, Errors.VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a repay action\r\n   * @param reserve The reserve state from which the user is repaying\r\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\r\n   * @param onBehalfOf The address of the user msg.sender is repaying for\r\n   * @param stableDebt The borrow balance of the user\r\n   * @param variableDebt The borrow balance of the user\r\n   */\r\n  function validateRepay(\r\n    DataTypes.ReserveData storage reserve,\r\n    uint256 amountSent,\r\n    DataTypes.InterestRateMode rateMode,\r\n    address onBehalfOf,\r\n    uint256 stableDebt,\r\n    uint256 variableDebt\r\n  ) external view {\r\n    bool isActive = reserve.configuration.getActive();\r\n\r\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n\r\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\r\n\r\n    require(\r\n      (stableDebt > 0 &&\r\n        DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE) ||\r\n        (variableDebt > 0 &&\r\n          DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.VARIABLE),\r\n      Errors.VL_NO_DEBT_OF_SELECTED_TYPE\r\n    );\r\n\r\n    require(\r\n      amountSent != uint256(-1) || msg.sender == onBehalfOf,\r\n      Errors.VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a swap of borrow rate mode.\r\n   * @param reserve The reserve state on which the user is swapping the rate\r\n   * @param userConfig The user reserves configuration\r\n   * @param stableDebt The stable debt of the user\r\n   * @param variableDebt The variable debt of the user\r\n   * @param currentRateMode The rate mode of the borrow\r\n   */\r\n  function validateSwapRateMode(\r\n    DataTypes.ReserveData storage reserve,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    uint256 stableDebt,\r\n    uint256 variableDebt,\r\n    DataTypes.InterestRateMode currentRateMode\r\n  ) external view {\r\n    (bool isActive, bool isFrozen, , bool stableRateEnabled) = reserve.configuration.getFlags();\r\n\r\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\r\n\r\n    if (currentRateMode == DataTypes.InterestRateMode.STABLE) {\r\n      require(stableDebt > 0, Errors.VL_NO_STABLE_RATE_LOAN_IN_RESERVE);\r\n    } else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) {\r\n      require(variableDebt > 0, Errors.VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE);\r\n      /**\r\n       * user wants to swap to stable, before swapping we need to ensure that\r\n       * 1. stable borrow rate is enabled on the reserve\r\n       * 2. user is not trying to abuse the reserve by depositing\r\n       * more collateral than he is borrowing, artificially lowering\r\n       * the interest rate, borrowing at variable, and switching to stable\r\n       **/\r\n      require(stableRateEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\r\n\r\n      require(\r\n        !userConfig.isUsingAsCollateral(reserve.id) ||\r\n          reserve.configuration.getLtv() == 0 ||\r\n          stableDebt.add(variableDebt) > IERC20(reserve.aTokenAddress).balanceOf(msg.sender),\r\n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\r\n      );\r\n    } else {\r\n      revert(Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a stable borrow rate rebalance action\r\n   * @param reserve The reserve state on which the user is getting rebalanced\r\n   * @param reserveAddress The address of the reserve\r\n   * @param stableDebtToken The stable debt token instance\r\n   * @param variableDebtToken The variable debt token instance\r\n   * @param aTokenAddress The address of the aToken contract\r\n   */\r\n  function validateRebalanceStableBorrowRate(\r\n    DataTypes.ReserveData storage reserve,\r\n    address reserveAddress,\r\n    IERC20 stableDebtToken,\r\n    IERC20 variableDebtToken,\r\n    address aTokenAddress\r\n  ) external view {\r\n    (bool isActive, , , ) = reserve.configuration.getFlags();\r\n\r\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n\r\n    //if the usage ratio is below 95%, no rebalances are needed\r\n    uint256 totalDebt =\r\n      stableDebtToken.totalSupply().add(variableDebtToken.totalSupply()).wadToRay();\r\n    uint256 availableLiquidity = IERC20(reserveAddress).balanceOf(aTokenAddress).wadToRay();\r\n    uint256 usageRatio = totalDebt == 0 ? 0 : totalDebt.rayDiv(availableLiquidity.add(totalDebt));\r\n\r\n    //if the liquidity rate is below REBALANCE_UP_THRESHOLD of the max variable APR at 95% usage,\r\n    //then we allow rebalancing of the stable rate positions.\r\n\r\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\r\n    uint256 maxVariableBorrowRate =\r\n      IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).getMaxVariableBorrowRate();\r\n\r\n    require(\r\n      usageRatio >= REBALANCE_UP_USAGE_RATIO_THRESHOLD &&\r\n        currentLiquidityRate <=\r\n        maxVariableBorrowRate.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),\r\n      Errors.LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Validates the action of setting an asset as collateral\r\n   * @param reserve The state of the reserve that the user is enabling or disabling as collateral\r\n   * @param reserveAddress The address of the reserve\r\n   * @param reservesData The data of all the reserves\r\n   * @param userConfig The state of the user for the specific reserve\r\n   * @param reserves The addresses of all the active reserves\r\n   * @param oracle The price oracle\r\n   */\r\n  function validateSetUseReserveAsCollateral(\r\n    DataTypes.ReserveData storage reserve,\r\n    address reserveAddress,\r\n    bool useAsCollateral,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  ) external view {\r\n    uint256 underlyingBalance = IERC20(reserve.aTokenAddress).balanceOf(msg.sender);\r\n\r\n    require(underlyingBalance > 0, Errors.VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0);\r\n\r\n    require(\r\n      useAsCollateral ||\r\n        GenericLogic.balanceDecreaseAllowed(\r\n          reserveAddress,\r\n          msg.sender,\r\n          underlyingBalance,\r\n          reservesData,\r\n          userConfig,\r\n          reserves,\r\n          reservesCount,\r\n          oracle\r\n        ),\r\n      Errors.VL_DEPOSIT_ALREADY_IN_USE\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a flashloan action\r\n   * @param assets The assets being flashborrowed\r\n   * @param amounts The amounts for each asset being borrowed\r\n   **/\r\n  function validateFlashloan(address[] memory assets, uint256[] memory amounts) internal pure {\r\n    require(assets.length == amounts.length, Errors.VL_INCONSISTENT_FLASHLOAN_PARAMS);\r\n  }\r\n\r\n  /**\r\n   * @dev Validates the liquidation action\r\n   * @param collateralReserve The reserve data of the collateral\r\n   * @param principalReserve The reserve data of the principal\r\n   * @param userConfig The user configuration\r\n   * @param userHealthFactor The user's health factor\r\n   * @param userStableDebt Total stable debt balance of the user\r\n   * @param userVariableDebt Total variable debt balance of the user\r\n   **/\r\n  function validateLiquidationCall(\r\n    DataTypes.ReserveData storage collateralReserve,\r\n    DataTypes.ReserveData storage principalReserve,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    uint256 userHealthFactor,\r\n    uint256 userStableDebt,\r\n    uint256 userVariableDebt\r\n  ) internal view returns (uint256, string memory) {\r\n    if (\r\n      !collateralReserve.configuration.getActive() || !principalReserve.configuration.getActive()\r\n    ) {\r\n      return (\r\n        uint256(Errors.CollateralManagerErrors.NO_ACTIVE_RESERVE),\r\n        Errors.VL_NO_ACTIVE_RESERVE\r\n      );\r\n    }\r\n\r\n    if (userHealthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD) {\r\n      return (\r\n        uint256(Errors.CollateralManagerErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),\r\n        Errors.LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\r\n      );\r\n    }\r\n\r\n    bool isCollateralEnabled =\r\n      collateralReserve.configuration.getLiquidationThreshold() > 0 &&\r\n        userConfig.isUsingAsCollateral(collateralReserve.id);\r\n\r\n    //if collateral isn't enabled as collateral by user, it cannot be liquidated\r\n    if (!isCollateralEnabled) {\r\n      return (\r\n        uint256(Errors.CollateralManagerErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),\r\n        Errors.LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED\r\n      );\r\n    }\r\n\r\n    if (userStableDebt == 0 && userVariableDebt == 0) {\r\n      return (\r\n        uint256(Errors.CollateralManagerErrors.CURRRENCY_NOT_BORROWED),\r\n        Errors.LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\r\n      );\r\n    }\r\n\r\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS);\r\n  }\r\n\r\n  /**\r\n   * @dev Validates an aToken transfer\r\n   * @param from The user from which the aTokens are being transferred\r\n   * @param reservesData The state of all the reserves\r\n   * @param userConfig The state of the user for the specific reserve\r\n   * @param reserves The addresses of all the active reserves\r\n   * @param oracle The price oracle\r\n   */\r\n  function validateTransfer(\r\n    address from,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  ) internal view {\r\n    (, , , , uint256 healthFactor) =\r\n      GenericLogic.calculateUserAccountData(\r\n        from,\r\n        reservesData,\r\n        userConfig,\r\n        reserves,\r\n        reservesCount,\r\n        oracle\r\n      );\r\n\r\n    require(\r\n      healthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\r\n      Errors.VL_TRANSFER_NOT_ALLOWED\r\n    );\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/lendingpool/LendingPoolStorage.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol';\r\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\r\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\r\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\r\n\r\ncontract LendingPoolStorage {\r\n  using ReserveLogic for DataTypes.ReserveData;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n  using UserConfiguration for DataTypes.UserConfigurationMap;\r\n\r\n  ILendingPoolAddressesProvider internal _addressesProvider;\r\n\r\n  mapping(address => DataTypes.ReserveData) internal _reserves;\r\n  mapping(address => DataTypes.UserConfigurationMap) internal _usersConfig;\r\n\r\n  // the list of the available reserves, structured as a mapping for gas savings reasons\r\n  mapping(uint256 => address) internal _reservesList;\r\n\r\n  uint256 internal _reservesCount;\r\n\r\n  bool internal _paused;\r\n\r\n  uint256 internal _maxStableRateBorrowSizePercent;\r\n\r\n  uint256 internal _flashLoanPremiumTotal;\r\n\r\n  uint256 internal _maxNumberOfReserves;\r\n}\r\n"
      },
      "contracts/interfaces/IScaledBalanceToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\ninterface IScaledBalanceToken {\r\n  /**\r\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\r\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\r\n   * @param user The user whose balance is calculated\r\n   * @return The scaled balance of the user\r\n   **/\r\n  function scaledBalanceOf(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the scaled balance of the user and the scaled total supply.\r\n   * @param user The address of the user\r\n   * @return The scaled balance of the user\r\n   * @return The scaled balance and the scaled total supply\r\n   **/\r\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\r\n\r\n  /**\r\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\r\n   * @return The scaled total supply\r\n   **/\r\n  function scaledTotalSupply() external view returns (uint256);\r\n}\r\n"
      },
      "contracts/interfaces/IInitializableAToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {ILendingPool} from './ILendingPool.sol';\r\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\r\n\r\n/**\r\n * @title IInitializableAToken\r\n * @notice Interface for the initialize function on AToken\r\n * @author Aave\r\n **/\r\ninterface IInitializableAToken {\r\n  /**\r\n   * @dev Emitted when an aToken is initialized\r\n   * @param underlyingAsset The address of the underlying asset\r\n   * @param pool The address of the associated lending pool\r\n   * @param treasury The address of the treasury\r\n   * @param incentivesController The address of the incentives controller for this aToken\r\n   * @param aTokenDecimals the decimals of the underlying\r\n   * @param aTokenName the name of the aToken\r\n   * @param aTokenSymbol the symbol of the aToken\r\n   * @param params A set of encoded parameters for additional initialization\r\n   **/\r\n  event Initialized(\r\n    address indexed underlyingAsset,\r\n    address indexed pool,\r\n    address treasury,\r\n    address incentivesController,\r\n    uint8 aTokenDecimals,\r\n    string aTokenName,\r\n    string aTokenSymbol,\r\n    bytes params\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the aToken\r\n   * @param pool The address of the lending pool where this aToken will be used\r\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\r\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   * @param incentivesController The smart contract managing potential incentives distribution\r\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\r\n   * @param aTokenName The name of the aToken\r\n   * @param aTokenSymbol The symbol of the aToken\r\n   */\r\n  function initialize(\r\n    ILendingPool pool,\r\n    address treasury,\r\n    address underlyingAsset,\r\n    IAaveIncentivesController incentivesController,\r\n    uint8 aTokenDecimals,\r\n    string calldata aTokenName,\r\n    string calldata aTokenSymbol,\r\n    bytes calldata params\r\n  ) external;\r\n}\r\n"
      },
      "contracts/interfaces/IAaveIncentivesController.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IAaveIncentivesController {\r\n  function handleAction(\r\n    address user,\r\n    uint256 userBalance,\r\n    uint256 totalSupply\r\n  ) external;\r\n}\r\n"
      },
      "contracts/interfaces/IInitializableDebtToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {ILendingPool} from './ILendingPool.sol';\r\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\r\n\r\n/**\r\n * @title IInitializableDebtToken\r\n * @notice Interface for the initialize function common between debt tokens\r\n * @author Aave\r\n **/\r\ninterface IInitializableDebtToken {\r\n  /**\r\n   * @dev Emitted when a debt token is initialized\r\n   * @param underlyingAsset The address of the underlying asset\r\n   * @param pool The address of the associated lending pool\r\n   * @param incentivesController The address of the incentives controller for this aToken\r\n   * @param debtTokenDecimals the decimals of the debt token\r\n   * @param debtTokenName the name of the debt token\r\n   * @param debtTokenSymbol the symbol of the debt token\r\n   * @param params A set of encoded parameters for additional initialization\r\n   **/\r\n  event Initialized(\r\n    address indexed underlyingAsset,\r\n    address indexed pool,\r\n    address incentivesController,\r\n    uint8 debtTokenDecimals,\r\n    string debtTokenName,\r\n    string debtTokenSymbol,\r\n    bytes params\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the debt token.\r\n   * @param pool The address of the lending pool where this aToken will be used\r\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   * @param incentivesController The smart contract managing potential incentives distribution\r\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\r\n   * @param debtTokenName The name of the token\r\n   * @param debtTokenSymbol The symbol of the token\r\n   */\r\n  function initialize(\r\n    ILendingPool pool,\r\n    address underlyingAsset,\r\n    IAaveIncentivesController incentivesController,\r\n    uint8 debtTokenDecimals,\r\n    string memory debtTokenName,\r\n    string memory debtTokenSymbol,\r\n    bytes calldata params\r\n  ) external;\r\n}\r\n"
      },
      "contracts/protocol/libraries/logic/ReserveLogic.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol';\r\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\r\nimport {IAToken} from '../../../interfaces/IAToken.sol';\r\nimport {IStableDebtToken} from '../../../interfaces/IStableDebtToken.sol';\r\nimport {IVariableDebtToken} from '../../../interfaces/IVariableDebtToken.sol';\r\nimport {IReserveInterestRateStrategy} from '../../../interfaces/IReserveInterestRateStrategy.sol';\r\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\r\nimport {MathUtils} from '../math/MathUtils.sol';\r\nimport {WadRayMath} from '../math/WadRayMath.sol';\r\nimport {PercentageMath} from '../math/PercentageMath.sol';\r\nimport {Errors} from '../helpers/Errors.sol';\r\nimport {DataTypes} from '../types/DataTypes.sol';\r\n\r\n/**\r\n * @title ReserveLogic library\r\n * @author Aave\r\n * @notice Implements the logic to update the reserves state\r\n */\r\nlibrary ReserveLogic {\r\n  using SafeMath for uint256;\r\n  using WadRayMath for uint256;\r\n  using PercentageMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  /**\r\n   * @dev Emitted when the state of a reserve is updated\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param liquidityRate The new liquidity rate\r\n   * @param stableBorrowRate The new stable borrow rate\r\n   * @param variableBorrowRate The new variable borrow rate\r\n   * @param liquidityIndex The new liquidity index\r\n   * @param variableBorrowIndex The new variable borrow index\r\n   **/\r\n  event ReserveDataUpdated(\r\n    address indexed asset,\r\n    uint256 liquidityRate,\r\n    uint256 stableBorrowRate,\r\n    uint256 variableBorrowRate,\r\n    uint256 liquidityIndex,\r\n    uint256 variableBorrowIndex\r\n  );\r\n\r\n  using ReserveLogic for DataTypes.ReserveData;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n\r\n  /**\r\n   * @dev Returns the ongoing normalized income for the reserve\r\n   * A value of 1e27 means there is no income. As time passes, the income is accrued\r\n   * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\r\n   * @param reserve The reserve object\r\n   * @return the normalized income. expressed in ray\r\n   **/\r\n  function getNormalizedIncome(DataTypes.ReserveData storage reserve)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint40 timestamp = reserve.lastUpdateTimestamp;\r\n\r\n    //solium-disable-next-line\r\n    if (timestamp == uint40(block.timestamp)) {\r\n      //if the index was updated in the same block, no need to perform any calculation\r\n      return reserve.liquidityIndex;\r\n    }\r\n\r\n    uint256 cumulated =\r\n      MathUtils.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul(\r\n        reserve.liquidityIndex\r\n      );\r\n\r\n    return cumulated;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the ongoing normalized variable debt for the reserve\r\n   * A value of 1e27 means there is no debt. As time passes, the income is accrued\r\n   * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\r\n   * @param reserve The reserve object\r\n   * @return The normalized variable debt. expressed in ray\r\n   **/\r\n  function getNormalizedDebt(DataTypes.ReserveData storage reserve)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint40 timestamp = reserve.lastUpdateTimestamp;\r\n\r\n    //solium-disable-next-line\r\n    if (timestamp == uint40(block.timestamp)) {\r\n      //if the index was updated in the same block, no need to perform any calculation\r\n      return reserve.variableBorrowIndex;\r\n    }\r\n\r\n    uint256 cumulated =\r\n      MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul(\r\n        reserve.variableBorrowIndex\r\n      );\r\n\r\n    return cumulated;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\r\n   * @param reserve the reserve object\r\n   **/\r\n  function updateState(DataTypes.ReserveData storage reserve) internal {\r\n    uint256 scaledVariableDebt =\r\n      IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply();\r\n    uint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;\r\n    uint256 previousLiquidityIndex = reserve.liquidityIndex;\r\n    uint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp;\r\n\r\n    (uint256 newLiquidityIndex, uint256 newVariableBorrowIndex) =\r\n      _updateIndexes(\r\n        reserve,\r\n        scaledVariableDebt,\r\n        previousLiquidityIndex,\r\n        previousVariableBorrowIndex,\r\n        lastUpdatedTimestamp\r\n      );\r\n\r\n    _mintToTreasury(\r\n      reserve,\r\n      scaledVariableDebt,\r\n      previousVariableBorrowIndex,\r\n      newLiquidityIndex,\r\n      newVariableBorrowIndex,\r\n      lastUpdatedTimestamp\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example to accumulate\r\n   * the flashloan fee to the reserve, and spread it between all the depositors\r\n   * @param reserve The reserve object\r\n   * @param totalLiquidity The total liquidity available in the reserve\r\n   * @param amount The amount to accomulate\r\n   **/\r\n  function cumulateToLiquidityIndex(\r\n    DataTypes.ReserveData storage reserve,\r\n    uint256 totalLiquidity,\r\n    uint256 amount\r\n  ) internal {\r\n    uint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay());\r\n\r\n    uint256 result = amountToLiquidityRatio.add(WadRayMath.ray());\r\n\r\n    result = result.rayMul(reserve.liquidityIndex);\r\n    require(result <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\r\n\r\n    reserve.liquidityIndex = uint128(result);\r\n  }\r\n\r\n  /**\r\n   * @dev Initializes a reserve\r\n   * @param reserve The reserve object\r\n   * @param aTokenAddress The address of the overlying atoken contract\r\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\r\n   **/\r\n  function init(\r\n    DataTypes.ReserveData storage reserve,\r\n    address aTokenAddress,\r\n    address stableDebtTokenAddress,\r\n    address variableDebtTokenAddress,\r\n    address interestRateStrategyAddress\r\n  ) external {\r\n    require(reserve.aTokenAddress == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED);\r\n\r\n    reserve.liquidityIndex = uint128(WadRayMath.ray());\r\n    reserve.variableBorrowIndex = uint128(WadRayMath.ray());\r\n    reserve.aTokenAddress = aTokenAddress;\r\n    reserve.stableDebtTokenAddress = stableDebtTokenAddress;\r\n    reserve.variableDebtTokenAddress = variableDebtTokenAddress;\r\n    reserve.interestRateStrategyAddress = interestRateStrategyAddress;\r\n  }\r\n\r\n  struct UpdateInterestRatesLocalVars {\r\n    address stableDebtTokenAddress;\r\n    uint256 availableLiquidity;\r\n    uint256 totalStableDebt;\r\n    uint256 newLiquidityRate;\r\n    uint256 newStableRate;\r\n    uint256 newVariableRate;\r\n    uint256 avgStableRate;\r\n    uint256 totalVariableDebt;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\r\n   * @param reserve The address of the reserve to be updated\r\n   * @param liquidityAdded The amount of liquidity added to the protocol (deposit or repay) in the previous action\r\n   * @param liquidityTaken The amount of liquidity taken from the protocol (redeem or borrow)\r\n   **/\r\n  function updateInterestRates(\r\n    DataTypes.ReserveData storage reserve,\r\n    address reserveAddress,\r\n    address aTokenAddress,\r\n    uint256 liquidityAdded,\r\n    uint256 liquidityTaken\r\n  ) internal {\r\n    UpdateInterestRatesLocalVars memory vars;\r\n\r\n    vars.stableDebtTokenAddress = reserve.stableDebtTokenAddress;\r\n\r\n    (vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(vars.stableDebtTokenAddress)\r\n      .getTotalSupplyAndAvgRate();\r\n\r\n    //calculates the total variable debt locally using the scaled total supply instead\r\n    //of totalSupply(), as it's noticeably cheaper. Also, the index has been\r\n    //updated by the previous updateState() call\r\n    vars.totalVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress)\r\n      .scaledTotalSupply()\r\n      .rayMul(reserve.variableBorrowIndex);\r\n\r\n    (\r\n      vars.newLiquidityRate,\r\n      vars.newStableRate,\r\n      vars.newVariableRate\r\n    ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(\r\n      reserveAddress,\r\n      aTokenAddress,\r\n      liquidityAdded,\r\n      liquidityTaken,\r\n      vars.totalStableDebt,\r\n      vars.totalVariableDebt,\r\n      vars.avgStableRate,\r\n      reserve.configuration.getReserveFactor()\r\n    );\r\n    require(vars.newLiquidityRate <= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW);\r\n    require(vars.newStableRate <= type(uint128).max, Errors.RL_STABLE_BORROW_RATE_OVERFLOW);\r\n    require(vars.newVariableRate <= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW);\r\n\r\n    reserve.currentLiquidityRate = uint128(vars.newLiquidityRate);\r\n    reserve.currentStableBorrowRate = uint128(vars.newStableRate);\r\n    reserve.currentVariableBorrowRate = uint128(vars.newVariableRate);\r\n\r\n    emit ReserveDataUpdated(\r\n      reserveAddress,\r\n      vars.newLiquidityRate,\r\n      vars.newStableRate,\r\n      vars.newVariableRate,\r\n      reserve.liquidityIndex,\r\n      reserve.variableBorrowIndex\r\n    );\r\n  }\r\n\r\n  struct MintToTreasuryLocalVars {\r\n    uint256 currentStableDebt;\r\n    uint256 principalStableDebt;\r\n    uint256 previousStableDebt;\r\n    uint256 currentVariableDebt;\r\n    uint256 previousVariableDebt;\r\n    uint256 avgStableRate;\r\n    uint256 cumulatedStableInterest;\r\n    uint256 totalDebtAccrued;\r\n    uint256 amountToMint;\r\n    uint256 reserveFactor;\r\n    uint40 stableSupplyUpdatedTimestamp;\r\n  }\r\n\r\n  /**\r\n   * @dev Mints part of the repaid interest to the reserve treasury as a function of the reserveFactor for the\r\n   * specific asset.\r\n   * @param reserve The reserve reserve to be updated\r\n   * @param scaledVariableDebt The current scaled total variable debt\r\n   * @param previousVariableBorrowIndex The variable borrow index before the last accumulation of the interest\r\n   * @param newLiquidityIndex The new liquidity index\r\n   * @param newVariableBorrowIndex The variable borrow index after the last accumulation of the interest\r\n   **/\r\n  function _mintToTreasury(\r\n    DataTypes.ReserveData storage reserve,\r\n    uint256 scaledVariableDebt,\r\n    uint256 previousVariableBorrowIndex,\r\n    uint256 newLiquidityIndex,\r\n    uint256 newVariableBorrowIndex,\r\n    uint40 timestamp\r\n  ) internal {\r\n    MintToTreasuryLocalVars memory vars;\r\n\r\n    vars.reserveFactor = reserve.configuration.getReserveFactor();\r\n\r\n    if (vars.reserveFactor == 0) {\r\n      return;\r\n    }\r\n\r\n    //fetching the principal, total stable debt and the avg stable rate\r\n    (\r\n      vars.principalStableDebt,\r\n      vars.currentStableDebt,\r\n      vars.avgStableRate,\r\n      vars.stableSupplyUpdatedTimestamp\r\n    ) = IStableDebtToken(reserve.stableDebtTokenAddress).getSupplyData();\r\n\r\n    //calculate the last principal variable debt\r\n    vars.previousVariableDebt = scaledVariableDebt.rayMul(previousVariableBorrowIndex);\r\n\r\n    //calculate the new total supply after accumulation of the index\r\n    vars.currentVariableDebt = scaledVariableDebt.rayMul(newVariableBorrowIndex);\r\n\r\n    //calculate the stable debt until the last timestamp update\r\n    vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(\r\n      vars.avgStableRate,\r\n      vars.stableSupplyUpdatedTimestamp,\r\n      timestamp\r\n    );\r\n\r\n    vars.previousStableDebt = vars.principalStableDebt.rayMul(vars.cumulatedStableInterest);\r\n\r\n    //debt accrued is the sum of the current debt minus the sum of the debt at the last update\r\n    vars.totalDebtAccrued = vars\r\n      .currentVariableDebt\r\n      .add(vars.currentStableDebt)\r\n      .sub(vars.previousVariableDebt)\r\n      .sub(vars.previousStableDebt);\r\n\r\n    vars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor);\r\n\r\n    if (vars.amountToMint != 0) {\r\n      IAToken(reserve.aTokenAddress).mintToTreasury(vars.amountToMint, newLiquidityIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the reserve indexes and the timestamp of the update\r\n   * @param reserve The reserve reserve to be updated\r\n   * @param scaledVariableDebt The scaled variable debt\r\n   * @param liquidityIndex The last stored liquidity index\r\n   * @param variableBorrowIndex The last stored variable borrow index\r\n   **/\r\n  function _updateIndexes(\r\n    DataTypes.ReserveData storage reserve,\r\n    uint256 scaledVariableDebt,\r\n    uint256 liquidityIndex,\r\n    uint256 variableBorrowIndex,\r\n    uint40 timestamp\r\n  ) internal returns (uint256, uint256) {\r\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\r\n\r\n    uint256 newLiquidityIndex = liquidityIndex;\r\n    uint256 newVariableBorrowIndex = variableBorrowIndex;\r\n\r\n    //only cumulating if there is any income being produced\r\n    if (currentLiquidityRate > 0) {\r\n      uint256 cumulatedLiquidityInterest =\r\n        MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp);\r\n      newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex);\r\n      require(newLiquidityIndex <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\r\n\r\n      reserve.liquidityIndex = uint128(newLiquidityIndex);\r\n\r\n      //as the liquidity rate might come only from stable rate loans, we need to ensure\r\n      //that there is actual variable debt before accumulating\r\n      if (scaledVariableDebt != 0) {\r\n        uint256 cumulatedVariableBorrowInterest =\r\n          MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp);\r\n        newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex);\r\n        require(\r\n          newVariableBorrowIndex <= type(uint128).max,\r\n          Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW\r\n        );\r\n        reserve.variableBorrowIndex = uint128(newVariableBorrowIndex);\r\n      }\r\n    }\r\n\r\n    //solium-disable-next-line\r\n    reserve.lastUpdateTimestamp = uint40(block.timestamp);\r\n    return (newLiquidityIndex, newVariableBorrowIndex);\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/libraries/configuration/ReserveConfiguration.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {Errors} from '../helpers/Errors.sol';\r\nimport {DataTypes} from '../types/DataTypes.sol';\r\n\r\n/**\r\n * @title ReserveConfiguration library\r\n * @author Aave\r\n * @notice Implements the bitmap logic to handle the reserve configuration\r\n */\r\nlibrary ReserveConfiguration {\r\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\r\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\r\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\r\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\r\n\r\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\r\n  uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\r\n  uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\r\n  uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\r\n  uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\r\n  uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\r\n  uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\r\n  uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\r\n  uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\r\n\r\n  uint256 constant MAX_VALID_LTV = 65535;\r\n  uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\r\n  uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\r\n  uint256 constant MAX_VALID_DECIMALS = 255;\r\n  uint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\r\n\r\n  /**\r\n   * @dev Sets the Loan to Value of the reserve\r\n   * @param self The reserve configuration\r\n   * @param ltv the new ltv\r\n   **/\r\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\r\n    require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\r\n\r\n    self.data = (self.data & LTV_MASK) | ltv;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the Loan to Value of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The loan to value\r\n   **/\r\n  function getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\r\n    return self.data & ~LTV_MASK;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the liquidation threshold of the reserve\r\n   * @param self The reserve configuration\r\n   * @param threshold The new liquidation threshold\r\n   **/\r\n  function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold)\r\n    internal\r\n    pure\r\n  {\r\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\r\n\r\n    self.data =\r\n      (self.data & LIQUIDATION_THRESHOLD_MASK) |\r\n      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the liquidation threshold of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The liquidation threshold\r\n   **/\r\n  function getLiquidationThreshold(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the liquidation bonus of the reserve\r\n   * @param self The reserve configuration\r\n   * @param bonus The new liquidation bonus\r\n   **/\r\n  function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus)\r\n    internal\r\n    pure\r\n  {\r\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\r\n\r\n    self.data =\r\n      (self.data & LIQUIDATION_BONUS_MASK) |\r\n      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the liquidation bonus of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The liquidation bonus\r\n   **/\r\n  function getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the decimals of the underlying asset of the reserve\r\n   * @param self The reserve configuration\r\n   * @param decimals The decimals\r\n   **/\r\n  function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals)\r\n    internal\r\n    pure\r\n  {\r\n    require(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\r\n\r\n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the decimals of the underlying asset of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The decimals of the asset\r\n   **/\r\n  function getDecimals(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the active state of the reserve\r\n   * @param self The reserve configuration\r\n   * @param active The active state\r\n   **/\r\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\r\n    self.data =\r\n      (self.data & ACTIVE_MASK) |\r\n      (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the active state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The active state\r\n   **/\r\n  function getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\r\n    return (self.data & ~ACTIVE_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the frozen state of the reserve\r\n   * @param self The reserve configuration\r\n   * @param frozen The frozen state\r\n   **/\r\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\r\n    self.data =\r\n      (self.data & FROZEN_MASK) |\r\n      (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the frozen state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The frozen state\r\n   **/\r\n  function getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\r\n    return (self.data & ~FROZEN_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Enables or disables borrowing on the reserve\r\n   * @param self The reserve configuration\r\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\r\n   **/\r\n  function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled)\r\n    internal\r\n    pure\r\n  {\r\n    self.data =\r\n      (self.data & BORROWING_MASK) |\r\n      (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the borrowing state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The borrowing state\r\n   **/\r\n  function getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return (self.data & ~BORROWING_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Enables or disables stable rate borrowing on the reserve\r\n   * @param self The reserve configuration\r\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\r\n   **/\r\n  function setStableRateBorrowingEnabled(\r\n    DataTypes.ReserveConfigurationMap memory self,\r\n    bool enabled\r\n  ) internal pure {\r\n    self.data =\r\n      (self.data & STABLE_BORROWING_MASK) |\r\n      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the stable rate borrowing state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The stable rate borrowing state\r\n   **/\r\n  function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the reserve factor of the reserve\r\n   * @param self The reserve configuration\r\n   * @param reserveFactor The reserve factor\r\n   **/\r\n  function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor)\r\n    internal\r\n    pure\r\n  {\r\n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);\r\n\r\n    self.data =\r\n      (self.data & RESERVE_FACTOR_MASK) |\r\n      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the reserve factor of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The reserve factor\r\n   **/\r\n  function getReserveFactor(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration flags of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\r\n   **/\r\n  function getFlags(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (\r\n      bool,\r\n      bool,\r\n      bool,\r\n      bool\r\n    )\r\n  {\r\n    uint256 dataLocal = self.data;\r\n\r\n    return (\r\n      (dataLocal & ~ACTIVE_MASK) != 0,\r\n      (dataLocal & ~FROZEN_MASK) != 0,\r\n      (dataLocal & ~BORROWING_MASK) != 0,\r\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration paramters of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\r\n   **/\r\n  function getParams(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    uint256 dataLocal = self.data;\r\n\r\n    return (\r\n      dataLocal & ~LTV_MASK,\r\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\r\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\r\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\r\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration paramters of the reserve from a memory object\r\n   * @param self The reserve configuration\r\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\r\n   **/\r\n  function getParamsMemory(DataTypes.ReserveConfigurationMap memory self)\r\n    internal\r\n    pure\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    return (\r\n      self.data & ~LTV_MASK,\r\n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\r\n      (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\r\n      (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\r\n      (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration flags of the reserve from a memory object\r\n   * @param self The reserve configuration\r\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\r\n   **/\r\n  function getFlagsMemory(DataTypes.ReserveConfigurationMap memory self)\r\n    internal\r\n    pure\r\n    returns (\r\n      bool,\r\n      bool,\r\n      bool,\r\n      bool\r\n    )\r\n  {\r\n    return (\r\n      (self.data & ~ACTIVE_MASK) != 0,\r\n      (self.data & ~FROZEN_MASK) != 0,\r\n      (self.data & ~BORROWING_MASK) != 0,\r\n      (self.data & ~STABLE_BORROWING_MASK) != 0\r\n    );\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/libraries/configuration/UserConfiguration.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {Errors} from '../helpers/Errors.sol';\r\nimport {DataTypes} from '../types/DataTypes.sol';\r\n\r\n/**\r\n * @title UserConfiguration library\r\n * @author Aave\r\n * @notice Implements the bitmap logic to handle the user configuration\r\n */\r\nlibrary UserConfiguration {\r\n  uint256 internal constant BORROWING_MASK =\r\n    0x5555555555555555555555555555555555555555555555555555555555555555;\r\n\r\n  /**\r\n   * @dev Sets if the user is borrowing the reserve identified by reserveIndex\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @param borrowing True if the user is borrowing the reserve, false otherwise\r\n   **/\r\n  function setBorrowing(\r\n    DataTypes.UserConfigurationMap storage self,\r\n    uint256 reserveIndex,\r\n    bool borrowing\r\n  ) internal {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    self.data =\r\n      (self.data & ~(1 << (reserveIndex * 2))) |\r\n      (uint256(borrowing ? 1 : 0) << (reserveIndex * 2));\r\n  }\r\n\r\n  /**\r\n   * @dev Sets if the user is using as collateral the reserve identified by reserveIndex\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @param usingAsCollateral True if the user is usin the reserve as collateral, false otherwise\r\n   **/\r\n  function setUsingAsCollateral(\r\n    DataTypes.UserConfigurationMap storage self,\r\n    uint256 reserveIndex,\r\n    bool usingAsCollateral\r\n  ) internal {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    self.data =\r\n      (self.data & ~(1 << (reserveIndex * 2 + 1))) |\r\n      (uint256(usingAsCollateral ? 1 : 0) << (reserveIndex * 2 + 1));\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been using the reserve for borrowing or as collateral\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise\r\n   **/\r\n  function isUsingAsCollateralOrBorrowing(\r\n    DataTypes.UserConfigurationMap memory self,\r\n    uint256 reserveIndex\r\n  ) internal pure returns (bool) {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    return (self.data >> (reserveIndex * 2)) & 3 != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been using the reserve for borrowing\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @return True if the user has been using a reserve for borrowing, false otherwise\r\n   **/\r\n  function isBorrowing(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    return (self.data >> (reserveIndex * 2)) & 1 != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been using the reserve as collateral\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @return True if the user has been using a reserve as collateral, false otherwise\r\n   **/\r\n  function isUsingAsCollateral(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    return (self.data >> (reserveIndex * 2 + 1)) & 1 != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been borrowing from any reserve\r\n   * @param self The configuration object\r\n   * @return True if the user has been borrowing any reserve, false otherwise\r\n   **/\r\n  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\r\n    return self.data & BORROWING_MASK != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has not been using any reserve\r\n   * @param self The configuration object\r\n   * @return True if the user has been borrowing any reserve, false otherwise\r\n   **/\r\n  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\r\n    return self.data == 0;\r\n  }\r\n}\r\n"
      },
      "contracts/interfaces/IReserveInterestRateStrategy.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title IReserveInterestRateStrategyInterface interface\r\n * @dev Interface for the calculation of the interest rates\r\n * @author Aave\r\n */\r\ninterface IReserveInterestRateStrategy {\r\n  function baseVariableBorrowRate() external view returns (uint256);\r\n\r\n  function getMaxVariableBorrowRate() external view returns (uint256);\r\n\r\n  function calculateInterestRates(\r\n    address reserve,\r\n    uint256 availableLiquidity,\r\n    uint256 totalStableDebt,\r\n    uint256 totalVariableDebt,\r\n    uint256 averageStableBorrowRate,\r\n    uint256 reserveFactor\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    );\r\n\r\n  function calculateInterestRates(\r\n    address reserve,\r\n    address aToken,\r\n    uint256 liquidityAdded,\r\n    uint256 liquidityTaken,\r\n    uint256 totalStableDebt,\r\n    uint256 totalVariableDebt,\r\n    uint256 averageStableBorrowRate,\r\n    uint256 reserveFactor\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 liquidityRate,\r\n      uint256 stableBorrowRate,\r\n      uint256 variableBorrowRate\r\n    );\r\n}\r\n"
      },
      "contracts/protocol/libraries/math/MathUtils.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol';\r\nimport {WadRayMath} from './WadRayMath.sol';\r\n\r\nlibrary MathUtils {\r\n  using SafeMath for uint256;\r\n  using WadRayMath for uint256;\r\n\r\n  /// @dev Ignoring leap years\r\n  uint256 internal constant SECONDS_PER_YEAR = 365 days;\r\n\r\n  /**\r\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\r\n   * @param rate The interest rate, in ray\r\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\r\n   * @return The interest rate linearly accumulated during the timeDelta, in ray\r\n   **/\r\n\r\n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    //solium-disable-next-line\r\n    uint256 timeDifference = block.timestamp.sub(uint256(lastUpdateTimestamp));\r\n\r\n    return (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray());\r\n  }\r\n\r\n  /**\r\n   * @dev Function to calculate the interest using a compounded interest rate formula\r\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\r\n   *\r\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\r\n   *\r\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\r\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\r\n   *\r\n   * @param rate The interest rate, in ray\r\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\r\n   * @return The interest rate compounded during the timeDelta, in ray\r\n   **/\r\n  function calculateCompoundedInterest(\r\n    uint256 rate,\r\n    uint40 lastUpdateTimestamp,\r\n    uint256 currentTimestamp\r\n  ) internal pure returns (uint256) {\r\n    //solium-disable-next-line\r\n    uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp));\r\n\r\n    if (exp == 0) {\r\n      return WadRayMath.ray();\r\n    }\r\n\r\n    uint256 expMinusOne = exp - 1;\r\n\r\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\r\n\r\n    uint256 ratePerSecond = rate / SECONDS_PER_YEAR;\r\n\r\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\r\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\r\n\r\n    uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2;\r\n    uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree) / 6;\r\n\r\n    return WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(thirdTerm);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\r\n   * @param rate The interest rate (in ray)\r\n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\r\n   **/\r\n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\r\n  }\r\n}\r\n"
      },
      "contracts/mocks/flashloan/MockFlashLoanReceiver.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\r\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\r\n\r\nimport {FlashLoanReceiverBase} from '../../flashloan/base/FlashLoanReceiverBase.sol';\r\nimport {MintableERC20} from '../tokens/MintableERC20.sol';\r\nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol';\r\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\r\n\r\ncontract MockFlashLoanReceiver is FlashLoanReceiverBase {\r\n  using SafeERC20 for IERC20;\r\n\r\n  ILendingPoolAddressesProvider internal _provider;\r\n\r\n  event ExecutedWithFail(address[] _assets, uint256[] _amounts, uint256[] _premiums);\r\n  event ExecutedWithSuccess(address[] _assets, uint256[] _amounts, uint256[] _premiums);\r\n\r\n  bool _failExecution;\r\n  uint256 _amountToApprove;\r\n  bool _simulateEOA;\r\n\r\n  constructor(ILendingPoolAddressesProvider provider) public FlashLoanReceiverBase(provider) {}\r\n\r\n  function setFailExecutionTransfer(bool fail) public {\r\n    _failExecution = fail;\r\n  }\r\n\r\n  function setAmountToApprove(uint256 amountToApprove) public {\r\n    _amountToApprove = amountToApprove;\r\n  }\r\n\r\n  function setSimulateEOA(bool flag) public {\r\n    _simulateEOA = flag;\r\n  }\r\n\r\n  function amountToApprove() public view returns (uint256) {\r\n    return _amountToApprove;\r\n  }\r\n\r\n  function simulateEOA() public view returns (bool) {\r\n    return _simulateEOA;\r\n  }\r\n\r\n  function executeOperation(\r\n    address[] memory assets,\r\n    uint256[] memory amounts,\r\n    uint256[] memory premiums,\r\n    address initiator,\r\n    bytes memory params\r\n  ) public override returns (bool) {\r\n    params;\r\n    initiator;\r\n\r\n    if (_failExecution) {\r\n      emit ExecutedWithFail(assets, amounts, premiums);\r\n      return !_simulateEOA;\r\n    }\r\n\r\n    for (uint256 i = 0; i < assets.length; i++) {\r\n      //mint to this contract the specific amount\r\n      MintableERC20 token = MintableERC20(assets[i]);\r\n\r\n      //check the contract has the specified balance\r\n      require(\r\n        amounts[i] <= IERC20(assets[i]).balanceOf(address(this)),\r\n        'Invalid balance for the contract'\r\n      );\r\n\r\n      uint256 amountToReturn =\r\n        (_amountToApprove != 0) ? _amountToApprove : amounts[i].add(premiums[i]);\r\n      //execution does not fail - mint tokens and return them to the _destination\r\n\r\n      token.mint(premiums[i]);\r\n\r\n      IERC20(assets[i]).approve(address(LENDING_POOL), amountToReturn);\r\n    }\r\n\r\n    emit ExecutedWithSuccess(assets, amounts, premiums);\r\n\r\n    return true;\r\n  }\r\n}\r\n"
      },
      "contracts/mocks/tokens/MintableERC20.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {ERC20} from '../../dependencies/openzeppelin/contracts/ERC20.sol';\r\n\r\n/**\r\n * @title ERC20Mintable\r\n * @dev ERC20 minting logic\r\n */\r\ncontract MintableERC20 is ERC20 {\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint8 decimals\r\n  ) public ERC20(name, symbol) {\r\n    _setupDecimals(decimals);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param value The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(uint256 value) public returns (bool) {\r\n    _mint(_msgSender(), value);\r\n    return true;\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/contracts/ERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nimport './Context.sol';\r\nimport './IERC20.sol';\r\nimport './SafeMath.sol';\r\nimport './Address.sol';\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  mapping(address => uint256) private _balances;\r\n\r\n  mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  /**\r\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n   * a default value of 18.\r\n   *\r\n   * To select a different value for {decimals}, use {_setupDecimals}.\r\n   *\r\n   * All three of these values are immutable: they can only be set once during\r\n   * construction.\r\n   */\r\n  constructor(string memory name, string memory symbol) public {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _decimals = 18;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name() public view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token, usually a shorter version of the\r\n   * name.\r\n   */\r\n  function symbol() public view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of decimals used to get its user representation.\r\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n   *\r\n   * Tokens usually opt for a value of 18, imitating the relationship between\r\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n   * called.\r\n   *\r\n   * NOTE: This information is only used for _display_ purposes: it in\r\n   * no way affects any of the arithmetic of the contract, including\r\n   * {IERC20-balanceOf} and {IERC20-transfer}.\r\n   */\r\n  function decimals() public view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-totalSupply}.\r\n   */\r\n  function totalSupply() public view override returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-balanceOf}.\r\n   */\r\n  function balanceOf(address account) public view override returns (uint256) {\r\n    return _balances[account];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transfer}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `recipient` cannot be the zero address.\r\n   * - the caller must have a balance of at least `amount`.\r\n   */\r\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-allowance}.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-approve}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transferFrom}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance. This is not\r\n   * required by the EIP. See the note at the beginning of {ERC20};\r\n   *\r\n   * Requirements:\r\n   * - `sender` and `recipient` cannot be the zero address.\r\n   * - `sender` must have a balance of at least `amount`.\r\n   * - the caller must have allowance for ``sender``'s tokens of at least\r\n   * `amount`.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(\r\n      sender,\r\n      _msgSender(),\r\n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance')\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   * - `spender` must have allowance for the caller of at least\r\n   * `subtractedValue`.\r\n   */\r\n  function decreaseAllowance(address spender, uint256 subtractedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    _approve(\r\n      _msgSender(),\r\n      spender,\r\n      _allowances[_msgSender()][spender].sub(\r\n        subtractedValue,\r\n        'ERC20: decreased allowance below zero'\r\n      )\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n   *\r\n   * This is internal function is equivalent to {transfer}, and can be used to\r\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `sender` cannot be the zero address.\r\n   * - `recipient` cannot be the zero address.\r\n   * - `sender` must have a balance of at least `amount`.\r\n   */\r\n  function _transfer(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(sender != address(0), 'ERC20: transfer from the zero address');\r\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\r\n\r\n    _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n    _balances[sender] = _balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');\r\n    _balances[recipient] = _balances[recipient].add(amount);\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n   * the total supply.\r\n   *\r\n   * Emits a {Transfer} event with `from` set to the zero address.\r\n   *\r\n   * Requirements\r\n   *\r\n   * - `to` cannot be the zero address.\r\n   */\r\n  function _mint(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), 'ERC20: mint to the zero address');\r\n\r\n    _beforeTokenTransfer(address(0), account, amount);\r\n\r\n    _totalSupply = _totalSupply.add(amount);\r\n    _balances[account] = _balances[account].add(amount);\r\n    emit Transfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from `account`, reducing the\r\n   * total supply.\r\n   *\r\n   * Emits a {Transfer} event with `to` set to the zero address.\r\n   *\r\n   * Requirements\r\n   *\r\n   * - `account` cannot be the zero address.\r\n   * - `account` must have at least `amount` tokens.\r\n   */\r\n  function _burn(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), 'ERC20: burn from the zero address');\r\n\r\n    _beforeTokenTransfer(account, address(0), amount);\r\n\r\n    _balances[account] = _balances[account].sub(amount, 'ERC20: burn amount exceeds balance');\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n   *\r\n   * This is internal function is equivalent to `approve`, and can be used to\r\n   * e.g. set automatic allowances for certain subsystems, etc.\r\n   *\r\n   * Emits an {Approval} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `owner` cannot be the zero address.\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function _approve(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(owner != address(0), 'ERC20: approve from the zero address');\r\n    require(spender != address(0), 'ERC20: approve to the zero address');\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets {decimals} to a value other than the default one of 18.\r\n   *\r\n   * WARNING: This function should only be called from the constructor. Most\r\n   * applications that interact with token contracts will not expect\r\n   * {decimals} to ever change, and may work incorrectly if it does.\r\n   */\r\n  function _setupDecimals(uint8 decimals_) internal {\r\n    _decimals = decimals_;\r\n  }\r\n\r\n  /**\r\n   * @dev Hook that is called before any transfer of tokens. This includes\r\n   * minting and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n   * will be to transferred to `to`.\r\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {}\r\n}\r\n"
      },
      "contracts/misc/WalletBalanceProvider.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {Address} from '../dependencies/openzeppelin/contracts/Address.sol';\r\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\r\n\r\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\r\nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol';\r\nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol';\r\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\r\n\r\n/**\r\n * @title WalletBalanceProvider contract\r\n * @author Aave, influenced by https://github.com/wbobeirne/eth-balance-checker/blob/master/contracts/BalanceChecker.sol\r\n * @notice Implements a logic of getting multiple tokens balance for one user address\r\n * @dev NOTE: THIS CONTRACT IS NOT USED WITHIN THE AAVE PROTOCOL. It's an accessory contract used to reduce the number of calls\r\n * towards the blockchain from the Aave backend.\r\n **/\r\ncontract WalletBalanceProvider {\r\n  using Address for address payable;\r\n  using Address for address;\r\n  using SafeERC20 for IERC20;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n\r\n  address constant MOCK_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n  /**\r\n    @dev Fallback function, don't accept any ETH\r\n    **/\r\n  receive() external payable {\r\n    //only contracts can send ETH to the core\r\n    require(msg.sender.isContract(), '22');\r\n  }\r\n\r\n  /**\r\n    @dev Check the token balance of a wallet in a token contract\r\n\r\n    Returns the balance of the token for user. Avoids possible errors:\r\n      - return 0 on non-contract address\r\n    **/\r\n  function balanceOf(address user, address token) public view returns (uint256) {\r\n    if (token == MOCK_ETH_ADDRESS) {\r\n      return user.balance; // ETH balance\r\n      // check if token is actually a contract\r\n    } else if (token.isContract()) {\r\n      return IERC20(token).balanceOf(user);\r\n    }\r\n    revert('INVALID_TOKEN');\r\n  }\r\n\r\n  /**\r\n   * @notice Fetches, for a list of _users and _tokens (ETH included with mock address), the balances\r\n   * @param users The list of users\r\n   * @param tokens The list of tokens\r\n   * @return And array with the concatenation of, for each user, his/her balances\r\n   **/\r\n  function batchBalanceOf(address[] calldata users, address[] calldata tokens)\r\n    external\r\n    view\r\n    returns (uint256[] memory)\r\n  {\r\n    uint256[] memory balances = new uint256[](users.length * tokens.length);\r\n\r\n    for (uint256 i = 0; i < users.length; i++) {\r\n      for (uint256 j = 0; j < tokens.length; j++) {\r\n        balances[i * tokens.length + j] = balanceOf(users[i], tokens[j]);\r\n      }\r\n    }\r\n\r\n    return balances;\r\n  }\r\n\r\n  /**\r\n    @dev provides balances of user wallet for all reserves available on the pool\r\n    */\r\n  function getUserWalletBalances(address provider, address user)\r\n    external\r\n    view\r\n    returns (address[] memory, uint256[] memory)\r\n  {\r\n    ILendingPool pool = ILendingPool(ILendingPoolAddressesProvider(provider).getLendingPool());\r\n\r\n    address[] memory reserves = pool.getReservesList();\r\n    address[] memory reservesWithEth = new address[](reserves.length + 1);\r\n    for (uint256 i = 0; i < reserves.length; i++) {\r\n      reservesWithEth[i] = reserves[i];\r\n    }\r\n    reservesWithEth[reserves.length] = MOCK_ETH_ADDRESS;\r\n\r\n    uint256[] memory balances = new uint256[](reservesWithEth.length);\r\n\r\n    for (uint256 j = 0; j < reserves.length; j++) {\r\n      DataTypes.ReserveConfigurationMap memory configuration =\r\n        pool.getConfiguration(reservesWithEth[j]);\r\n\r\n      (bool isActive, , , ) = configuration.getFlagsMemory();\r\n\r\n      if (!isActive) {\r\n        balances[j] = 0;\r\n        continue;\r\n      }\r\n      balances[j] = balanceOf(user, reservesWithEth[j]);\r\n    }\r\n    balances[reserves.length] = balanceOf(user, MOCK_ETH_ADDRESS);\r\n\r\n    return (reservesWithEth, balances);\r\n  }\r\n}\r\n"
      },
      "contracts/misc/WETHGateway.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol';\r\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {IWETH} from './interfaces/IWETH.sol';\r\nimport {IWETHGateway} from './interfaces/IWETHGateway.sol';\r\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\r\nimport {IAToken} from '../interfaces/IAToken.sol';\r\nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol';\r\nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol';\r\nimport {Helpers} from '../protocol/libraries/helpers/Helpers.sol';\r\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\r\n\r\ncontract WETHGateway is IWETHGateway, Ownable {\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n  using UserConfiguration for DataTypes.UserConfigurationMap;\r\n\r\n  IWETH internal immutable WETH;\r\n\r\n  /**\r\n   * @dev Sets the WETH address and the LendingPoolAddressesProvider address. Infinite approves lending pool.\r\n   * @param weth Address of the Wrapped Ether contract\r\n   **/\r\n  constructor(address weth) public {\r\n    WETH = IWETH(weth);\r\n  }\r\n\r\n  function authorizeLendingPool(address lendingPool) external onlyOwner {\r\n    WETH.approve(lendingPool, uint256(-1));\r\n  }\r\n\r\n  /**\r\n   * @dev deposits WETH into the reserve, using native ETH. A corresponding amount of the overlying asset (aTokens)\r\n   * is minted.\r\n   * @param lendingPool address of the targeted underlying lending pool\r\n   * @param onBehalfOf address of the user who will receive the aTokens representing the deposit\r\n   * @param referralCode integrators are assigned a referral code and can potentially receive rewards.\r\n   **/\r\n  function depositETH(\r\n    address lendingPool,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external payable override {\r\n    WETH.deposit{value: msg.value}();\r\n    ILendingPool(lendingPool).deposit(address(WETH), msg.value, onBehalfOf, referralCode);\r\n  }\r\n\r\n  /**\r\n   * @dev withdraws the WETH _reserves of msg.sender.\r\n   * @param lendingPool address of the targeted underlying lending pool\r\n   * @param amount amount of aWETH to withdraw and receive native ETH\r\n   * @param to address of the user who will receive native ETH\r\n   */\r\n  function withdrawETH(\r\n    address lendingPool,\r\n    uint256 amount,\r\n    address to\r\n  ) external override {\r\n    IAToken aWETH = IAToken(ILendingPool(lendingPool).getReserveData(address(WETH)).aTokenAddress);\r\n    uint256 userBalance = aWETH.balanceOf(msg.sender);\r\n    uint256 amountToWithdraw = amount;\r\n\r\n    // if amount is equal to uint(-1), the user wants to redeem everything\r\n    if (amount == type(uint256).max) {\r\n      amountToWithdraw = userBalance;\r\n    }\r\n    aWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\r\n    ILendingPool(lendingPool).withdraw(address(WETH), amountToWithdraw, address(this));\r\n    WETH.withdraw(amountToWithdraw);\r\n    _safeTransferETH(to, amountToWithdraw);\r\n  }\r\n\r\n  /**\r\n   * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\r\n   * @param lendingPool address of the targeted underlying lending pool\r\n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\r\n   * @param rateMode the rate mode to repay\r\n   * @param onBehalfOf the address for which msg.sender is repaying\r\n   */\r\n  function repayETH(\r\n    address lendingPool,\r\n    uint256 amount,\r\n    uint256 rateMode,\r\n    address onBehalfOf\r\n  ) external payable override {\r\n    (uint256 stableDebt, uint256 variableDebt) =\r\n      Helpers.getUserCurrentDebtMemory(\r\n        onBehalfOf,\r\n        ILendingPool(lendingPool).getReserveData(address(WETH))\r\n      );\r\n\r\n    uint256 paybackAmount =\r\n      DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE\r\n        ? stableDebt\r\n        : variableDebt;\r\n\r\n    if (amount < paybackAmount) {\r\n      paybackAmount = amount;\r\n    }\r\n    require(msg.value >= paybackAmount, 'msg.value is less than repayment amount');\r\n    WETH.deposit{value: paybackAmount}();\r\n    ILendingPool(lendingPool).repay(address(WETH), msg.value, rateMode, onBehalfOf);\r\n\r\n    // refund remaining dust eth\r\n    if (msg.value > paybackAmount) _safeTransferETH(msg.sender, msg.value - paybackAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev borrow WETH, unwraps to ETH and send both the ETH and DebtTokens to msg.sender, via `approveDelegation` and onBehalf argument in `LendingPool.borrow`.\r\n   * @param lendingPool address of the targeted underlying lending pool\r\n   * @param amount the amount of ETH to borrow\r\n   * @param interesRateMode the interest rate mode\r\n   * @param referralCode integrators are assigned a referral code and can potentially receive rewards\r\n   */\r\n  function borrowETH(\r\n    address lendingPool,\r\n    uint256 amount,\r\n    uint256 interesRateMode,\r\n    uint16 referralCode\r\n  ) external override {\r\n    ILendingPool(lendingPool).borrow(\r\n      address(WETH),\r\n      amount,\r\n      interesRateMode,\r\n      referralCode,\r\n      msg.sender\r\n    );\r\n    WETH.withdraw(amount);\r\n    _safeTransferETH(msg.sender, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev transfer ETH to an address, revert if it fails.\r\n   * @param to recipient of the transfer\r\n   * @param value the amount to send\r\n   */\r\n  function _safeTransferETH(address to, uint256 value) internal {\r\n    (bool success, ) = to.call{value: value}(new bytes(0));\r\n    require(success, 'ETH_TRANSFER_FAILED');\r\n  }\r\n\r\n  /**\r\n   * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\r\n   * direct transfers to the contract address.\r\n   * @param token token to transfer\r\n   * @param to recipient of the transfer\r\n   * @param amount amount to send\r\n   */\r\n  function emergencyTokenTransfer(\r\n    address token,\r\n    address to,\r\n    uint256 amount\r\n  ) external onlyOwner {\r\n    IERC20(token).transfer(to, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\r\n   * due selfdestructs or transfer ether to pre-computated contract address before deployment.\r\n   * @param to recipient of the transfer\r\n   * @param amount amount to send\r\n   */\r\n  function emergencyEtherTransfer(address to, uint256 amount) external onlyOwner {\r\n    _safeTransferETH(to, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Get WETH address used by WETHGateway\r\n   */\r\n  function getWETHAddress() external view returns (address) {\r\n    return address(WETH);\r\n  }\r\n\r\n  /**\r\n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\r\n   */\r\n  receive() external payable {\r\n    require(msg.sender == address(WETH), 'Receive not allowed');\r\n  }\r\n\r\n  /**\r\n   * @dev Revert fallback calls\r\n   */\r\n  fallback() external payable {\r\n    revert('Fallback not allowed');\r\n  }\r\n}\r\n"
      },
      "contracts/misc/interfaces/IWETH.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\ninterface IWETH {\r\n  function deposit() external payable;\r\n\r\n  function withdraw(uint256) external;\r\n\r\n  function approve(address guy, uint256 wad) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address src,\r\n    address dst,\r\n    uint256 wad\r\n  ) external returns (bool);\r\n}\r\n"
      },
      "contracts/misc/interfaces/IWETHGateway.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\ninterface IWETHGateway {\r\n  function depositETH(\r\n    address lendingPool,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external payable;\r\n\r\n  function withdrawETH(\r\n    address lendingPool,\r\n    uint256 amount,\r\n    address onBehalfOf\r\n  ) external;\r\n\r\n  function repayETH(\r\n    address lendingPool,\r\n    uint256 amount,\r\n    uint256 rateMode,\r\n    address onBehalfOf\r\n  ) external payable;\r\n\r\n  function borrowETH(\r\n    address lendingPool,\r\n    uint256 amount,\r\n    uint256 interesRateMode,\r\n    uint16 referralCode\r\n  ) external;\r\n}\r\n"
      },
      "contracts/protocol/lendingpool/DefaultReserveInterestRateStrategy.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\r\nimport {IReserveInterestRateStrategy} from '../../interfaces/IReserveInterestRateStrategy.sol';\r\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\r\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\r\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {ILendingRateOracle} from '../../interfaces/ILendingRateOracle.sol';\r\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport 'hardhat/console.sol';\r\n\r\n/**\r\n * @title DefaultReserveInterestRateStrategy contract\r\n * @notice Implements the calculation of the interest rates depending on the reserve state\r\n * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_UTILIZATION_RATE`\r\n * point of utilization and another from that one to 100%\r\n * - An instance of this same contract, can't be used across different Aave markets, due to the caching\r\n *   of the LendingPoolAddressesProvider\r\n * @author Aave\r\n **/\r\ncontract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\r\n  using WadRayMath for uint256;\r\n  using SafeMath for uint256;\r\n  using PercentageMath for uint256;\r\n\r\n  /**\r\n   * @dev this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates.\r\n   * Expressed in ray\r\n   **/\r\n  uint256 public immutable OPTIMAL_UTILIZATION_RATE;\r\n\r\n  /**\r\n   * @dev This constant represents the excess utilization rate above the optimal. It's always equal to\r\n   * 1-optimal utilization rate. Added as a constant here for gas optimizations.\r\n   * Expressed in ray\r\n   **/\r\n\r\n  uint256 public immutable EXCESS_UTILIZATION_RATE;\r\n\r\n  ILendingPoolAddressesProvider public immutable addressesProvider;\r\n\r\n  // Base variable borrow rate when Utilization rate = 0. Expressed in ray\r\n  uint256 internal immutable _baseVariableBorrowRate;\r\n\r\n  // Slope of the variable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\r\n  uint256 internal immutable _variableRateSlope1;\r\n\r\n  // Slope of the variable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\r\n  uint256 internal immutable _variableRateSlope2;\r\n\r\n  // Slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\r\n  uint256 internal immutable _stableRateSlope1;\r\n\r\n  // Slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\r\n  uint256 internal immutable _stableRateSlope2;\r\n\r\n  constructor(\r\n    ILendingPoolAddressesProvider provider,\r\n    uint256 optimalUtilizationRate,\r\n    uint256 baseVariableBorrowRate,\r\n    uint256 variableRateSlope1,\r\n    uint256 variableRateSlope2,\r\n    uint256 stableRateSlope1,\r\n    uint256 stableRateSlope2\r\n  ) public {\r\n    OPTIMAL_UTILIZATION_RATE = optimalUtilizationRate;\r\n    EXCESS_UTILIZATION_RATE = WadRayMath.ray().sub(optimalUtilizationRate);\r\n    addressesProvider = provider;\r\n    _baseVariableBorrowRate = baseVariableBorrowRate;\r\n    _variableRateSlope1 = variableRateSlope1;\r\n    _variableRateSlope2 = variableRateSlope2;\r\n    _stableRateSlope1 = stableRateSlope1;\r\n    _stableRateSlope2 = stableRateSlope2;\r\n  }\r\n\r\n  function variableRateSlope1() external view returns (uint256) {\r\n    return _variableRateSlope1;\r\n  }\r\n\r\n  function variableRateSlope2() external view returns (uint256) {\r\n    return _variableRateSlope2;\r\n  }\r\n\r\n  function stableRateSlope1() external view returns (uint256) {\r\n    return _stableRateSlope1;\r\n  }\r\n\r\n  function stableRateSlope2() external view returns (uint256) {\r\n    return _stableRateSlope2;\r\n  }\r\n\r\n  function baseVariableBorrowRate() external view override returns (uint256) {\r\n    return _baseVariableBorrowRate;\r\n  }\r\n\r\n  function getMaxVariableBorrowRate() external view override returns (uint256) {\r\n    return _baseVariableBorrowRate.add(_variableRateSlope1).add(_variableRateSlope2);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the interest rates depending on the reserve's state and configurations\r\n   * @param reserve The address of the reserve\r\n   * @param liquidityAdded The liquidity added during the operation\r\n   * @param liquidityTaken The liquidity taken during the operation\r\n   * @param totalStableDebt The total borrowed from the reserve a stable rate\r\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\r\n   * @param averageStableBorrowRate The weighted average of all the stable rate loans\r\n   * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\r\n   * @return The liquidity rate, the stable borrow rate and the variable borrow rate\r\n   **/\r\n  function calculateInterestRates(\r\n    address reserve,\r\n    address aToken,\r\n    uint256 liquidityAdded,\r\n    uint256 liquidityTaken,\r\n    uint256 totalStableDebt,\r\n    uint256 totalVariableDebt,\r\n    uint256 averageStableBorrowRate,\r\n    uint256 reserveFactor\r\n  )\r\n    external\r\n    view\r\n    override\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    uint256 availableLiquidity = IERC20(reserve).balanceOf(aToken);\r\n    //avoid stack too deep\r\n    availableLiquidity = availableLiquidity.add(liquidityAdded).sub(liquidityTaken);\r\n\r\n    return\r\n      calculateInterestRates(\r\n        reserve,\r\n        availableLiquidity,\r\n        totalStableDebt,\r\n        totalVariableDebt,\r\n        averageStableBorrowRate,\r\n        reserveFactor\r\n      );\r\n  }\r\n\r\n  struct CalcInterestRatesLocalVars {\r\n    uint256 totalDebt;\r\n    uint256 currentVariableBorrowRate;\r\n    uint256 currentStableBorrowRate;\r\n    uint256 currentLiquidityRate;\r\n    uint256 utilizationRate;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the interest rates depending on the reserve's state and configurations.\r\n   * NOTE This function is kept for compatibility with the previous DefaultInterestRateStrategy interface.\r\n   * New protocol implementation uses the new calculateInterestRates() interface\r\n   * @param reserve The address of the reserve\r\n   * @param availableLiquidity The liquidity available in the corresponding aToken\r\n   * @param totalStableDebt The total borrowed from the reserve a stable rate\r\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\r\n   * @param averageStableBorrowRate The weighted average of all the stable rate loans\r\n   * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\r\n   * @return The liquidity rate, the stable borrow rate and the variable borrow rate\r\n   **/\r\n  function calculateInterestRates(\r\n    address reserve,\r\n    uint256 availableLiquidity,\r\n    uint256 totalStableDebt,\r\n    uint256 totalVariableDebt,\r\n    uint256 averageStableBorrowRate,\r\n    uint256 reserveFactor\r\n  )\r\n    public\r\n    view\r\n    override\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    CalcInterestRatesLocalVars memory vars;\r\n\r\n    vars.totalDebt = totalStableDebt.add(totalVariableDebt);\r\n    vars.currentVariableBorrowRate = 0;\r\n    vars.currentStableBorrowRate = 0;\r\n    vars.currentLiquidityRate = 0;\r\n\r\n    vars.utilizationRate = vars.totalDebt == 0\r\n      ? 0\r\n      : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt));\r\n\r\n    vars.currentStableBorrowRate = ILendingRateOracle(addressesProvider.getLendingRateOracle())\r\n      .getMarketBorrowRate(reserve);\r\n\r\n    if (vars.utilizationRate > OPTIMAL_UTILIZATION_RATE) {\r\n      uint256 excessUtilizationRateRatio =\r\n        vars.utilizationRate.sub(OPTIMAL_UTILIZATION_RATE).rayDiv(EXCESS_UTILIZATION_RATE);\r\n\r\n      vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(_stableRateSlope1).add(\r\n        _stableRateSlope2.rayMul(excessUtilizationRateRatio)\r\n      );\r\n\r\n      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(_variableRateSlope1).add(\r\n        _variableRateSlope2.rayMul(excessUtilizationRateRatio)\r\n      );\r\n    } else {\r\n      vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(\r\n        _stableRateSlope1.rayMul(vars.utilizationRate.rayDiv(OPTIMAL_UTILIZATION_RATE))\r\n      );\r\n      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(\r\n        vars.utilizationRate.rayMul(_variableRateSlope1).rayDiv(OPTIMAL_UTILIZATION_RATE)\r\n      );\r\n    }\r\n\r\n    vars.currentLiquidityRate = _getOverallBorrowRate(\r\n      totalStableDebt,\r\n      totalVariableDebt,\r\n      vars\r\n        .currentVariableBorrowRate,\r\n      averageStableBorrowRate\r\n    )\r\n      .rayMul(vars.utilizationRate)\r\n      .percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(reserveFactor));\r\n\r\n    return (\r\n      vars.currentLiquidityRate,\r\n      vars.currentStableBorrowRate,\r\n      vars.currentVariableBorrowRate\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable debt\r\n   * @param totalStableDebt The total borrowed from the reserve a stable rate\r\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\r\n   * @param currentVariableBorrowRate The current variable borrow rate of the reserve\r\n   * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans\r\n   * @return The weighted averaged borrow rate\r\n   **/\r\n  function _getOverallBorrowRate(\r\n    uint256 totalStableDebt,\r\n    uint256 totalVariableDebt,\r\n    uint256 currentVariableBorrowRate,\r\n    uint256 currentAverageStableBorrowRate\r\n  ) internal pure returns (uint256) {\r\n    uint256 totalDebt = totalStableDebt.add(totalVariableDebt);\r\n\r\n    if (totalDebt == 0) return 0;\r\n\r\n    uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate);\r\n\r\n    uint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate);\r\n\r\n    uint256 overallBorrowRate =\r\n      weightedVariableRate.add(weightedStableRate).rayDiv(totalDebt.wadToRay());\r\n\r\n    return overallBorrowRate;\r\n  }\r\n}\r\n"
      },
      "contracts/interfaces/ILendingRateOracle.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title ILendingRateOracle interface\r\n * @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be used as a base for the stable borrow rate calculations\r\n **/\r\n\r\ninterface ILendingRateOracle {\r\n  /**\r\n    @dev returns the market borrow rate in ray\r\n    **/\r\n  function getMarketBorrowRate(address asset) external view returns (uint256);\r\n\r\n  /**\r\n    @dev sets the market borrow rate. Rate value must be in ray\r\n    **/\r\n  function setMarketBorrowRate(address asset, uint256 rate) external;\r\n}\r\n"
      },
      "hardhat/console.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
      },
      "contracts/misc/UiPoolDataProvider.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\r\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {IUiPoolDataProvider} from './interfaces/IUiPoolDataProvider.sol';\r\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\r\nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol';\r\nimport {IAToken} from '../interfaces/IAToken.sol';\r\nimport {IVariableDebtToken} from '../interfaces/IVariableDebtToken.sol';\r\nimport {IStableDebtToken} from '../interfaces/IStableDebtToken.sol';\r\nimport {WadRayMath} from '../protocol/libraries/math/WadRayMath.sol';\r\nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol';\r\nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol';\r\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\r\nimport {\r\n  DefaultReserveInterestRateStrategy\r\n} from '../protocol/lendingpool/DefaultReserveInterestRateStrategy.sol';\r\n\r\ncontract UiPoolDataProvider is IUiPoolDataProvider {\r\n  using WadRayMath for uint256;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n  using UserConfiguration for DataTypes.UserConfigurationMap;\r\n\r\n  address public constant MOCK_USD_ADDRESS = 0x10F7Fc1F91Ba351f9C629c5947AD69bD03C05b96;\r\n\r\n  function getInterestRateStrategySlopes(DefaultReserveInterestRateStrategy interestRateStrategy)\r\n    internal\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    return (\r\n      interestRateStrategy.variableRateSlope1(),\r\n      interestRateStrategy.variableRateSlope2(),\r\n      interestRateStrategy.stableRateSlope1(),\r\n      interestRateStrategy.stableRateSlope2()\r\n    );\r\n  }\r\n\r\n  function getReservesData(ILendingPoolAddressesProvider provider, address user)\r\n    external\r\n    view\r\n    override\r\n    returns (\r\n      AggregatedReserveData[] memory,\r\n      UserReserveData[] memory,\r\n      uint256\r\n    )\r\n  {\r\n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\r\n    IPriceOracleGetter oracle = IPriceOracleGetter(provider.getPriceOracle());\r\n    address[] memory reserves = lendingPool.getReservesList();\r\n    DataTypes.UserConfigurationMap memory userConfig = lendingPool.getUserConfiguration(user);\r\n\r\n    AggregatedReserveData[] memory reservesData = new AggregatedReserveData[](reserves.length);\r\n    UserReserveData[] memory userReservesData =\r\n      new UserReserveData[](user != address(0) ? reserves.length : 0);\r\n\r\n    for (uint256 i = 0; i < reserves.length; i++) {\r\n      AggregatedReserveData memory reserveData = reservesData[i];\r\n      reserveData.underlyingAsset = reserves[i];\r\n\r\n      // reserve current state\r\n      DataTypes.ReserveData memory baseData =\r\n        lendingPool.getReserveData(reserveData.underlyingAsset);\r\n      reserveData.liquidityIndex = baseData.liquidityIndex;\r\n      reserveData.variableBorrowIndex = baseData.variableBorrowIndex;\r\n      reserveData.liquidityRate = baseData.currentLiquidityRate;\r\n      reserveData.variableBorrowRate = baseData.currentVariableBorrowRate;\r\n      reserveData.stableBorrowRate = baseData.currentStableBorrowRate;\r\n      reserveData.lastUpdateTimestamp = baseData.lastUpdateTimestamp;\r\n      reserveData.aTokenAddress = baseData.aTokenAddress;\r\n      reserveData.stableDebtTokenAddress = baseData.stableDebtTokenAddress;\r\n      reserveData.variableDebtTokenAddress = baseData.variableDebtTokenAddress;\r\n      reserveData.interestRateStrategyAddress = baseData.interestRateStrategyAddress;\r\n      reserveData.priceInEth = oracle.getAssetPrice(reserveData.underlyingAsset);\r\n\r\n      reserveData.availableLiquidity = IERC20Detailed(reserveData.underlyingAsset).balanceOf(\r\n        reserveData.aTokenAddress\r\n      );\r\n      (\r\n        reserveData.totalPrincipalStableDebt,\r\n        ,\r\n        reserveData.averageStableRate,\r\n        reserveData.stableDebtLastUpdateTimestamp\r\n      ) = IStableDebtToken(reserveData.stableDebtTokenAddress).getSupplyData();\r\n      reserveData.totalScaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress)\r\n        .scaledTotalSupply();\r\n\r\n      // reserve configuration\r\n\r\n      // we're getting this info from the aToken, because some of assets can be not compliant with ETC20Detailed\r\n      reserveData.symbol = IERC20Detailed(reserveData.aTokenAddress).symbol();\r\n      reserveData.name = '';\r\n\r\n      (\r\n        reserveData.baseLTVasCollateral,\r\n        reserveData.reserveLiquidationThreshold,\r\n        reserveData.reserveLiquidationBonus,\r\n        reserveData.decimals,\r\n        reserveData.reserveFactor\r\n      ) = baseData.configuration.getParamsMemory();\r\n      (\r\n        reserveData.isActive,\r\n        reserveData.isFrozen,\r\n        reserveData.borrowingEnabled,\r\n        reserveData.stableBorrowRateEnabled\r\n      ) = baseData.configuration.getFlagsMemory();\r\n      reserveData.usageAsCollateralEnabled = reserveData.baseLTVasCollateral != 0;\r\n      (\r\n        reserveData.variableRateSlope1,\r\n        reserveData.variableRateSlope2,\r\n        reserveData.stableRateSlope1,\r\n        reserveData.stableRateSlope2\r\n      ) = getInterestRateStrategySlopes(\r\n        DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress)\r\n      );\r\n\r\n      if (user != address(0)) {\r\n        // user reserve data\r\n        userReservesData[i].underlyingAsset = reserveData.underlyingAsset;\r\n        userReservesData[i].scaledATokenBalance = IAToken(reserveData.aTokenAddress)\r\n          .scaledBalanceOf(user);\r\n        userReservesData[i].usageAsCollateralEnabledOnUser = userConfig.isUsingAsCollateral(i);\r\n\r\n        if (userConfig.isBorrowing(i)) {\r\n          userReservesData[i].scaledVariableDebt = IVariableDebtToken(\r\n            reserveData\r\n              .variableDebtTokenAddress\r\n          )\r\n            .scaledBalanceOf(user);\r\n          userReservesData[i].principalStableDebt = IStableDebtToken(\r\n            reserveData\r\n              .stableDebtTokenAddress\r\n          )\r\n            .principalBalanceOf(user);\r\n          if (userReservesData[i].principalStableDebt != 0) {\r\n            userReservesData[i].stableBorrowRate = IStableDebtToken(\r\n              reserveData\r\n                .stableDebtTokenAddress\r\n            )\r\n              .getUserStableRate(user);\r\n            userReservesData[i].stableBorrowLastUpdateTimestamp = IStableDebtToken(\r\n              reserveData\r\n                .stableDebtTokenAddress\r\n            )\r\n              .getUserLastUpdated(user);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return (reservesData, userReservesData, oracle.getAssetPrice(MOCK_USD_ADDRESS));\r\n  }\r\n}\r\n"
      },
      "contracts/misc/interfaces/IUiPoolDataProvider.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\r\n\r\ninterface IUiPoolDataProvider {\r\n  struct AggregatedReserveData {\r\n    address underlyingAsset;\r\n    string name;\r\n    string symbol;\r\n    uint256 decimals;\r\n    uint256 baseLTVasCollateral;\r\n    uint256 reserveLiquidationThreshold;\r\n    uint256 reserveLiquidationBonus;\r\n    uint256 reserveFactor;\r\n    bool usageAsCollateralEnabled;\r\n    bool borrowingEnabled;\r\n    bool stableBorrowRateEnabled;\r\n    bool isActive;\r\n    bool isFrozen;\r\n    // base data\r\n    uint128 liquidityIndex;\r\n    uint128 variableBorrowIndex;\r\n    uint128 liquidityRate;\r\n    uint128 variableBorrowRate;\r\n    uint128 stableBorrowRate;\r\n    uint40 lastUpdateTimestamp;\r\n    address aTokenAddress;\r\n    address stableDebtTokenAddress;\r\n    address variableDebtTokenAddress;\r\n    address interestRateStrategyAddress;\r\n    //\r\n    uint256 availableLiquidity;\r\n    uint256 totalPrincipalStableDebt;\r\n    uint256 averageStableRate;\r\n    uint256 stableDebtLastUpdateTimestamp;\r\n    uint256 totalScaledVariableDebt;\r\n    uint256 priceInEth;\r\n    uint256 variableRateSlope1;\r\n    uint256 variableRateSlope2;\r\n    uint256 stableRateSlope1;\r\n    uint256 stableRateSlope2;\r\n  }\r\n  //\r\n  //  struct ReserveData {\r\n  //    uint256 averageStableBorrowRate;\r\n  //    uint256 totalLiquidity;\r\n  //  }\r\n\r\n  struct UserReserveData {\r\n    address underlyingAsset;\r\n    uint256 scaledATokenBalance;\r\n    bool usageAsCollateralEnabledOnUser;\r\n    uint256 stableBorrowRate;\r\n    uint256 scaledVariableDebt;\r\n    uint256 principalStableDebt;\r\n    uint256 stableBorrowLastUpdateTimestamp;\r\n  }\r\n\r\n  //\r\n  //  struct ATokenSupplyData {\r\n  //    string name;\r\n  //    string symbol;\r\n  //    uint8 decimals;\r\n  //    uint256 totalSupply;\r\n  //    address aTokenAddress;\r\n  //  }\r\n\r\n  function getReservesData(ILendingPoolAddressesProvider provider, address user)\r\n    external\r\n    view\r\n    returns (\r\n      AggregatedReserveData[] memory,\r\n      UserReserveData[] memory,\r\n      uint256\r\n    );\r\n\r\n  //  function getUserReservesData(ILendingPoolAddressesProvider provider, address user)\r\n  //    external\r\n  //    view\r\n  //    returns (UserReserveData[] memory);\r\n  //\r\n  //  function getAllATokenSupply(ILendingPoolAddressesProvider provider)\r\n  //    external\r\n  //    view\r\n  //    returns (ATokenSupplyData[] memory);\r\n  //\r\n  //  function getATokenSupply(address[] calldata aTokens)\r\n  //    external\r\n  //    view\r\n  //    returns (ATokenSupplyData[] memory);\r\n}\r\n"
      },
      "contracts/misc/AaveProtocolDataProvider.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\r\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\r\nimport {IStableDebtToken} from '../interfaces/IStableDebtToken.sol';\r\nimport {IVariableDebtToken} from '../interfaces/IVariableDebtToken.sol';\r\nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol';\r\nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol';\r\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\r\n\r\ncontract AaveProtocolDataProvider {\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n  using UserConfiguration for DataTypes.UserConfigurationMap;\r\n\r\n  address constant MKR = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\r\n  address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n  struct TokenData {\r\n    string symbol;\r\n    address tokenAddress;\r\n  }\r\n\r\n  ILendingPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\r\n\r\n  constructor(ILendingPoolAddressesProvider addressesProvider) public {\r\n    ADDRESSES_PROVIDER = addressesProvider;\r\n  }\r\n\r\n  function getAllReservesTokens() external view returns (TokenData[] memory) {\r\n    ILendingPool pool = ILendingPool(ADDRESSES_PROVIDER.getLendingPool());\r\n    address[] memory reserves = pool.getReservesList();\r\n    TokenData[] memory reservesTokens = new TokenData[](reserves.length);\r\n    for (uint256 i = 0; i < reserves.length; i++) {\r\n      if (reserves[i] == MKR) {\r\n        reservesTokens[i] = TokenData({symbol: 'MKR', tokenAddress: reserves[i]});\r\n        continue;\r\n      }\r\n      if (reserves[i] == ETH) {\r\n        reservesTokens[i] = TokenData({symbol: 'ETH', tokenAddress: reserves[i]});\r\n        continue;\r\n      }\r\n      reservesTokens[i] = TokenData({\r\n        symbol: IERC20Detailed(reserves[i]).symbol(),\r\n        tokenAddress: reserves[i]\r\n      });\r\n    }\r\n    return reservesTokens;\r\n  }\r\n\r\n  function getAllATokens() external view returns (TokenData[] memory) {\r\n    ILendingPool pool = ILendingPool(ADDRESSES_PROVIDER.getLendingPool());\r\n    address[] memory reserves = pool.getReservesList();\r\n    TokenData[] memory aTokens = new TokenData[](reserves.length);\r\n    for (uint256 i = 0; i < reserves.length; i++) {\r\n      DataTypes.ReserveData memory reserveData = pool.getReserveData(reserves[i]);\r\n      aTokens[i] = TokenData({\r\n        symbol: IERC20Detailed(reserveData.aTokenAddress).symbol(),\r\n        tokenAddress: reserveData.aTokenAddress\r\n      });\r\n    }\r\n    return aTokens;\r\n  }\r\n\r\n  function getReserveConfigurationData(address asset)\r\n    external\r\n    view\r\n    returns (\r\n      uint256 decimals,\r\n      uint256 ltv,\r\n      uint256 liquidationThreshold,\r\n      uint256 liquidationBonus,\r\n      uint256 reserveFactor,\r\n      bool usageAsCollateralEnabled,\r\n      bool borrowingEnabled,\r\n      bool stableBorrowRateEnabled,\r\n      bool isActive,\r\n      bool isFrozen\r\n    )\r\n  {\r\n    DataTypes.ReserveConfigurationMap memory configuration =\r\n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getConfiguration(asset);\r\n\r\n    (ltv, liquidationThreshold, liquidationBonus, decimals, reserveFactor) = configuration\r\n      .getParamsMemory();\r\n\r\n    (isActive, isFrozen, borrowingEnabled, stableBorrowRateEnabled) = configuration\r\n      .getFlagsMemory();\r\n\r\n    usageAsCollateralEnabled = liquidationThreshold > 0;\r\n  }\r\n\r\n  function getReserveData(address asset)\r\n    external\r\n    view\r\n    returns (\r\n      uint256 availableLiquidity,\r\n      uint256 totalStableDebt,\r\n      uint256 totalVariableDebt,\r\n      uint256 liquidityRate,\r\n      uint256 variableBorrowRate,\r\n      uint256 stableBorrowRate,\r\n      uint256 averageStableBorrowRate,\r\n      uint256 liquidityIndex,\r\n      uint256 variableBorrowIndex,\r\n      uint40 lastUpdateTimestamp\r\n    )\r\n  {\r\n    DataTypes.ReserveData memory reserve =\r\n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\r\n\r\n    return (\r\n      IERC20Detailed(asset).balanceOf(reserve.aTokenAddress),\r\n      IERC20Detailed(reserve.stableDebtTokenAddress).totalSupply(),\r\n      IERC20Detailed(reserve.variableDebtTokenAddress).totalSupply(),\r\n      reserve.currentLiquidityRate,\r\n      reserve.currentVariableBorrowRate,\r\n      reserve.currentStableBorrowRate,\r\n      IStableDebtToken(reserve.stableDebtTokenAddress).getAverageStableRate(),\r\n      reserve.liquidityIndex,\r\n      reserve.variableBorrowIndex,\r\n      reserve.lastUpdateTimestamp\r\n    );\r\n  }\r\n\r\n  function getUserReserveData(address asset, address user)\r\n    external\r\n    view\r\n    returns (\r\n      uint256 currentATokenBalance,\r\n      uint256 currentStableDebt,\r\n      uint256 currentVariableDebt,\r\n      uint256 principalStableDebt,\r\n      uint256 scaledVariableDebt,\r\n      uint256 stableBorrowRate,\r\n      uint256 liquidityRate,\r\n      uint40 stableRateLastUpdated,\r\n      bool usageAsCollateralEnabled\r\n    )\r\n  {\r\n    DataTypes.ReserveData memory reserve =\r\n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\r\n\r\n    DataTypes.UserConfigurationMap memory userConfig =\r\n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getUserConfiguration(user);\r\n\r\n    currentATokenBalance = IERC20Detailed(reserve.aTokenAddress).balanceOf(user);\r\n    currentVariableDebt = IERC20Detailed(reserve.variableDebtTokenAddress).balanceOf(user);\r\n    currentStableDebt = IERC20Detailed(reserve.stableDebtTokenAddress).balanceOf(user);\r\n    principalStableDebt = IStableDebtToken(reserve.stableDebtTokenAddress).principalBalanceOf(user);\r\n    scaledVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user);\r\n    liquidityRate = reserve.currentLiquidityRate;\r\n    stableBorrowRate = IStableDebtToken(reserve.stableDebtTokenAddress).getUserStableRate(user);\r\n    stableRateLastUpdated = IStableDebtToken(reserve.stableDebtTokenAddress).getUserLastUpdated(\r\n      user\r\n    );\r\n    usageAsCollateralEnabled = userConfig.isUsingAsCollateral(reserve.id);\r\n  }\r\n\r\n  function getReserveTokensAddresses(address asset)\r\n    external\r\n    view\r\n    returns (\r\n      address aTokenAddress,\r\n      address stableDebtTokenAddress,\r\n      address variableDebtTokenAddress\r\n    )\r\n  {\r\n    DataTypes.ReserveData memory reserve =\r\n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\r\n\r\n    return (\r\n      reserve.aTokenAddress,\r\n      reserve.stableDebtTokenAddress,\r\n      reserve.variableDebtTokenAddress\r\n    );\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/tokenization/VariableDebtToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {IVariableDebtToken} from '../../interfaces/IVariableDebtToken.sol';\r\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\r\nimport {Errors} from '../libraries/helpers/Errors.sol';\r\nimport {DebtTokenBase} from './base/DebtTokenBase.sol';\r\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\r\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\r\n\r\n/**\r\n * @title VariableDebtToken\r\n * @notice Implements a variable debt token to track the borrowing positions of users\r\n * at variable rate mode\r\n * @author Aave\r\n **/\r\ncontract VariableDebtToken is DebtTokenBase, IVariableDebtToken {\r\n  using WadRayMath for uint256;\r\n\r\n  uint256 public constant DEBT_TOKEN_REVISION = 0x1;\r\n\r\n  ILendingPool internal _pool;\r\n  address internal _underlyingAsset;\r\n  IAaveIncentivesController internal _incentivesController;\r\n\r\n  /**\r\n   * @dev Initializes the debt token.\r\n   * @param pool The address of the lending pool where this aToken will be used\r\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   * @param incentivesController The smart contract managing potential incentives distribution\r\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\r\n   * @param debtTokenName The name of the token\r\n   * @param debtTokenSymbol The symbol of the token\r\n   */\r\n  function initialize(\r\n    ILendingPool pool,\r\n    address underlyingAsset,\r\n    IAaveIncentivesController incentivesController,\r\n    uint8 debtTokenDecimals,\r\n    string memory debtTokenName,\r\n    string memory debtTokenSymbol,\r\n    bytes calldata params\r\n  ) public override initializer {\r\n    _setName(debtTokenName);\r\n    _setSymbol(debtTokenSymbol);\r\n    _setDecimals(debtTokenDecimals);\r\n\r\n    _pool = pool;\r\n    _underlyingAsset = underlyingAsset;\r\n    _incentivesController = incentivesController;\r\n\r\n    emit Initialized(\r\n      underlyingAsset,\r\n      address(pool),\r\n      address(incentivesController),\r\n      debtTokenDecimals,\r\n      debtTokenName,\r\n      debtTokenSymbol,\r\n      params\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the revision of the stable debt token implementation\r\n   * @return The debt token implementation revision\r\n   **/\r\n  function getRevision() internal pure virtual override returns (uint256) {\r\n    return DEBT_TOKEN_REVISION;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the accumulated debt balance of the user\r\n   * @return The debt balance of the user\r\n   **/\r\n  function balanceOf(address user) public view virtual override returns (uint256) {\r\n    uint256 scaledBalance = super.balanceOf(user);\r\n\r\n    if (scaledBalance == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return scaledBalance.rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset));\r\n  }\r\n\r\n  /**\r\n   * @dev Mints debt token to the `onBehalfOf` address\r\n   * -  Only callable by the LendingPool\r\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\r\n   * of credit delegate, or same as `onBehalfOf` otherwise\r\n   * @param onBehalfOf The address receiving the debt tokens\r\n   * @param amount The amount of debt being minted\r\n   * @param index The variable debt index of the reserve\r\n   * @return `true` if the the previous balance of the user is 0\r\n   **/\r\n  function mint(\r\n    address user,\r\n    address onBehalfOf,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external override onlyLendingPool returns (bool) {\r\n    if (user != onBehalfOf) {\r\n      _decreaseBorrowAllowance(onBehalfOf, user, amount);\r\n    }\r\n\r\n    uint256 previousBalance = super.balanceOf(onBehalfOf);\r\n    uint256 amountScaled = amount.rayDiv(index);\r\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\r\n\r\n    _mint(onBehalfOf, amountScaled);\r\n\r\n    emit Transfer(address(0), onBehalfOf, amount);\r\n    emit Mint(user, onBehalfOf, amount, index);\r\n\r\n    return previousBalance == 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Burns user variable debt\r\n   * - Only callable by the LendingPool\r\n   * @param user The user whose debt is getting burned\r\n   * @param amount The amount getting burned\r\n   * @param index The variable debt index of the reserve\r\n   **/\r\n  function burn(\r\n    address user,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external override onlyLendingPool {\r\n    uint256 amountScaled = amount.rayDiv(index);\r\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\r\n\r\n    _burn(user, amountScaled);\r\n\r\n    emit Transfer(user, address(0), amount);\r\n    emit Burn(user, amount, index);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the principal debt balance of the user from\r\n   * @return The debt balance of the user since the last burn/mint action\r\n   **/\r\n  function scaledBalanceOf(address user) public view virtual override returns (uint256) {\r\n    return super.balanceOf(user);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total supply of the variable debt token. Represents the total debt accrued by the users\r\n   * @return The total supply\r\n   **/\r\n  function totalSupply() public view virtual override returns (uint256) {\r\n    return super.totalSupply().rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\r\n   * @return the scaled total supply\r\n   **/\r\n  function scaledTotalSupply() public view virtual override returns (uint256) {\r\n    return super.totalSupply();\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the principal balance of the user and principal total supply.\r\n   * @param user The address of the user\r\n   * @return The principal balance of the user\r\n   * @return The principal total supply\r\n   **/\r\n  function getScaledUserBalanceAndSupply(address user)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256, uint256)\r\n  {\r\n    return (super.balanceOf(user), super.totalSupply());\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   **/\r\n  function UNDERLYING_ASSET_ADDRESS() public view returns (address) {\r\n    return _underlyingAsset;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view override returns (IAaveIncentivesController) {\r\n    return _getIncentivesController();\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the lending pool where this aToken is used\r\n   **/\r\n  function POOL() public view returns (ILendingPool) {\r\n    return _pool;\r\n  }\r\n\r\n  function _getIncentivesController() internal view override returns (IAaveIncentivesController) {\r\n    return _incentivesController;\r\n  }\r\n\r\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\r\n    return _underlyingAsset;\r\n  }\r\n\r\n  function _getLendingPool() internal view override returns (ILendingPool) {\r\n    return _pool;\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/tokenization/base/DebtTokenBase.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {ILendingPool} from '../../../interfaces/ILendingPool.sol';\r\nimport {ICreditDelegationToken} from '../../../interfaces/ICreditDelegationToken.sol';\r\nimport {\r\n  VersionedInitializable\r\n} from '../../libraries/aave-upgradeability/VersionedInitializable.sol';\r\nimport {IncentivizedERC20} from '../IncentivizedERC20.sol';\r\nimport {Errors} from '../../libraries/helpers/Errors.sol';\r\n\r\n/**\r\n * @title DebtTokenBase\r\n * @notice Base contract for different types of debt tokens, like StableDebtToken or VariableDebtToken\r\n * @author Aave\r\n */\r\n\r\nabstract contract DebtTokenBase is\r\n  IncentivizedERC20('DEBTTOKEN_IMPL', 'DEBTTOKEN_IMPL', 0),\r\n  VersionedInitializable,\r\n  ICreditDelegationToken\r\n{\r\n  mapping(address => mapping(address => uint256)) internal _borrowAllowances;\r\n\r\n  /**\r\n   * @dev Only lending pool can call functions marked by this modifier\r\n   **/\r\n  modifier onlyLendingPool {\r\n    require(_msgSender() == address(_getLendingPool()), Errors.CT_CALLER_MUST_BE_LENDING_POOL);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev delegates borrowing power to a user on the specific debt token\r\n   * @param delegatee the address receiving the delegated borrowing power\r\n   * @param amount the maximum amount being delegated. Delegation will still\r\n   * respect the liquidation constraints (even if delegated, a delegatee cannot\r\n   * force a delegator HF to go below 1)\r\n   **/\r\n  function approveDelegation(address delegatee, uint256 amount) external override {\r\n    _borrowAllowances[_msgSender()][delegatee] = amount;\r\n    emit BorrowAllowanceDelegated(_msgSender(), delegatee, _getUnderlyingAssetAddress(), amount);\r\n  }\r\n\r\n  /**\r\n   * @dev returns the borrow allowance of the user\r\n   * @param fromUser The user to giving allowance\r\n   * @param toUser The user to give allowance to\r\n   * @return the current allowance of toUser\r\n   **/\r\n  function borrowAllowance(address fromUser, address toUser)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _borrowAllowances[fromUser][toUser];\r\n  }\r\n\r\n  /**\r\n   * @dev Being non transferrable, the debt token does not implement any of the\r\n   * standard ERC20 functions for transfer and allowance.\r\n   **/\r\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n    recipient;\r\n    amount;\r\n    revert('TRANSFER_NOT_SUPPORTED');\r\n  }\r\n\r\n  function allowance(address owner, address spender)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    owner;\r\n    spender;\r\n    revert('ALLOWANCE_NOT_SUPPORTED');\r\n  }\r\n\r\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n    spender;\r\n    amount;\r\n    revert('APPROVAL_NOT_SUPPORTED');\r\n  }\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    sender;\r\n    recipient;\r\n    amount;\r\n    revert('TRANSFER_NOT_SUPPORTED');\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue)\r\n    public\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    spender;\r\n    addedValue;\r\n    revert('ALLOWANCE_NOT_SUPPORTED');\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue)\r\n    public\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    spender;\r\n    subtractedValue;\r\n    revert('ALLOWANCE_NOT_SUPPORTED');\r\n  }\r\n\r\n  function _decreaseBorrowAllowance(\r\n    address delegator,\r\n    address delegatee,\r\n    uint256 amount\r\n  ) internal {\r\n    uint256 newAllowance =\r\n      _borrowAllowances[delegator][delegatee].sub(amount, Errors.BORROW_ALLOWANCE_NOT_ENOUGH);\r\n\r\n    _borrowAllowances[delegator][delegatee] = newAllowance;\r\n\r\n    emit BorrowAllowanceDelegated(delegator, delegatee, _getUnderlyingAssetAddress(), newAllowance);\r\n  }\r\n\r\n  function _getUnderlyingAssetAddress() internal view virtual returns (address);\r\n\r\n  function _getLendingPool() internal view virtual returns (ILendingPool);\r\n}\r\n"
      },
      "contracts/interfaces/ICreditDelegationToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\ninterface ICreditDelegationToken {\r\n  event BorrowAllowanceDelegated(\r\n    address indexed fromUser,\r\n    address indexed toUser,\r\n    address asset,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @dev delegates borrowing power to a user on the specific debt token\r\n   * @param delegatee the address receiving the delegated borrowing power\r\n   * @param amount the maximum amount being delegated. Delegation will still\r\n   * respect the liquidation constraints (even if delegated, a delegatee cannot\r\n   * force a delegator HF to go below 1)\r\n   **/\r\n  function approveDelegation(address delegatee, uint256 amount) external;\r\n\r\n  /**\r\n   * @dev returns the borrow allowance of the user\r\n   * @param fromUser The user to giving allowance\r\n   * @param toUser The user to give allowance to\r\n   * @return the current allowance of toUser\r\n   **/\r\n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256);\r\n}\r\n"
      },
      "contracts/protocol/tokenization/IncentivizedERC20.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {Context} from '../../dependencies/openzeppelin/contracts/Context.sol';\r\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\r\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\r\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\r\n\r\n/**\r\n * @title ERC20\r\n * @notice Basic ERC20 implementation\r\n * @author Aave, inspired by the Openzeppelin ERC20 implementation\r\n **/\r\nabstract contract IncentivizedERC20 is Context, IERC20, IERC20Detailed {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) internal _balances;\r\n\r\n  mapping(address => mapping(address => uint256)) private _allowances;\r\n  uint256 internal _totalSupply;\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint8 decimals\r\n  ) public {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _decimals = decimals;\r\n  }\r\n\r\n  /**\r\n   * @return The name of the token\r\n   **/\r\n  function name() public view override returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @return The symbol of the token\r\n   **/\r\n  function symbol() public view override returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @return The decimals of the token\r\n   **/\r\n  function decimals() public view override returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  /**\r\n   * @return The total supply of the token\r\n   **/\r\n  function totalSupply() public view virtual override returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * @return The balance of the token\r\n   **/\r\n  function balanceOf(address account) public view virtual override returns (uint256) {\r\n    return _balances[account];\r\n  }\r\n\r\n  /**\r\n   * @return Abstract function implemented by the child aToken/debtToken. \r\n   * Done this way in order to not break compatibility with previous versions of aTokens/debtTokens\r\n   **/\r\n  function _getIncentivesController() internal view virtual returns(IAaveIncentivesController);\r\n\r\n  /**\r\n   * @dev Executes a transfer of tokens from _msgSender() to recipient\r\n   * @param recipient The recipient of the tokens\r\n   * @param amount The amount of tokens being transferred\r\n   * @return `true` if the transfer succeeds, `false` otherwise\r\n   **/\r\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    emit Transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the allowance of spender on the tokens owned by owner\r\n   * @param owner The owner of the tokens\r\n   * @param spender The user allowed to spend the owner's tokens\r\n   * @return The amount of owner's tokens spender is allowed to spend\r\n   **/\r\n  function allowance(address owner, address spender)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Allows `spender` to spend the tokens owned by _msgSender()\r\n   * @param spender The user allowed to spend _msgSender() tokens\r\n   * @return `true`\r\n   **/\r\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Executes a transfer of token from sender to recipient, if _msgSender() is allowed to do so\r\n   * @param sender The owner of the tokens\r\n   * @param recipient The recipient of the tokens\r\n   * @param amount The amount of tokens being transferred\r\n   * @return `true` if the transfer succeeds, `false` otherwise\r\n   **/\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(\r\n      sender,\r\n      _msgSender(),\r\n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance')\r\n    );\r\n    emit Transfer(sender, recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Increases the allowance of spender to spend _msgSender() tokens\r\n   * @param spender The user allowed to spend on behalf of _msgSender()\r\n   * @param addedValue The amount being added to the allowance\r\n   * @return `true`\r\n   **/\r\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decreases the allowance of spender to spend _msgSender() tokens\r\n   * @param spender The user allowed to spend on behalf of _msgSender()\r\n   * @param subtractedValue The amount being subtracted to the allowance\r\n   * @return `true`\r\n   **/\r\n  function decreaseAllowance(address spender, uint256 subtractedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    _approve(\r\n      _msgSender(),\r\n      spender,\r\n      _allowances[_msgSender()][spender].sub(\r\n        subtractedValue,\r\n        'ERC20: decreased allowance below zero'\r\n      )\r\n    );\r\n    return true;\r\n  }\r\n\r\n  function _transfer(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(sender != address(0), 'ERC20: transfer from the zero address');\r\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\r\n\r\n    _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n    uint256 oldSenderBalance = _balances[sender];\r\n    _balances[sender] = oldSenderBalance.sub(amount, 'ERC20: transfer amount exceeds balance');\r\n    uint256 oldRecipientBalance = _balances[recipient];\r\n    _balances[recipient] = _balances[recipient].add(amount);\r\n\r\n    if (address(_getIncentivesController()) != address(0)) {\r\n      uint256 currentTotalSupply = _totalSupply;\r\n      _getIncentivesController().handleAction(sender, currentTotalSupply, oldSenderBalance);\r\n      if (sender != recipient) {\r\n        _getIncentivesController().handleAction(recipient, currentTotalSupply, oldRecipientBalance);\r\n      }\r\n    }\r\n  }\r\n\r\n  function _mint(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), 'ERC20: mint to the zero address');\r\n\r\n    _beforeTokenTransfer(address(0), account, amount);\r\n\r\n    uint256 oldTotalSupply = _totalSupply;\r\n    _totalSupply = oldTotalSupply.add(amount);\r\n\r\n    uint256 oldAccountBalance = _balances[account];\r\n    _balances[account] = oldAccountBalance.add(amount);\r\n\r\n    if (address(_getIncentivesController()) != address(0)) {\r\n      _getIncentivesController().handleAction(account, oldTotalSupply, oldAccountBalance);\r\n    }\r\n  }\r\n\r\n  function _burn(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), 'ERC20: burn from the zero address');\r\n\r\n    _beforeTokenTransfer(account, address(0), amount);\r\n\r\n    uint256 oldTotalSupply = _totalSupply;\r\n    _totalSupply = oldTotalSupply.sub(amount);\r\n\r\n    uint256 oldAccountBalance = _balances[account];\r\n    _balances[account] = oldAccountBalance.sub(amount, 'ERC20: burn amount exceeds balance');\r\n\r\n    if (address(_getIncentivesController()) != address(0)) {\r\n      _getIncentivesController().handleAction(account, oldTotalSupply, oldAccountBalance);\r\n    }\r\n  }\r\n\r\n  function _approve(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(owner != address(0), 'ERC20: approve from the zero address');\r\n    require(spender != address(0), 'ERC20: approve to the zero address');\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  function _setName(string memory newName) internal {\r\n    _name = newName;\r\n  }\r\n\r\n  function _setSymbol(string memory newSymbol) internal {\r\n    _symbol = newSymbol;\r\n  }\r\n\r\n  function _setDecimals(uint8 newDecimals) internal {\r\n    _decimals = newDecimals;\r\n  }\r\n\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {}\r\n}\r\n"
      },
      "contracts/mocks/upgradeability/MockVariableDebtToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {VariableDebtToken} from '../../protocol/tokenization/VariableDebtToken.sol';\r\n\r\ncontract MockVariableDebtToken is VariableDebtToken {\r\n  function getRevision() internal pure override returns (uint256) {\r\n    return 0x2;\r\n  }\r\n}\r\n"
      },
      "contracts/mocks/upgradeability/MockAToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {AToken} from '../../protocol/tokenization/AToken.sol';\r\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\r\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\r\n\r\ncontract MockAToken is AToken {\r\n  function getRevision() internal pure override returns (uint256) {\r\n    return 0x2;\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/tokenization/AToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol';\r\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\r\nimport {IAToken} from '../../interfaces/IAToken.sol';\r\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\r\nimport {Errors} from '../libraries/helpers/Errors.sol';\r\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\r\nimport {IncentivizedERC20} from './IncentivizedERC20.sol';\r\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\r\n\r\n/**\r\n * @title Aave ERC20 AToken\r\n * @dev Implementation of the interest bearing token for the Aave protocol\r\n * @author Aave\r\n */\r\ncontract AToken is\r\n  VersionedInitializable,\r\n  IncentivizedERC20('ATOKEN_IMPL', 'ATOKEN_IMPL', 0),\r\n  IAToken\r\n{\r\n  using WadRayMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  bytes public constant EIP712_REVISION = bytes('1');\r\n  bytes32 internal constant EIP712_DOMAIN =\r\n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\r\n  bytes32 public constant PERMIT_TYPEHASH =\r\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\r\n\r\n  uint256 public constant ATOKEN_REVISION = 0x1;\r\n\r\n  /// @dev owner => next valid nonce to submit with permit()\r\n  mapping(address => uint256) public _nonces;\r\n\r\n  bytes32 public DOMAIN_SEPARATOR;\r\n\r\n  ILendingPool internal _pool;\r\n  address internal _treasury;\r\n  address internal _underlyingAsset;\r\n  IAaveIncentivesController internal _incentivesController;\r\n\r\n  modifier onlyLendingPool {\r\n    require(_msgSender() == address(_pool), Errors.CT_CALLER_MUST_BE_LENDING_POOL);\r\n    _;\r\n  }\r\n\r\n  function getRevision() internal pure virtual override returns (uint256) {\r\n    return ATOKEN_REVISION;\r\n  }\r\n\r\n  /**\r\n   * @dev Initializes the aToken\r\n   * @param pool The address of the lending pool where this aToken will be used\r\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\r\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   * @param incentivesController The smart contract managing potential incentives distribution\r\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\r\n   * @param aTokenName The name of the aToken\r\n   * @param aTokenSymbol The symbol of the aToken\r\n   */\r\n  function initialize(\r\n    ILendingPool pool,\r\n    address treasury,\r\n    address underlyingAsset,\r\n    IAaveIncentivesController incentivesController,\r\n    uint8 aTokenDecimals,\r\n    string calldata aTokenName,\r\n    string calldata aTokenSymbol,\r\n    bytes calldata params\r\n  ) external override initializer {\r\n    uint256 chainId;\r\n\r\n    //solium-disable-next-line\r\n    assembly {\r\n      chainId := chainid()\r\n    }\r\n\r\n    DOMAIN_SEPARATOR = keccak256(\r\n      abi.encode(\r\n        EIP712_DOMAIN,\r\n        keccak256(bytes(aTokenName)),\r\n        keccak256(EIP712_REVISION),\r\n        chainId,\r\n        address(this)\r\n      )\r\n    );\r\n\r\n    _setName(aTokenName);\r\n    _setSymbol(aTokenSymbol);\r\n    _setDecimals(aTokenDecimals);\r\n\r\n    _pool = pool;\r\n    _treasury = treasury;\r\n    _underlyingAsset = underlyingAsset;\r\n    _incentivesController = incentivesController;\r\n\r\n    emit Initialized(\r\n      underlyingAsset,\r\n      address(pool),\r\n      treasury,\r\n      address(incentivesController),\r\n      aTokenDecimals,\r\n      aTokenName,\r\n      aTokenSymbol,\r\n      params\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\r\n   * - Only callable by the LendingPool, as extra state updates there need to be managed\r\n   * @param user The owner of the aTokens, getting them burned\r\n   * @param receiverOfUnderlying The address that will receive the underlying\r\n   * @param amount The amount being burned\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  function burn(\r\n    address user,\r\n    address receiverOfUnderlying,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external override onlyLendingPool {\r\n    uint256 amountScaled = amount.rayDiv(index);\r\n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\r\n    _burn(user, amountScaled);\r\n\r\n    IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\r\n\r\n    emit Transfer(user, address(0), amount);\r\n    emit Burn(user, receiverOfUnderlying, amount, index);\r\n  }\r\n\r\n  /**\r\n   * @dev Mints `amount` aTokens to `user`\r\n   * - Only callable by the LendingPool, as extra state updates there need to be managed\r\n   * @param user The address receiving the minted tokens\r\n   * @param amount The amount of tokens getting minted\r\n   * @param index The new liquidity index of the reserve\r\n   * @return `true` if the the previous balance of the user was 0\r\n   */\r\n  function mint(\r\n    address user,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external override onlyLendingPool returns (bool) {\r\n    uint256 previousBalance = super.balanceOf(user);\r\n\r\n    uint256 amountScaled = amount.rayDiv(index);\r\n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\r\n    _mint(user, amountScaled);\r\n\r\n    emit Transfer(address(0), user, amount);\r\n    emit Mint(user, amount, index);\r\n\r\n    return previousBalance == 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Mints aTokens to the reserve treasury\r\n   * - Only callable by the LendingPool\r\n   * @param amount The amount of tokens getting minted\r\n   * @param index The new liquidity index of the reserve\r\n   */\r\n  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendingPool {\r\n    if (amount == 0) {\r\n      return;\r\n    }\r\n\r\n    address treasury = _treasury;\r\n\r\n    // Compared to the normal mint, we don't check for rounding errors.\r\n    // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\r\n    // In that case, the treasury will experience a (very small) loss, but it\r\n    // wont cause potentially valid transactions to fail.\r\n    _mint(treasury, amount.rayDiv(index));\r\n\r\n    emit Transfer(address(0), treasury, amount);\r\n    emit Mint(treasury, amount, index);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\r\n   * - Only callable by the LendingPool\r\n   * @param from The address getting liquidated, current owner of the aTokens\r\n   * @param to The recipient\r\n   * @param value The amount of tokens getting transferred\r\n   **/\r\n  function transferOnLiquidation(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external override onlyLendingPool {\r\n    // Being a normal transfer, the Transfer() and BalanceTransfer() are emitted\r\n    // so no need to emit a specific event here\r\n    _transfer(from, to, value, false);\r\n\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\r\n   * @param user The user whose balance is calculated\r\n   * @return The balance of the user\r\n   **/\r\n  function balanceOf(address user)\r\n    public\r\n    view\r\n    override(IncentivizedERC20, IERC20)\r\n    returns (uint256)\r\n  {\r\n    return super.balanceOf(user).rayMul(_pool.getReserveNormalizedIncome(_underlyingAsset));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\r\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\r\n   * @param user The user whose balance is calculated\r\n   * @return The scaled balance of the user\r\n   **/\r\n  function scaledBalanceOf(address user) external view override returns (uint256) {\r\n    return super.balanceOf(user);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the scaled balance of the user and the scaled total supply.\r\n   * @param user The address of the user\r\n   * @return The scaled balance of the user\r\n   * @return The scaled balance and the scaled total supply\r\n   **/\r\n  function getScaledUserBalanceAndSupply(address user)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256, uint256)\r\n  {\r\n    return (super.balanceOf(user), super.totalSupply());\r\n  }\r\n\r\n  /**\r\n   * @dev calculates the total supply of the specific aToken\r\n   * since the balance of every single user increases over time, the total supply\r\n   * does that too.\r\n   * @return the current total supply\r\n   **/\r\n  function totalSupply() public view override(IncentivizedERC20, IERC20) returns (uint256) {\r\n    uint256 currentSupplyScaled = super.totalSupply();\r\n\r\n    if (currentSupplyScaled == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return currentSupplyScaled.rayMul(_pool.getReserveNormalizedIncome(_underlyingAsset));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\r\n   * @return the scaled total supply\r\n   **/\r\n  function scaledTotalSupply() public view virtual override returns (uint256) {\r\n    return super.totalSupply();\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the Aave treasury, receiving the fees on this aToken\r\n   **/\r\n  function RESERVE_TREASURY_ADDRESS() public view returns (address) {\r\n    return _treasury;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   **/\r\n  function UNDERLYING_ASSET_ADDRESS() public view returns (address) {\r\n    return _underlyingAsset;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the lending pool where this aToken is used\r\n   **/\r\n  function POOL() public view returns (ILendingPool) {\r\n    return _pool;\r\n  }\r\n\r\n  /**\r\n   * @dev For internal usage in the logic of the parent contract IncentivizedERC20\r\n   **/\r\n  function _getIncentivesController() internal view override returns (IAaveIncentivesController) {\r\n    return _incentivesController;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view override returns (IAaveIncentivesController) {\r\n    return _getIncentivesController();\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\r\n   * assets in borrow(), withdraw() and flashLoan()\r\n   * @param target The recipient of the aTokens\r\n   * @param amount The amount getting transferred\r\n   * @return The amount transferred\r\n   **/\r\n  function transferUnderlyingTo(address target, uint256 amount)\r\n    external\r\n    override\r\n    onlyLendingPool\r\n    returns (uint256)\r\n  {\r\n    IERC20(_underlyingAsset).safeTransfer(target, amount);\r\n    return amount;\r\n  }\r\n\r\n  /**\r\n   * @dev Invoked to execute actions on the aToken side after a repayment.\r\n   * @param user The user executing the repayment\r\n   * @param amount The amount getting repaid\r\n   **/\r\n  function handleRepayment(address user, uint256 amount) external override onlyLendingPool {}\r\n\r\n  /**\r\n   * @dev implements the permit function as for\r\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\r\n   * @param owner The owner of the funds\r\n   * @param spender The spender\r\n   * @param value The amount\r\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\r\n   * @param v Signature param\r\n   * @param s Signature param\r\n   * @param r Signature param\r\n   */\r\n  function permit(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external {\r\n    require(owner != address(0), 'INVALID_OWNER');\r\n    //solium-disable-next-line\r\n    require(block.timestamp <= deadline, 'INVALID_EXPIRATION');\r\n    uint256 currentValidNonce = _nonces[owner];\r\n    bytes32 digest =\r\n      keccak256(\r\n        abi.encodePacked(\r\n          '\\x19\\x01',\r\n          DOMAIN_SEPARATOR,\r\n          keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\r\n        )\r\n      );\r\n    require(owner == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE');\r\n    _nonces[owner] = currentValidNonce.add(1);\r\n    _approve(owner, spender, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the aTokens between two users. Validates the transfer\r\n   * (ie checks for valid HF after the transfer) if required\r\n   * @param from The source address\r\n   * @param to The destination address\r\n   * @param amount The amount getting transferred\r\n   * @param validate `true` if the transfer needs to be validated\r\n   **/\r\n  function _transfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    bool validate\r\n  ) internal {\r\n    address underlyingAsset = _underlyingAsset;\r\n    ILendingPool pool = _pool;\r\n\r\n    uint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\r\n\r\n    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\r\n    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\r\n\r\n    super._transfer(from, to, amount.rayDiv(index));\r\n\r\n    if (validate) {\r\n      pool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\r\n    }\r\n\r\n    emit BalanceTransfer(from, to, amount, index);\r\n  }\r\n\r\n  /**\r\n   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\r\n   * @param from The source address\r\n   * @param to The destination address\r\n   * @param amount The amount getting transferred\r\n   **/\r\n  function _transfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal override {\r\n    _transfer(from, to, amount, true);\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/tokenization/DelegationAwareAToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\r\nimport {IDelegationToken} from '../../interfaces/IDelegationToken.sol';\r\nimport {Errors} from '../libraries/helpers/Errors.sol';\r\nimport {AToken} from './AToken.sol';\r\n\r\n/**\r\n * @title Aave AToken enabled to delegate voting power of the underlying asset to a different address\r\n * @dev The underlying asset needs to be compatible with the COMP delegation interface\r\n * @author Aave\r\n */\r\ncontract DelegationAwareAToken is AToken {\r\n  modifier onlyPoolAdmin {\r\n    require(\r\n      _msgSender() == ILendingPool(_pool).getAddressesProvider().getPoolAdmin(),\r\n      Errors.CALLER_NOT_POOL_ADMIN\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Delegates voting power of the underlying asset to a `delegatee` address\r\n   * @param delegatee The address that will receive the delegation\r\n   **/\r\n  function delegateUnderlyingTo(address delegatee) external onlyPoolAdmin {\r\n    IDelegationToken(_underlyingAsset).delegate(delegatee);\r\n  }\r\n}\r\n"
      },
      "contracts/interfaces/IDelegationToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title IDelegationToken\r\n * @dev Implements an interface for tokens with delegation COMP/UNI compatible\r\n * @author Aave\r\n **/\r\ninterface IDelegationToken {\r\n  function delegate(address delegatee) external;\r\n}\r\n"
      },
      "contracts/protocol/configuration/LendingPoolAddressesProviderRegistry.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\r\nimport {\r\n  ILendingPoolAddressesProviderRegistry\r\n} from '../../interfaces/ILendingPoolAddressesProviderRegistry.sol';\r\nimport {Errors} from '../libraries/helpers/Errors.sol';\r\n\r\n/**\r\n * @title LendingPoolAddressesProviderRegistry contract\r\n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets\r\n * - Used for indexing purposes of Aave protocol's markets\r\n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with,\r\n *   for example with `0` for the Aave main market and `1` for the next created\r\n * @author Aave\r\n **/\r\ncontract LendingPoolAddressesProviderRegistry is Ownable, ILendingPoolAddressesProviderRegistry {\r\n  mapping(address => uint256) private _addressesProviders;\r\n  address[] private _addressesProvidersList;\r\n\r\n  /**\r\n   * @dev Returns the list of registered addresses provider\r\n   * @return The list of addresses provider, potentially containing address(0) elements\r\n   **/\r\n  function getAddressesProvidersList() external view override returns (address[] memory) {\r\n    address[] memory addressesProvidersList = _addressesProvidersList;\r\n\r\n    uint256 maxLength = addressesProvidersList.length;\r\n\r\n    address[] memory activeProviders = new address[](maxLength);\r\n\r\n    for (uint256 i = 0; i < maxLength; i++) {\r\n      if (_addressesProviders[addressesProvidersList[i]] > 0) {\r\n        activeProviders[i] = addressesProvidersList[i];\r\n      }\r\n    }\r\n\r\n    return activeProviders;\r\n  }\r\n\r\n  /**\r\n   * @dev Registers an addresses provider\r\n   * @param provider The address of the new LendingPoolAddressesProvider\r\n   * @param id The id for the new LendingPoolAddressesProvider, referring to the market it belongs to\r\n   **/\r\n  function registerAddressesProvider(address provider, uint256 id) external override onlyOwner {\r\n    require(id != 0, Errors.LPAPR_INVALID_ADDRESSES_PROVIDER_ID);\r\n\r\n    _addressesProviders[provider] = id;\r\n    _addToAddressesProvidersList(provider);\r\n    emit AddressesProviderRegistered(provider);\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a LendingPoolAddressesProvider from the list of registered addresses provider\r\n   * @param provider The LendingPoolAddressesProvider address\r\n   **/\r\n  function unregisterAddressesProvider(address provider) external override onlyOwner {\r\n    require(_addressesProviders[provider] > 0, Errors.LPAPR_PROVIDER_NOT_REGISTERED);\r\n    _addressesProviders[provider] = 0;\r\n    emit AddressesProviderUnregistered(provider);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the id on a registered LendingPoolAddressesProvider\r\n   * @return The id or 0 if the LendingPoolAddressesProvider is not registered\r\n   */\r\n  function getAddressesProviderIdByAddress(address addressesProvider)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _addressesProviders[addressesProvider];\r\n  }\r\n\r\n  function _addToAddressesProvidersList(address provider) internal {\r\n    uint256 providersCount = _addressesProvidersList.length;\r\n\r\n    for (uint256 i = 0; i < providersCount; i++) {\r\n      if (_addressesProvidersList[i] == provider) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    _addressesProvidersList.push(provider);\r\n  }\r\n}\r\n"
      },
      "contracts/interfaces/ILendingPoolAddressesProviderRegistry.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title LendingPoolAddressesProviderRegistry contract\r\n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets\r\n * - Used for indexing purposes of Aave protocol's markets\r\n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with,\r\n *   for example with `0` for the Aave main market and `1` for the next created\r\n * @author Aave\r\n **/\r\ninterface ILendingPoolAddressesProviderRegistry {\r\n  event AddressesProviderRegistered(address indexed newAddress);\r\n  event AddressesProviderUnregistered(address indexed newAddress);\r\n\r\n  function getAddressesProvidersList() external view returns (address[] memory);\r\n\r\n  function getAddressesProviderIdByAddress(address addressesProvider)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function registerAddressesProvider(address provider, uint256 id) external;\r\n\r\n  function unregisterAddressesProvider(address provider) external;\r\n}\r\n"
      },
      "contracts/misc/AaveOracle.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol';\r\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\r\n\r\nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol';\r\nimport {IChainlinkAggregator} from '../interfaces/IChainlinkAggregator.sol';\r\nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol';\r\n\r\n/// @title AaveOracle\r\n/// @author Aave\r\n/// @notice Proxy smart contract to get the price of an asset from a price source, with Chainlink Aggregator\r\n///         smart contracts as primary option\r\n/// - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallbackOracle\r\n/// - Owned by the Aave governance system, allowed to add sources for assets, replace them\r\n///   and change the fallbackOracle\r\ncontract AaveOracle is IPriceOracleGetter, Ownable {\r\n  using SafeERC20 for IERC20;\r\n\r\n  event WethSet(address indexed weth);\r\n  event AssetSourceUpdated(address indexed asset, address indexed source);\r\n  event FallbackOracleUpdated(address indexed fallbackOracle);\r\n\r\n  mapping(address => IChainlinkAggregator) private assetsSources;\r\n  IPriceOracleGetter private _fallbackOracle;\r\n  address public immutable WETH;\r\n\r\n  /// @notice Constructor\r\n  /// @param assets The addresses of the assets\r\n  /// @param sources The address of the source of each asset\r\n  /// @param fallbackOracle The address of the fallback oracle to use if the data of an\r\n  ///        aggregator is not consistent\r\n  constructor(\r\n    address[] memory assets,\r\n    address[] memory sources,\r\n    address fallbackOracle,\r\n    address weth\r\n  ) public {\r\n    _setFallbackOracle(fallbackOracle);\r\n    _setAssetsSources(assets, sources);\r\n    WETH = weth;\r\n    emit WethSet(weth);\r\n  }\r\n\r\n  /// @notice External function called by the Aave governance to set or replace sources of assets\r\n  /// @param assets The addresses of the assets\r\n  /// @param sources The address of the source of each asset\r\n  function setAssetSources(address[] calldata assets, address[] calldata sources)\r\n    external\r\n    onlyOwner\r\n  {\r\n    _setAssetsSources(assets, sources);\r\n  }\r\n\r\n  /// @notice Sets the fallbackOracle\r\n  /// - Callable only by the Aave governance\r\n  /// @param fallbackOracle The address of the fallbackOracle\r\n  function setFallbackOracle(address fallbackOracle) external onlyOwner {\r\n    _setFallbackOracle(fallbackOracle);\r\n  }\r\n\r\n  /// @notice Internal function to set the sources for each asset\r\n  /// @param assets The addresses of the assets\r\n  /// @param sources The address of the source of each asset\r\n  function _setAssetsSources(address[] memory assets, address[] memory sources) internal {\r\n    require(assets.length == sources.length, 'INCONSISTENT_PARAMS_LENGTH');\r\n    for (uint256 i = 0; i < assets.length; i++) {\r\n      assetsSources[assets[i]] = IChainlinkAggregator(sources[i]);\r\n      emit AssetSourceUpdated(assets[i], sources[i]);\r\n    }\r\n  }\r\n\r\n  /// @notice Internal function to set the fallbackOracle\r\n  /// @param fallbackOracle The address of the fallbackOracle\r\n  function _setFallbackOracle(address fallbackOracle) internal {\r\n    _fallbackOracle = IPriceOracleGetter(fallbackOracle);\r\n    emit FallbackOracleUpdated(fallbackOracle);\r\n  }\r\n\r\n  /// @notice Gets an asset price by address\r\n  /// @param asset The asset address\r\n  function getAssetPrice(address asset) public view override returns (uint256) {\r\n    IChainlinkAggregator source = assetsSources[asset];\r\n\r\n    if (asset == WETH) {\r\n      return 1 ether;\r\n    } else if (address(source) == address(0)) {\r\n      return _fallbackOracle.getAssetPrice(asset);\r\n    } else {\r\n      int256 price = IChainlinkAggregator(source).latestAnswer();\r\n      if (price > 0) {\r\n        return uint256(price);\r\n      } else {\r\n        return _fallbackOracle.getAssetPrice(asset);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Gets a list of prices from a list of assets addresses\r\n  /// @param assets The list of assets addresses\r\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory) {\r\n    uint256[] memory prices = new uint256[](assets.length);\r\n    for (uint256 i = 0; i < assets.length; i++) {\r\n      prices[i] = getAssetPrice(assets[i]);\r\n    }\r\n    return prices;\r\n  }\r\n\r\n  /// @notice Gets the address of the source for an asset address\r\n  /// @param asset The address of the asset\r\n  /// @return address The address of the source\r\n  function getSourceOfAsset(address asset) external view returns (address) {\r\n    return address(assetsSources[asset]);\r\n  }\r\n\r\n  /// @notice Gets the address of the fallback oracle\r\n  /// @return address The addres of the fallback oracle\r\n  function getFallbackOracle() external view returns (address) {\r\n    return address(_fallbackOracle);\r\n  }\r\n}\r\n"
      },
      "contracts/interfaces/IChainlinkAggregator.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\ninterface IChainlinkAggregator {\r\n  function latestAnswer() external view returns (int256);\r\n\r\n  function latestTimestamp() external view returns (uint256);\r\n\r\n  function latestRound() external view returns (uint256);\r\n\r\n  function getAnswer(uint256 roundId) external view returns (int256);\r\n\r\n  function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\r\n  event NewRound(uint256 indexed roundId, address indexed startedBy);\r\n}\r\n"
      },
      "contracts/protocol/lendingpool/LendingPoolConfigurator.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\r\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\r\nimport {\r\n  InitializableImmutableAdminUpgradeabilityProxy\r\n} from '../libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol';\r\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\r\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\r\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\r\nimport {Errors} from '../libraries/helpers/Errors.sol';\r\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\r\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\r\nimport {IInitializableDebtToken} from '../../interfaces/IInitializableDebtToken.sol';\r\nimport {IInitializableAToken} from '../../interfaces/IInitializableAToken.sol';\r\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\r\nimport {ILendingPoolConfigurator} from '../../interfaces/ILendingPoolConfigurator.sol';\r\n\r\n/**\r\n * @title LendingPoolConfigurator contract\r\n * @author Aave\r\n * @dev Implements the configuration methods for the Aave protocol\r\n **/\r\n\r\ncontract LendingPoolConfigurator is VersionedInitializable, ILendingPoolConfigurator {\r\n  using SafeMath for uint256;\r\n  using PercentageMath for uint256;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n\r\n  ILendingPoolAddressesProvider internal addressesProvider;\r\n  ILendingPool internal pool;\r\n\r\n  modifier onlyPoolAdmin {\r\n    require(addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\r\n    _;\r\n  }\r\n\r\n  modifier onlyEmergencyAdmin {\r\n    require(\r\n      addressesProvider.getEmergencyAdmin() == msg.sender,\r\n      Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN\r\n    );\r\n    _;\r\n  }\r\n\r\n  uint256 internal constant CONFIGURATOR_REVISION = 0x1;\r\n\r\n  function getRevision() internal pure override returns (uint256) {\r\n    return CONFIGURATOR_REVISION;\r\n  }\r\n\r\n  function initialize(ILendingPoolAddressesProvider provider) public initializer {\r\n    addressesProvider = provider;\r\n    pool = ILendingPool(addressesProvider.getLendingPool());\r\n  }\r\n\r\n  /**\r\n   * @dev Initializes reserves in batch\r\n   **/\r\n  function batchInitReserve(InitReserveInput[] calldata input) external onlyPoolAdmin {\r\n    ILendingPool cachedPool = pool;\r\n    for (uint256 i = 0; i < input.length; i++) {\r\n      _initReserve(cachedPool, input[i]);\r\n    }\r\n  }\r\n\r\n  function _initReserve(ILendingPool pool, InitReserveInput calldata input) internal {\r\n    address aTokenProxyAddress =\r\n      _initTokenWithProxy(\r\n        input.aTokenImpl,\r\n        abi.encodeWithSelector(\r\n          IInitializableAToken.initialize.selector,\r\n          pool,\r\n          input.treasury,\r\n          input.underlyingAsset,\r\n          IAaveIncentivesController(input.incentivesController),\r\n          input.underlyingAssetDecimals,\r\n          input.aTokenName,\r\n          input.aTokenSymbol,\r\n          input.params\r\n        )\r\n      );\r\n\r\n    address stableDebtTokenProxyAddress =\r\n      _initTokenWithProxy(\r\n        input.stableDebtTokenImpl,\r\n        abi.encodeWithSelector(\r\n          IInitializableDebtToken.initialize.selector,\r\n          pool,\r\n          input.underlyingAsset,\r\n          IAaveIncentivesController(input.incentivesController),\r\n          input.underlyingAssetDecimals,\r\n          input.stableDebtTokenName,\r\n          input.stableDebtTokenSymbol,\r\n          input.params\r\n        )\r\n      );\r\n\r\n    address variableDebtTokenProxyAddress =\r\n      _initTokenWithProxy(\r\n        input.variableDebtTokenImpl,\r\n        abi.encodeWithSelector(\r\n          IInitializableDebtToken.initialize.selector,\r\n          pool,\r\n          input.underlyingAsset,\r\n          IAaveIncentivesController(input.incentivesController),\r\n          input.underlyingAssetDecimals,\r\n          input.variableDebtTokenName,\r\n          input.variableDebtTokenSymbol,\r\n          input.params\r\n        )\r\n      );\r\n\r\n    pool.initReserve(\r\n      input.underlyingAsset,\r\n      aTokenProxyAddress,\r\n      stableDebtTokenProxyAddress,\r\n      variableDebtTokenProxyAddress,\r\n      input.interestRateStrategyAddress\r\n    );\r\n\r\n    DataTypes.ReserveConfigurationMap memory currentConfig =\r\n      pool.getConfiguration(input.underlyingAsset);\r\n\r\n    currentConfig.setDecimals(input.underlyingAssetDecimals);\r\n\r\n    currentConfig.setActive(true);\r\n    currentConfig.setFrozen(false);\r\n\r\n    pool.setConfiguration(input.underlyingAsset, currentConfig.data);\r\n\r\n    emit ReserveInitialized(\r\n      input.underlyingAsset,\r\n      aTokenProxyAddress,\r\n      stableDebtTokenProxyAddress,\r\n      variableDebtTokenProxyAddress,\r\n      input.interestRateStrategyAddress\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the aToken implementation for the reserve\r\n   **/\r\n  function updateAToken(UpdateATokenInput calldata input) external onlyPoolAdmin {\r\n    ILendingPool cachedPool = pool;\r\n\r\n    DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\r\n\r\n    (, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\r\n\r\n    bytes memory encodedCall = abi.encodeWithSelector(\r\n        IInitializableAToken.initialize.selector,\r\n        cachedPool,\r\n        input.treasury,\r\n        input.asset,\r\n        input.incentivesController,\r\n        decimals,\r\n        input.name,\r\n        input.symbol,\r\n        input.params\r\n      );\r\n\r\n    _upgradeTokenImplementation(\r\n      reserveData.aTokenAddress,\r\n      input.implementation,\r\n      encodedCall\r\n    );\r\n\r\n    emit ATokenUpgraded(input.asset, reserveData.aTokenAddress, input.implementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the stable debt token implementation for the reserve\r\n   **/\r\n  function updateStableDebtToken(UpdateDebtTokenInput calldata input) external onlyPoolAdmin {\r\n    ILendingPool cachedPool = pool;\r\n\r\n    DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\r\n     \r\n    (, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\r\n\r\n    bytes memory encodedCall = abi.encodeWithSelector(\r\n        IInitializableDebtToken.initialize.selector,\r\n        cachedPool,\r\n        input.asset,\r\n        input.incentivesController,\r\n        decimals,\r\n        input.name,\r\n        input.symbol,\r\n        input.params\r\n      );\r\n\r\n    _upgradeTokenImplementation(\r\n      reserveData.stableDebtTokenAddress,\r\n      input.implementation,\r\n      encodedCall\r\n    );\r\n\r\n    emit StableDebtTokenUpgraded(\r\n      input.asset,\r\n      reserveData.stableDebtTokenAddress,\r\n      input.implementation\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the variable debt token implementation for the asset\r\n   **/\r\n  function updateVariableDebtToken(UpdateDebtTokenInput calldata input)\r\n    external\r\n    onlyPoolAdmin\r\n  {\r\n    ILendingPool cachedPool = pool;\r\n\r\n    DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\r\n\r\n    (, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\r\n\r\n    bytes memory encodedCall = abi.encodeWithSelector(\r\n        IInitializableDebtToken.initialize.selector,\r\n        cachedPool,\r\n        input.asset,\r\n        input.incentivesController,\r\n        decimals,\r\n        input.name,\r\n        input.symbol,\r\n        input.params\r\n      );\r\n\r\n    _upgradeTokenImplementation(\r\n      reserveData.variableDebtTokenAddress,\r\n      input.implementation,\r\n      encodedCall\r\n    );\r\n\r\n    emit VariableDebtTokenUpgraded(\r\n      input.asset,\r\n      reserveData.variableDebtTokenAddress,\r\n      input.implementation\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Enables borrowing on a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param stableBorrowRateEnabled True if stable borrow rate needs to be enabled by default on this reserve\r\n   **/\r\n  function enableBorrowingOnReserve(address asset, bool stableBorrowRateEnabled)\r\n    external\r\n    onlyPoolAdmin\r\n  {\r\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\r\n\r\n    currentConfig.setBorrowingEnabled(true);\r\n    currentConfig.setStableRateBorrowingEnabled(stableBorrowRateEnabled);\r\n\r\n    pool.setConfiguration(asset, currentConfig.data);\r\n\r\n    emit BorrowingEnabledOnReserve(asset, stableBorrowRateEnabled);\r\n  }\r\n\r\n  /**\r\n   * @dev Disables borrowing on a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  function disableBorrowingOnReserve(address asset) external onlyPoolAdmin {\r\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\r\n\r\n    currentConfig.setBorrowingEnabled(false);\r\n\r\n    pool.setConfiguration(asset, currentConfig.data);\r\n    emit BorrowingDisabledOnReserve(asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Configures the reserve collateralization parameters\r\n   * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param ltv The loan to value of the asset when used as collateral\r\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\r\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset. The values is always above 100%. A value of 105%\r\n   * means the liquidator will receive a 5% bonus\r\n   **/\r\n  function configureReserveAsCollateral(\r\n    address asset,\r\n    uint256 ltv,\r\n    uint256 liquidationThreshold,\r\n    uint256 liquidationBonus\r\n  ) external onlyPoolAdmin {\r\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\r\n\r\n    //validation of the parameters: the LTV can\r\n    //only be lower or equal than the liquidation threshold\r\n    //(otherwise a loan against the asset would cause instantaneous liquidation)\r\n    require(ltv <= liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\r\n\r\n    if (liquidationThreshold != 0) {\r\n      //liquidation bonus must be bigger than 100.00%, otherwise the liquidator would receive less\r\n      //collateral than needed to cover the debt\r\n      require(\r\n        liquidationBonus > PercentageMath.PERCENTAGE_FACTOR,\r\n        Errors.LPC_INVALID_CONFIGURATION\r\n      );\r\n\r\n      //if threshold * bonus is less than PERCENTAGE_FACTOR, it's guaranteed that at the moment\r\n      //a loan is taken there is enough collateral available to cover the liquidation bonus\r\n      require(\r\n        liquidationThreshold.percentMul(liquidationBonus) <= PercentageMath.PERCENTAGE_FACTOR,\r\n        Errors.LPC_INVALID_CONFIGURATION\r\n      );\r\n    } else {\r\n      require(liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\r\n      //if the liquidation threshold is being set to 0,\r\n      // the reserve is being disabled as collateral. To do so,\r\n      //we need to ensure no liquidity is deposited\r\n      _checkNoLiquidity(asset);\r\n    }\r\n\r\n    currentConfig.setLtv(ltv);\r\n    currentConfig.setLiquidationThreshold(liquidationThreshold);\r\n    currentConfig.setLiquidationBonus(liquidationBonus);\r\n\r\n    pool.setConfiguration(asset, currentConfig.data);\r\n\r\n    emit CollateralConfigurationChanged(asset, ltv, liquidationThreshold, liquidationBonus);\r\n  }\r\n\r\n  /**\r\n   * @dev Enable stable rate borrowing on a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  function enableReserveStableRate(address asset) external onlyPoolAdmin {\r\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\r\n\r\n    currentConfig.setStableRateBorrowingEnabled(true);\r\n\r\n    pool.setConfiguration(asset, currentConfig.data);\r\n\r\n    emit StableRateEnabledOnReserve(asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Disable stable rate borrowing on a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  function disableReserveStableRate(address asset) external onlyPoolAdmin {\r\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\r\n\r\n    currentConfig.setStableRateBorrowingEnabled(false);\r\n\r\n    pool.setConfiguration(asset, currentConfig.data);\r\n\r\n    emit StableRateDisabledOnReserve(asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Activates a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  function activateReserve(address asset) external onlyPoolAdmin {\r\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\r\n\r\n    currentConfig.setActive(true);\r\n\r\n    pool.setConfiguration(asset, currentConfig.data);\r\n\r\n    emit ReserveActivated(asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Deactivates a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  function deactivateReserve(address asset) external onlyPoolAdmin {\r\n    _checkNoLiquidity(asset);\r\n\r\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\r\n\r\n    currentConfig.setActive(false);\r\n\r\n    pool.setConfiguration(asset, currentConfig.data);\r\n\r\n    emit ReserveDeactivated(asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Freezes a reserve. A frozen reserve doesn't allow any new deposit, borrow or rate swap\r\n   *  but allows repayments, liquidations, rate rebalances and withdrawals\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  function freezeReserve(address asset) external onlyPoolAdmin {\r\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\r\n\r\n    currentConfig.setFrozen(true);\r\n\r\n    pool.setConfiguration(asset, currentConfig.data);\r\n\r\n    emit ReserveFrozen(asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Unfreezes a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  function unfreezeReserve(address asset) external onlyPoolAdmin {\r\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\r\n\r\n    currentConfig.setFrozen(false);\r\n\r\n    pool.setConfiguration(asset, currentConfig.data);\r\n\r\n    emit ReserveUnfrozen(asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the reserve factor of a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param reserveFactor The new reserve factor of the reserve\r\n   **/\r\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\r\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\r\n\r\n    currentConfig.setReserveFactor(reserveFactor);\r\n\r\n    pool.setConfiguration(asset, currentConfig.data);\r\n\r\n    emit ReserveFactorChanged(asset, reserveFactor);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the interest rate strategy of a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param rateStrategyAddress The new address of the interest strategy contract\r\n   **/\r\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\r\n    external\r\n    onlyPoolAdmin\r\n  {\r\n    pool.setReserveInterestRateStrategyAddress(asset, rateStrategyAddress);\r\n    emit ReserveInterestRateStrategyChanged(asset, rateStrategyAddress);\r\n  }\r\n\r\n  /**\r\n   * @dev pauses or unpauses all the actions of the protocol, including aToken transfers\r\n   * @param val true if protocol needs to be paused, false otherwise\r\n   **/\r\n  function setPoolPause(bool val) external onlyEmergencyAdmin {\r\n    pool.setPause(val);\r\n  }\r\n\r\n  function _initTokenWithProxy(address implementation, bytes memory initParams)\r\n    internal\r\n    returns (address)\r\n  {\r\n    InitializableImmutableAdminUpgradeabilityProxy proxy =\r\n      new InitializableImmutableAdminUpgradeabilityProxy(address(this));\r\n\r\n    proxy.initialize(implementation, initParams);\r\n\r\n    return address(proxy);\r\n  }\r\n\r\n  function _upgradeTokenImplementation(\r\n    address proxyAddress,\r\n    address implementation,\r\n    bytes memory initParams\r\n  ) internal {\r\n    InitializableImmutableAdminUpgradeabilityProxy proxy =\r\n      InitializableImmutableAdminUpgradeabilityProxy(payable(proxyAddress));\r\n\r\n    proxy.upgradeToAndCall(implementation, initParams);\r\n  }\r\n\r\n  function _checkNoLiquidity(address asset) internal view {\r\n    DataTypes.ReserveData memory reserveData = pool.getReserveData(asset);\r\n\r\n    uint256 availableLiquidity = IERC20Detailed(asset).balanceOf(reserveData.aTokenAddress);\r\n\r\n    require(\r\n      availableLiquidity == 0 && reserveData.currentLiquidityRate == 0,\r\n      Errors.LPC_RESERVE_LIQUIDITY_NOT_0\r\n    );\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport './BaseImmutableAdminUpgradeabilityProxy.sol';\r\nimport '../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol';\r\n\r\n/**\r\n * @title InitializableAdminUpgradeabilityProxy\r\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\r\n */\r\ncontract InitializableImmutableAdminUpgradeabilityProxy is\r\n  BaseImmutableAdminUpgradeabilityProxy,\r\n  InitializableUpgradeabilityProxy\r\n{\r\n  constructor(address admin) public BaseImmutableAdminUpgradeabilityProxy(admin) {}\r\n\r\n  /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\r\n    BaseImmutableAdminUpgradeabilityProxy._willFallback();\r\n  }\r\n}\r\n"
      },
      "contracts/interfaces/ILendingPoolConfigurator.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface ILendingPoolConfigurator {\r\n  struct InitReserveInput {\r\n    address aTokenImpl;\r\n    address stableDebtTokenImpl;\r\n    address variableDebtTokenImpl;\r\n    uint8 underlyingAssetDecimals;\r\n    address interestRateStrategyAddress;\r\n    address underlyingAsset;\r\n    address treasury;\r\n    address incentivesController;\r\n    string underlyingAssetName;\r\n    string aTokenName;\r\n    string aTokenSymbol;\r\n    string variableDebtTokenName;\r\n    string variableDebtTokenSymbol;\r\n    string stableDebtTokenName;\r\n    string stableDebtTokenSymbol;\r\n    bytes params;\r\n  }\r\n\r\n  struct UpdateATokenInput {\r\n    address asset;\r\n    address treasury;\r\n    address incentivesController;\r\n    string name;\r\n    string symbol;\r\n    address implementation;\r\n    bytes params;\r\n  }\r\n\r\n  struct UpdateDebtTokenInput {\r\n    address asset;\r\n    address incentivesController;\r\n    string name;\r\n    string symbol;\r\n    address implementation;\r\n    bytes params;\r\n  }\r\n\r\n  /**\r\n   * @dev Emitted when a reserve is initialized.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param aToken The address of the associated aToken contract\r\n   * @param stableDebtToken The address of the associated stable rate debt token\r\n   * @param variableDebtToken The address of the associated variable rate debt token\r\n   * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\r\n   **/\r\n  event ReserveInitialized(\r\n    address indexed asset,\r\n    address indexed aToken,\r\n    address stableDebtToken,\r\n    address variableDebtToken,\r\n    address interestRateStrategyAddress\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when borrowing is enabled on a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param stableRateEnabled True if stable rate borrowing is enabled, false otherwise\r\n   **/\r\n  event BorrowingEnabledOnReserve(address indexed asset, bool stableRateEnabled);\r\n\r\n  /**\r\n   * @dev Emitted when borrowing is disabled on a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  event BorrowingDisabledOnReserve(address indexed asset);\r\n\r\n  /**\r\n   * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param ltv The loan to value of the asset when used as collateral\r\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\r\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\r\n   **/\r\n  event CollateralConfigurationChanged(\r\n    address indexed asset,\r\n    uint256 ltv,\r\n    uint256 liquidationThreshold,\r\n    uint256 liquidationBonus\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when stable rate borrowing is enabled on a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  event StableRateEnabledOnReserve(address indexed asset);\r\n\r\n  /**\r\n   * @dev Emitted when stable rate borrowing is disabled on a reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  event StableRateDisabledOnReserve(address indexed asset);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve is activated\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  event ReserveActivated(address indexed asset);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve is deactivated\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  event ReserveDeactivated(address indexed asset);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve is frozen\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  event ReserveFrozen(address indexed asset);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve is unfrozen\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  event ReserveUnfrozen(address indexed asset);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve factor is updated\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param factor The new reserve factor\r\n   **/\r\n  event ReserveFactorChanged(address indexed asset, uint256 factor);\r\n\r\n  /**\r\n   * @dev Emitted when the reserve decimals are updated\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param decimals The new decimals\r\n   **/\r\n  event ReserveDecimalsChanged(address indexed asset, uint256 decimals);\r\n\r\n  /**\r\n   * @dev Emitted when a reserve interest strategy contract is updated\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param strategy The new address of the interest strategy contract\r\n   **/\r\n  event ReserveInterestRateStrategyChanged(address indexed asset, address strategy);\r\n\r\n  /**\r\n   * @dev Emitted when an aToken implementation is upgraded\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param proxy The aToken proxy address\r\n   * @param implementation The new aToken implementation\r\n   **/\r\n  event ATokenUpgraded(\r\n    address indexed asset,\r\n    address indexed proxy,\r\n    address indexed implementation\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the implementation of a stable debt token is upgraded\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param proxy The stable debt token proxy address\r\n   * @param implementation The new aToken implementation\r\n   **/\r\n  event StableDebtTokenUpgraded(\r\n    address indexed asset,\r\n    address indexed proxy,\r\n    address indexed implementation\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the implementation of a variable debt token is upgraded\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param proxy The variable debt token proxy address\r\n   * @param implementation The new aToken implementation\r\n   **/\r\n  event VariableDebtTokenUpgraded(\r\n    address indexed asset,\r\n    address indexed proxy,\r\n    address indexed implementation\r\n  );\r\n}\r\n"
      },
      "contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport '../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol';\r\n\r\n/**\r\n * @title BaseImmutableAdminUpgradeabilityProxy\r\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks. The admin role is stored in an immutable, which\r\n * helps saving transactions costs\r\n * All external functions in this contract must be guarded by the\r\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n  address immutable ADMIN;\r\n\r\n  constructor(address admin) public {\r\n    ADMIN = admin;\r\n  }\r\n\r\n  modifier ifAdmin() {\r\n    if (msg.sender == ADMIN) {\r\n      _;\r\n    } else {\r\n      _fallback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return The address of the proxy admin.\r\n   */\r\n  function admin() external ifAdmin returns (address) {\r\n    return ADMIN;\r\n  }\r\n\r\n  /**\r\n   * @return The address of the implementation.\r\n   */\r\n  function implementation() external ifAdmin returns (address) {\r\n    return _implementation();\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy.\r\n   * Only the admin can call this function.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function upgradeTo(address newImplementation) external ifAdmin {\r\n    _upgradeTo(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy and call a function\r\n   * on the new implementation.\r\n   * This is useful to initialize the proxied contract.\r\n   * @param newImplementation Address of the new implementation.\r\n   * @param data Data to send as msg.data in the low level call.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   */\r\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\r\n    external\r\n    payable\r\n    ifAdmin\r\n  {\r\n    _upgradeTo(newImplementation);\r\n    (bool success, ) = newImplementation.delegatecall(data);\r\n    require(success);\r\n  }\r\n\r\n  /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n  function _willFallback() internal virtual override {\r\n    require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin');\r\n    super._willFallback();\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport './BaseUpgradeabilityProxy.sol';\r\n\r\n/**\r\n * @title InitializableUpgradeabilityProxy\r\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\r\n * implementation and init data.\r\n */\r\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n  /**\r\n   * @dev Contract initializer.\r\n   * @param _logic Address of the initial implementation.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n  function initialize(address _logic, bytes memory _data) public payable {\r\n    require(_implementation() == address(0));\r\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\r\n    _setImplementation(_logic);\r\n    if (_data.length > 0) {\r\n      (bool success, ) = _logic.delegatecall(_data);\r\n      require(success);\r\n    }\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport './Proxy.sol';\r\nimport '../contracts/Address.sol';\r\n\r\n/**\r\n * @title BaseUpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract BaseUpgradeabilityProxy is Proxy {\r\n  /**\r\n   * @dev Emitted when the implementation is upgraded.\r\n   * @param implementation Address of the new implementation.\r\n   */\r\n  event Upgraded(address indexed implementation);\r\n\r\n  /**\r\n   * @dev Storage slot with the address of the current implementation.\r\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 internal constant IMPLEMENTATION_SLOT =\r\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n  /**\r\n   * @dev Returns the current implementation.\r\n   * @return impl Address of the current implementation\r\n   */\r\n  function _implementation() internal view override returns (address impl) {\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n    //solium-disable-next-line\r\n    assembly {\r\n      impl := sload(slot)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades the proxy to a new implementation.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function _upgradeTo(address newImplementation) internal {\r\n    _setImplementation(newImplementation);\r\n    emit Upgraded(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the implementation address of the proxy.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function _setImplementation(address newImplementation) internal {\r\n    require(\r\n      Address.isContract(newImplementation),\r\n      'Cannot set a proxy implementation to a non-contract address'\r\n    );\r\n\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n    //solium-disable-next-line\r\n    assembly {\r\n      sstore(slot, newImplementation)\r\n    }\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/upgradeability/Proxy.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\nabstract contract Proxy {\r\n  /**\r\n   * @dev Fallback function.\r\n   * Implemented entirely in `_fallback`.\r\n   */\r\n  fallback() external payable {\r\n    _fallback();\r\n  }\r\n\r\n  /**\r\n   * @return The Address of the implementation.\r\n   */\r\n  function _implementation() internal view virtual returns (address);\r\n\r\n  /**\r\n   * @dev Delegates execution to an implementation contract.\r\n   * This is a low level function that doesn't return to its internal call site.\r\n   * It will return to the external caller whatever the implementation returns.\r\n   * @param implementation Address to delegate.\r\n   */\r\n  function _delegate(address implementation) internal {\r\n    //solium-disable-next-line\r\n    assembly {\r\n      // Copy msg.data. We take full control of memory in this inline assembly\r\n      // block because it will not return to Solidity code. We overwrite the\r\n      // Solidity scratch pad at memory position 0.\r\n      calldatacopy(0, 0, calldatasize())\r\n\r\n      // Call the implementation.\r\n      // out and outsize are 0 because we don't know the size yet.\r\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n      // Copy the returned data.\r\n      returndatacopy(0, 0, returndatasize())\r\n\r\n      switch result\r\n        // delegatecall returns 0 on error.\r\n        case 0 {\r\n          revert(0, returndatasize())\r\n        }\r\n        default {\r\n          return(0, returndatasize())\r\n        }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Function that is run as the first thing in the fallback function.\r\n   * Can be redefined in derived contracts to add functionality.\r\n   * Redefinitions must call super._willFallback().\r\n   */\r\n  function _willFallback() internal virtual {}\r\n\r\n  /**\r\n   * @dev fallback implementation.\r\n   * Extracted to enable manual triggering.\r\n   */\r\n  function _fallback() internal {\r\n    _willFallback();\r\n    _delegate(_implementation());\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/tokenization/StableDebtToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {DebtTokenBase} from './base/DebtTokenBase.sol';\r\nimport {MathUtils} from '../libraries/math/MathUtils.sol';\r\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\r\nimport {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol';\r\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\r\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\r\nimport {Errors} from '../libraries/helpers/Errors.sol';\r\n\r\n/**\r\n * @title StableDebtToken\r\n * @notice Implements a stable debt token to track the borrowing positions of users\r\n * at stable rate mode\r\n * @author Aave\r\n **/\r\ncontract StableDebtToken is IStableDebtToken, DebtTokenBase {\r\n  using WadRayMath for uint256;\r\n\r\n  uint256 public constant DEBT_TOKEN_REVISION = 0x1;\r\n\r\n  uint256 internal _avgStableRate;\r\n  mapping(address => uint40) internal _timestamps;\r\n  mapping(address => uint256) internal _usersStableRate;\r\n  uint40 internal _totalSupplyTimestamp;\r\n\r\n  ILendingPool internal _pool;\r\n  address internal _underlyingAsset;\r\n  IAaveIncentivesController internal _incentivesController;\r\n\r\n  /**\r\n   * @dev Initializes the debt token.\r\n   * @param pool The address of the lending pool where this aToken will be used\r\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   * @param incentivesController The smart contract managing potential incentives distribution\r\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\r\n   * @param debtTokenName The name of the token\r\n   * @param debtTokenSymbol The symbol of the token\r\n   */\r\n  function initialize(\r\n    ILendingPool pool,\r\n    address underlyingAsset,\r\n    IAaveIncentivesController incentivesController,\r\n    uint8 debtTokenDecimals,\r\n    string memory debtTokenName,\r\n    string memory debtTokenSymbol,\r\n    bytes calldata params\r\n  ) public override initializer {\r\n    _setName(debtTokenName);\r\n    _setSymbol(debtTokenSymbol);\r\n    _setDecimals(debtTokenDecimals);\r\n\r\n    _pool = pool;\r\n    _underlyingAsset = underlyingAsset;\r\n    _incentivesController = incentivesController;\r\n\r\n    emit Initialized(\r\n      underlyingAsset,\r\n      address(pool),\r\n      address(incentivesController),\r\n      debtTokenDecimals,\r\n      debtTokenName,\r\n      debtTokenSymbol,\r\n      params\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the revision of the stable debt token implementation\r\n   * @return The debt token implementation revision\r\n   **/\r\n  function getRevision() internal pure virtual override returns (uint256) {\r\n    return DEBT_TOKEN_REVISION;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the average stable rate across all the stable rate debt\r\n   * @return the average stable rate\r\n   **/\r\n  function getAverageStableRate() external view virtual override returns (uint256) {\r\n    return _avgStableRate;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the timestamp of the last user action\r\n   * @return The last update timestamp\r\n   **/\r\n  function getUserLastUpdated(address user) external view virtual override returns (uint40) {\r\n    return _timestamps[user];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the stable rate of the user\r\n   * @param user The address of the user\r\n   * @return The stable rate of user\r\n   **/\r\n  function getUserStableRate(address user) external view virtual override returns (uint256) {\r\n    return _usersStableRate[user];\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the current user debt balance\r\n   * @return The accumulated debt of the user\r\n   **/\r\n  function balanceOf(address account) public view virtual override returns (uint256) {\r\n    uint256 accountBalance = super.balanceOf(account);\r\n    uint256 stableRate = _usersStableRate[account];\r\n    if (accountBalance == 0) {\r\n      return 0;\r\n    }\r\n    uint256 cumulatedInterest =\r\n      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);\r\n    return accountBalance.rayMul(cumulatedInterest);\r\n  }\r\n\r\n  struct MintLocalVars {\r\n    uint256 previousSupply;\r\n    uint256 nextSupply;\r\n    uint256 amountInRay;\r\n    uint256 newStableRate;\r\n    uint256 currentAvgStableRate;\r\n  }\r\n\r\n  /**\r\n   * @dev Mints debt token to the `onBehalfOf` address.\r\n   * -  Only callable by the LendingPool\r\n   * - The resulting rate is the weighted average between the rate of the new debt\r\n   * and the rate of the previous debt\r\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\r\n   * of credit delegate, or same as `onBehalfOf` otherwise\r\n   * @param onBehalfOf The address receiving the debt tokens\r\n   * @param amount The amount of debt tokens to mint\r\n   * @param rate The rate of the debt being minted\r\n   **/\r\n  function mint(\r\n    address user,\r\n    address onBehalfOf,\r\n    uint256 amount,\r\n    uint256 rate\r\n  ) external override onlyLendingPool returns (bool) {\r\n    MintLocalVars memory vars;\r\n\r\n    if (user != onBehalfOf) {\r\n      _decreaseBorrowAllowance(onBehalfOf, user, amount);\r\n    }\r\n\r\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);\r\n\r\n    vars.previousSupply = totalSupply();\r\n    vars.currentAvgStableRate = _avgStableRate;\r\n    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);\r\n\r\n    vars.amountInRay = amount.wadToRay();\r\n\r\n    vars.newStableRate = _usersStableRate[onBehalfOf]\r\n      .rayMul(currentBalance.wadToRay())\r\n      .add(vars.amountInRay.rayMul(rate))\r\n      .rayDiv(currentBalance.add(amount).wadToRay());\r\n\r\n    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);\r\n    _usersStableRate[onBehalfOf] = vars.newStableRate;\r\n\r\n    //solium-disable-next-line\r\n    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);\r\n\r\n    // Calculates the updated average stable rate\r\n    vars.currentAvgStableRate = _avgStableRate = vars\r\n      .currentAvgStableRate\r\n      .rayMul(vars.previousSupply.wadToRay())\r\n      .add(rate.rayMul(vars.amountInRay))\r\n      .rayDiv(vars.nextSupply.wadToRay());\r\n\r\n    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);\r\n\r\n    emit Transfer(address(0), onBehalfOf, amount);\r\n\r\n    emit Mint(\r\n      user,\r\n      onBehalfOf,\r\n      amount,\r\n      currentBalance,\r\n      balanceIncrease,\r\n      vars.newStableRate,\r\n      vars.currentAvgStableRate,\r\n      vars.nextSupply\r\n    );\r\n\r\n    return currentBalance == 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Burns debt of `user`\r\n   * @param user The address of the user getting his debt burned\r\n   * @param amount The amount of debt tokens getting burned\r\n   **/\r\n  function burn(address user, uint256 amount) external override onlyLendingPool {\r\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);\r\n\r\n    uint256 previousSupply = totalSupply();\r\n    uint256 newAvgStableRate = 0;\r\n    uint256 nextSupply = 0;\r\n    uint256 userStableRate = _usersStableRate[user];\r\n\r\n    // Since the total supply and each single user debt accrue separately,\r\n    // there might be accumulation errors so that the last borrower repaying\r\n    // mght actually try to repay more than the available debt supply.\r\n    // In this case we simply set the total supply and the avg stable rate to 0\r\n    if (previousSupply <= amount) {\r\n      _avgStableRate = 0;\r\n      _totalSupply = 0;\r\n    } else {\r\n      nextSupply = _totalSupply = previousSupply.sub(amount);\r\n      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());\r\n      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());\r\n\r\n      // For the same reason described above, when the last user is repaying it might\r\n      // happen that user rate * user balance > avg rate * total supply. In that case,\r\n      // we simply set the avg rate to 0\r\n      if (secondTerm >= firstTerm) {\r\n        newAvgStableRate = _avgStableRate = _totalSupply = 0;\r\n      } else {\r\n        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());\r\n      }\r\n    }\r\n\r\n    if (amount == currentBalance) {\r\n      _usersStableRate[user] = 0;\r\n      _timestamps[user] = 0;\r\n    } else {\r\n      //solium-disable-next-line\r\n      _timestamps[user] = uint40(block.timestamp);\r\n    }\r\n    //solium-disable-next-line\r\n    _totalSupplyTimestamp = uint40(block.timestamp);\r\n\r\n    if (balanceIncrease > amount) {\r\n      uint256 amountToMint = balanceIncrease.sub(amount);\r\n      _mint(user, amountToMint, previousSupply);\r\n      emit Mint(\r\n        user,\r\n        user,\r\n        amountToMint,\r\n        currentBalance,\r\n        balanceIncrease,\r\n        userStableRate,\r\n        newAvgStableRate,\r\n        nextSupply\r\n      );\r\n    } else {\r\n      uint256 amountToBurn = amount.sub(balanceIncrease);\r\n      _burn(user, amountToBurn, previousSupply);\r\n      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);\r\n    }\r\n\r\n    emit Transfer(user, address(0), amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the increase in balance since the last user interaction\r\n   * @param user The address of the user for which the interest is being accumulated\r\n   * @return The previous principal balance, the new principal balance and the balance increase\r\n   **/\r\n  function _calculateBalanceIncrease(address user)\r\n    internal\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    uint256 previousPrincipalBalance = super.balanceOf(user);\r\n\r\n    if (previousPrincipalBalance == 0) {\r\n      return (0, 0, 0);\r\n    }\r\n\r\n    // Calculation of the accrued interest since the last accumulation\r\n    uint256 balanceIncrease = balanceOf(user).sub(previousPrincipalBalance);\r\n\r\n    return (\r\n      previousPrincipalBalance,\r\n      previousPrincipalBalance.add(balanceIncrease),\r\n      balanceIncrease\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the principal and total supply, the average borrow rate and the last supply update timestamp\r\n   **/\r\n  function getSupplyData()\r\n    public\r\n    view\r\n    override\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint40\r\n    )\r\n  {\r\n    uint256 avgRate = _avgStableRate;\r\n    return (super.totalSupply(), _calcTotalSupply(avgRate), avgRate, _totalSupplyTimestamp);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the the total supply and the average stable rate\r\n   **/\r\n  function getTotalSupplyAndAvgRate() public view override returns (uint256, uint256) {\r\n    uint256 avgRate = _avgStableRate;\r\n    return (_calcTotalSupply(avgRate), avgRate);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total supply\r\n   **/\r\n  function totalSupply() public view override returns (uint256) {\r\n    return _calcTotalSupply(_avgStableRate);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the timestamp at which the total supply was updated\r\n   **/\r\n  function getTotalSupplyLastUpdated() public view override returns (uint40) {\r\n    return _totalSupplyTimestamp;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the principal debt balance of the user from\r\n   * @param user The user's address\r\n   * @return The debt balance of the user since the last burn/mint action\r\n   **/\r\n  function principalBalanceOf(address user) external view virtual override returns (uint256) {\r\n    return super.balanceOf(user);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   **/\r\n  function UNDERLYING_ASSET_ADDRESS() public view returns (address) {\r\n    return _underlyingAsset;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the lending pool where this aToken is used\r\n   **/\r\n  function POOL() public view returns (ILendingPool) {\r\n    return _pool;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view override returns (IAaveIncentivesController) {\r\n    return _getIncentivesController();\r\n  }\r\n\r\n  /**\r\n   * @dev For internal usage in the logic of the parent contracts\r\n   **/\r\n  function _getIncentivesController() internal view override returns (IAaveIncentivesController) {\r\n    return _incentivesController;\r\n  }\r\n\r\n  /**\r\n   * @dev For internal usage in the logic of the parent contracts\r\n   **/\r\n  function _getUnderlyingAssetAddress() internal view override returns (address) {\r\n    return _underlyingAsset;\r\n  }\r\n\r\n  /**\r\n   * @dev For internal usage in the logic of the parent contracts\r\n   **/\r\n  function _getLendingPool() internal view override returns (ILendingPool) {\r\n    return _pool;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the total supply\r\n   * @param avgRate The average rate at which the total supply increases\r\n   * @return The debt balance of the user since the last burn/mint action\r\n   **/\r\n  function _calcTotalSupply(uint256 avgRate) internal view virtual returns (uint256) {\r\n    uint256 principalSupply = super.totalSupply();\r\n\r\n    if (principalSupply == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 cumulatedInterest =\r\n      MathUtils.calculateCompoundedInterest(avgRate, _totalSupplyTimestamp);\r\n\r\n    return principalSupply.rayMul(cumulatedInterest);\r\n  }\r\n\r\n  /**\r\n   * @dev Mints stable debt tokens to an user\r\n   * @param account The account receiving the debt tokens\r\n   * @param amount The amount being minted\r\n   * @param oldTotalSupply the total supply before the minting event\r\n   **/\r\n  function _mint(\r\n    address account,\r\n    uint256 amount,\r\n    uint256 oldTotalSupply\r\n  ) internal {\r\n    uint256 oldAccountBalance = _balances[account];\r\n    _balances[account] = oldAccountBalance.add(amount);\r\n\r\n    if (address(_incentivesController) != address(0)) {\r\n      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Burns stable debt tokens of an user\r\n   * @param account The user getting his debt burned\r\n   * @param amount The amount being burned\r\n   * @param oldTotalSupply The total supply before the burning event\r\n   **/\r\n  function _burn(\r\n    address account,\r\n    uint256 amount,\r\n    uint256 oldTotalSupply\r\n  ) internal {\r\n    uint256 oldAccountBalance = _balances[account];\r\n    _balances[account] = oldAccountBalance.sub(amount, Errors.SDT_BURN_EXCEEDS_BALANCE);\r\n\r\n    if (address(_incentivesController) != address(0)) {\r\n      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);\r\n    }\r\n  }\r\n}\r\n"
      },
      "contracts/mocks/upgradeability/MockStableDebtToken.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {StableDebtToken} from '../../protocol/tokenization/StableDebtToken.sol';\r\n\r\ncontract MockStableDebtToken is StableDebtToken {\r\n  function getRevision() internal pure override returns (uint256) {\r\n    return 0x2;\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/lendingpool/LendingPool.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\r\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol';\r\nimport {Address} from '../../dependencies/openzeppelin/contracts/Address.sol';\r\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {IAToken} from '../../interfaces/IAToken.sol';\r\nimport {IVariableDebtToken} from '../../interfaces/IVariableDebtToken.sol';\r\nimport {IFlashLoanReceiver} from '../../flashloan/interfaces/IFlashLoanReceiver.sol';\r\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\r\nimport {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol';\r\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\r\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\r\nimport {Helpers} from '../libraries/helpers/Helpers.sol';\r\nimport {Errors} from '../libraries/helpers/Errors.sol';\r\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\r\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\r\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\r\nimport {GenericLogic} from '../libraries/logic/GenericLogic.sol';\r\nimport {ValidationLogic} from '../libraries/logic/ValidationLogic.sol';\r\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\r\nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol';\r\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\r\nimport {LendingPoolStorage} from './LendingPoolStorage.sol';\r\n\r\n/**\r\n * @title LendingPool contract\r\n * @dev Main point of interaction with an Aave protocol's market\r\n * - Users can:\r\n *   # Deposit\r\n *   # Withdraw\r\n *   # Borrow\r\n *   # Repay\r\n *   # Swap their loans between variable and stable rate\r\n *   # Enable/disable their deposits as collateral rebalance stable rate borrow positions\r\n *   # Liquidate positions\r\n *   # Execute Flash Loans\r\n * - To be covered by a proxy contract, owned by the LendingPoolAddressesProvider of the specific market\r\n * - All admin functions are callable by the LendingPoolConfigurator contract defined also in the\r\n *   LendingPoolAddressesProvider\r\n * @author Aave\r\n **/\r\ncontract LendingPool is VersionedInitializable, ILendingPool, LendingPoolStorage {\r\n  using SafeMath for uint256;\r\n  using WadRayMath for uint256;\r\n  using PercentageMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  uint256 public constant LENDINGPOOL_REVISION = 0x2;\r\n\r\n  modifier whenNotPaused() {\r\n    _whenNotPaused();\r\n    _;\r\n  }\r\n\r\n  modifier onlyLendingPoolConfigurator() {\r\n    _onlyLendingPoolConfigurator();\r\n    _;\r\n  }\r\n\r\n  function _whenNotPaused() internal view {\r\n    require(!_paused, Errors.LP_IS_PAUSED);\r\n  }\r\n\r\n  function _onlyLendingPoolConfigurator() internal view {\r\n    require(\r\n      _addressesProvider.getLendingPoolConfigurator() == msg.sender,\r\n      Errors.LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR\r\n    );\r\n  }\r\n\r\n  function getRevision() internal pure override returns (uint256) {\r\n    return LENDINGPOOL_REVISION;\r\n  }\r\n\r\n  /**\r\n   * @dev Function is invoked by the proxy contract when the LendingPool contract is added to the\r\n   * LendingPoolAddressesProvider of the market.\r\n   * - Caching the address of the LendingPoolAddressesProvider in order to reduce gas consumption\r\n   *   on subsequent operations\r\n   * @param provider The address of the LendingPoolAddressesProvider\r\n   **/\r\n  function initialize(ILendingPoolAddressesProvider provider) public initializer {\r\n    _addressesProvider = provider;\r\n    _maxStableRateBorrowSizePercent = 2500;\r\n    _flashLoanPremiumTotal = 9;\r\n    _maxNumberOfReserves = 128;\r\n  }\r\n\r\n  /**\r\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n   * @param asset The address of the underlying asset to deposit\r\n   * @param amount The amount to be deposited\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function deposit(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external override whenNotPaused {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    ValidationLogic.validateDeposit(reserve, amount);\r\n\r\n    address aToken = reserve.aTokenAddress;\r\n\r\n    reserve.updateState();\r\n    reserve.updateInterestRates(asset, aToken, amount, 0);\r\n\r\n    IERC20(asset).safeTransferFrom(msg.sender, aToken, amount);\r\n\r\n    bool isFirstDeposit = IAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex);\r\n\r\n    if (isFirstDeposit) {\r\n      _usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\r\n      emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\r\n    }\r\n\r\n    emit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n   * @param asset The address of the underlying asset to withdraw\r\n   * @param amount The underlying amount to be withdrawn\r\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n   * @param to Address that will receive the underlying, same as msg.sender if the user\r\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n   *   different wallet\r\n   * @return The final amount withdrawn\r\n   **/\r\n  function withdraw(\r\n    address asset,\r\n    uint256 amount,\r\n    address to\r\n  ) external override whenNotPaused returns (uint256) {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    address aToken = reserve.aTokenAddress;\r\n\r\n    uint256 userBalance = IAToken(aToken).balanceOf(msg.sender);\r\n\r\n    uint256 amountToWithdraw = amount;\r\n\r\n    if (amount == type(uint256).max) {\r\n      amountToWithdraw = userBalance;\r\n    }\r\n\r\n    ValidationLogic.validateWithdraw(\r\n      asset,\r\n      amountToWithdraw,\r\n      userBalance,\r\n      _reserves,\r\n      _usersConfig[msg.sender],\r\n      _reservesList,\r\n      _reservesCount,\r\n      _addressesProvider.getPriceOracle()\r\n    );\r\n\r\n    reserve.updateState();\r\n\r\n    reserve.updateInterestRates(asset, aToken, 0, amountToWithdraw);\r\n\r\n    if (amountToWithdraw == userBalance) {\r\n      _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\r\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\r\n    }\r\n\r\n    IAToken(aToken).burn(msg.sender, to, amountToWithdraw, reserve.liquidityIndex);\r\n\r\n    emit Withdraw(asset, msg.sender, to, amountToWithdraw);\r\n\r\n    return amountToWithdraw;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n   * @param asset The address of the underlying asset to borrow\r\n   * @param amount The amount to be borrowed\r\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n   * if he has been given credit delegation allowance\r\n   **/\r\n  function borrow(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    uint16 referralCode,\r\n    address onBehalfOf\r\n  ) external override whenNotPaused {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    _executeBorrow(\r\n      ExecuteBorrowParams(\r\n        asset,\r\n        msg.sender,\r\n        onBehalfOf,\r\n        amount,\r\n        interestRateMode,\r\n        reserve.aTokenAddress,\r\n        referralCode,\r\n        true\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n   * other borrower whose debt should be removed\r\n   * @return The final amount repaid\r\n   **/\r\n  function repay(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 rateMode,\r\n    address onBehalfOf\r\n  ) external override whenNotPaused returns (uint256) {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\r\n\r\n    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\r\n\r\n    ValidationLogic.validateRepay(\r\n      reserve,\r\n      amount,\r\n      interestRateMode,\r\n      onBehalfOf,\r\n      stableDebt,\r\n      variableDebt\r\n    );\r\n\r\n    uint256 paybackAmount =\r\n      interestRateMode == DataTypes.InterestRateMode.STABLE ? stableDebt : variableDebt;\r\n\r\n    if (amount < paybackAmount) {\r\n      paybackAmount = amount;\r\n    }\r\n\r\n    reserve.updateState();\r\n\r\n    if (interestRateMode == DataTypes.InterestRateMode.STABLE) {\r\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(onBehalfOf, paybackAmount);\r\n    } else {\r\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\r\n        onBehalfOf,\r\n        paybackAmount,\r\n        reserve.variableBorrowIndex\r\n      );\r\n    }\r\n\r\n    address aToken = reserve.aTokenAddress;\r\n    reserve.updateInterestRates(asset, aToken, paybackAmount, 0);\r\n\r\n    if (stableDebt.add(variableDebt).sub(paybackAmount) == 0) {\r\n      _usersConfig[onBehalfOf].setBorrowing(reserve.id, false);\r\n    }\r\n\r\n    IERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount);\r\n\r\n    IAToken(aToken).handleRepayment(msg.sender, paybackAmount);\r\n\r\n    emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\r\n\r\n    return paybackAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param rateMode The rate mode that the user wants to swap to\r\n   **/\r\n  function swapBorrowRateMode(address asset, uint256 rateMode) external override whenNotPaused {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(msg.sender, reserve);\r\n\r\n    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\r\n\r\n    ValidationLogic.validateSwapRateMode(\r\n      reserve,\r\n      _usersConfig[msg.sender],\r\n      stableDebt,\r\n      variableDebt,\r\n      interestRateMode\r\n    );\r\n\r\n    reserve.updateState();\r\n\r\n    if (interestRateMode == DataTypes.InterestRateMode.STABLE) {\r\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(msg.sender, stableDebt);\r\n      IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\r\n        msg.sender,\r\n        msg.sender,\r\n        stableDebt,\r\n        reserve.variableBorrowIndex\r\n      );\r\n    } else {\r\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\r\n        msg.sender,\r\n        variableDebt,\r\n        reserve.variableBorrowIndex\r\n      );\r\n      IStableDebtToken(reserve.stableDebtTokenAddress).mint(\r\n        msg.sender,\r\n        msg.sender,\r\n        variableDebt,\r\n        reserve.currentStableBorrowRate\r\n      );\r\n    }\r\n\r\n    reserve.updateInterestRates(asset, reserve.aTokenAddress, 0, 0);\r\n\r\n    emit Swap(asset, msg.sender, rateMode);\r\n  }\r\n\r\n  /**\r\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n   * - Users can be rebalanced if the following conditions are satisfied:\r\n   *     1. Usage ratio is above 95%\r\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\r\n   *        borrowed at a stable rate and depositors are not earning enough\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param user The address of the user to be rebalanced\r\n   **/\r\n  function rebalanceStableBorrowRate(address asset, address user) external override whenNotPaused {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    IERC20 stableDebtToken = IERC20(reserve.stableDebtTokenAddress);\r\n    IERC20 variableDebtToken = IERC20(reserve.variableDebtTokenAddress);\r\n    address aTokenAddress = reserve.aTokenAddress;\r\n\r\n    uint256 stableDebt = IERC20(stableDebtToken).balanceOf(user);\r\n\r\n    ValidationLogic.validateRebalanceStableBorrowRate(\r\n      reserve,\r\n      asset,\r\n      stableDebtToken,\r\n      variableDebtToken,\r\n      aTokenAddress\r\n    );\r\n\r\n    reserve.updateState();\r\n\r\n    IStableDebtToken(address(stableDebtToken)).burn(user, stableDebt);\r\n    IStableDebtToken(address(stableDebtToken)).mint(\r\n      user,\r\n      user,\r\n      stableDebt,\r\n      reserve.currentStableBorrowRate\r\n    );\r\n\r\n    reserve.updateInterestRates(asset, aTokenAddress, 0, 0);\r\n\r\n    emit RebalanceStableBorrowRate(asset, user);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n   * @param asset The address of the underlying asset deposited\r\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n   **/\r\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\r\n    external\r\n    override\r\n    whenNotPaused\r\n  {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    ValidationLogic.validateSetUseReserveAsCollateral(\r\n      reserve,\r\n      asset,\r\n      useAsCollateral,\r\n      _reserves,\r\n      _usersConfig[msg.sender],\r\n      _reservesList,\r\n      _reservesCount,\r\n      _addressesProvider.getPriceOracle()\r\n    );\r\n\r\n    _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, useAsCollateral);\r\n\r\n    if (useAsCollateral) {\r\n      emit ReserveUsedAsCollateralEnabled(asset, msg.sender);\r\n    } else {\r\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  function liquidationCall(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool receiveAToken\r\n  ) external override whenNotPaused {\r\n    address collateralManager = _addressesProvider.getLendingPoolCollateralManager();\r\n\r\n    //solium-disable-next-line\r\n    (bool success, bytes memory result) =\r\n      collateralManager.delegatecall(\r\n        abi.encodeWithSignature(\r\n          'liquidationCall(address,address,address,uint256,bool)',\r\n          collateralAsset,\r\n          debtAsset,\r\n          user,\r\n          debtToCover,\r\n          receiveAToken\r\n        )\r\n      );\r\n\r\n    require(success, Errors.LP_LIQUIDATION_CALL_FAILED);\r\n\r\n    (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\r\n\r\n    require(returnCode == 0, string(abi.encodePacked(returnMessage)));\r\n  }\r\n\r\n  struct FlashLoanLocalVars {\r\n    IFlashLoanReceiver receiver;\r\n    address oracle;\r\n    uint256 i;\r\n    address currentAsset;\r\n    address currentATokenAddress;\r\n    uint256 currentAmount;\r\n    uint256 currentPremium;\r\n    uint256 currentAmountPlusPremium;\r\n    address debtToken;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n   * as long as the amount taken plus a fee is returned.\r\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n   * For further details please visit https://developers.aave.com\r\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n   * @param assets The addresses of the assets being flash-borrowed\r\n   * @param amounts The amounts amounts being flash-borrowed\r\n   * @param modes Types of the debt to open if the flash loan is not returned:\r\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n   * @param params Variadic packed params to pass to the receiver as extra information\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function flashLoan(\r\n    address receiverAddress,\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata modes,\r\n    address onBehalfOf,\r\n    bytes calldata params,\r\n    uint16 referralCode\r\n  ) external override whenNotPaused {\r\n    FlashLoanLocalVars memory vars;\r\n\r\n    ValidationLogic.validateFlashloan(assets, amounts);\r\n\r\n    address[] memory aTokenAddresses = new address[](assets.length);\r\n    uint256[] memory premiums = new uint256[](assets.length);\r\n\r\n    vars.receiver = IFlashLoanReceiver(receiverAddress);\r\n\r\n    for (vars.i = 0; vars.i < assets.length; vars.i++) {\r\n      aTokenAddresses[vars.i] = _reserves[assets[vars.i]].aTokenAddress;\r\n\r\n      premiums[vars.i] = amounts[vars.i].mul(_flashLoanPremiumTotal).div(10000);\r\n\r\n      IAToken(aTokenAddresses[vars.i]).transferUnderlyingTo(receiverAddress, amounts[vars.i]);\r\n    }\r\n\r\n    require(\r\n      vars.receiver.executeOperation(assets, amounts, premiums, msg.sender, params),\r\n      Errors.LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN\r\n    );\r\n\r\n    for (vars.i = 0; vars.i < assets.length; vars.i++) {\r\n      vars.currentAsset = assets[vars.i];\r\n      vars.currentAmount = amounts[vars.i];\r\n      vars.currentPremium = premiums[vars.i];\r\n      vars.currentATokenAddress = aTokenAddresses[vars.i];\r\n      vars.currentAmountPlusPremium = vars.currentAmount.add(vars.currentPremium);\r\n\r\n      if (DataTypes.InterestRateMode(modes[vars.i]) == DataTypes.InterestRateMode.NONE) {\r\n        _reserves[vars.currentAsset].updateState();\r\n        _reserves[vars.currentAsset].cumulateToLiquidityIndex(\r\n          IERC20(vars.currentATokenAddress).totalSupply(),\r\n          vars.currentPremium\r\n        );\r\n        _reserves[vars.currentAsset].updateInterestRates(\r\n          vars.currentAsset,\r\n          vars.currentATokenAddress,\r\n          vars.currentAmountPlusPremium,\r\n          0\r\n        );\r\n\r\n        IERC20(vars.currentAsset).safeTransferFrom(\r\n          receiverAddress,\r\n          vars.currentATokenAddress,\r\n          vars.currentAmountPlusPremium\r\n        );\r\n      } else {\r\n        // If the user chose to not return the funds, the system checks if there is enough collateral and\r\n        // eventually opens a debt position\r\n        _executeBorrow(\r\n          ExecuteBorrowParams(\r\n            vars.currentAsset,\r\n            msg.sender,\r\n            onBehalfOf,\r\n            vars.currentAmount,\r\n            modes[vars.i],\r\n            vars.currentATokenAddress,\r\n            referralCode,\r\n            false\r\n          )\r\n        );\r\n      }\r\n      emit FlashLoan(\r\n        receiverAddress,\r\n        msg.sender,\r\n        vars.currentAsset,\r\n        vars.currentAmount,\r\n        vars.currentPremium,\r\n        referralCode\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the state and configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The state of the reserve\r\n   **/\r\n  function getReserveData(address asset)\r\n    external\r\n    view\r\n    override\r\n    returns (DataTypes.ReserveData memory)\r\n  {\r\n    return _reserves[asset];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the user account data across all the reserves\r\n   * @param user The address of the user\r\n   * @return totalCollateralETH the total collateral in ETH of the user\r\n   * @return totalDebtETH the total debt in ETH of the user\r\n   * @return availableBorrowsETH the borrowing power left of the user\r\n   * @return currentLiquidationThreshold the liquidation threshold of the user\r\n   * @return ltv the loan to value of the user\r\n   * @return healthFactor the current health factor of the user\r\n   **/\r\n  function getUserAccountData(address user)\r\n    external\r\n    view\r\n    override\r\n    returns (\r\n      uint256 totalCollateralETH,\r\n      uint256 totalDebtETH,\r\n      uint256 availableBorrowsETH,\r\n      uint256 currentLiquidationThreshold,\r\n      uint256 ltv,\r\n      uint256 healthFactor\r\n    )\r\n  {\r\n    (\r\n      totalCollateralETH,\r\n      totalDebtETH,\r\n      ltv,\r\n      currentLiquidationThreshold,\r\n      healthFactor\r\n    ) = GenericLogic.calculateUserAccountData(\r\n      user,\r\n      _reserves,\r\n      _usersConfig[user],\r\n      _reservesList,\r\n      _reservesCount,\r\n      _addressesProvider.getPriceOracle()\r\n    );\r\n\r\n    availableBorrowsETH = GenericLogic.calculateAvailableBorrowsETH(\r\n      totalCollateralETH,\r\n      totalDebtETH,\r\n      ltv\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The configuration of the reserve\r\n   **/\r\n  function getConfiguration(address asset)\r\n    external\r\n    view\r\n    override\r\n    returns (DataTypes.ReserveConfigurationMap memory)\r\n  {\r\n    return _reserves[asset].configuration;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the configuration of the user across all the reserves\r\n   * @param user The user address\r\n   * @return The configuration of the user\r\n   **/\r\n  function getUserConfiguration(address user)\r\n    external\r\n    view\r\n    override\r\n    returns (DataTypes.UserConfigurationMap memory)\r\n  {\r\n    return _usersConfig[user];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the normalized income per unit of asset\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve's normalized income\r\n   */\r\n  function getReserveNormalizedIncome(address asset)\r\n    external\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _reserves[asset].getNormalizedIncome();\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the normalized variable debt per unit of asset\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve normalized variable debt\r\n   */\r\n  function getReserveNormalizedVariableDebt(address asset)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _reserves[asset].getNormalizedDebt();\r\n  }\r\n\r\n  /**\r\n   * @dev Returns if the LendingPool is paused\r\n   */\r\n  function paused() external view override returns (bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the list of the initialized reserves\r\n   **/\r\n  function getReservesList() external view override returns (address[] memory) {\r\n    address[] memory _activeReserves = new address[](_reservesCount);\r\n\r\n    for (uint256 i = 0; i < _reservesCount; i++) {\r\n      _activeReserves[i] = _reservesList[i];\r\n    }\r\n    return _activeReserves;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the cached LendingPoolAddressesProvider connected to this contract\r\n   **/\r\n  function getAddressesProvider() external view override returns (ILendingPoolAddressesProvider) {\r\n    return _addressesProvider;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the percentage of available liquidity that can be borrowed at once at stable rate\r\n   */\r\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() public view returns (uint256) {\r\n    return _maxStableRateBorrowSizePercent;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the fee on flash loans \r\n   */\r\n  function FLASHLOAN_PREMIUM_TOTAL() public view returns (uint256) {\r\n    return _flashLoanPremiumTotal;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the maximum number of reserves supported to be listed in this LendingPool\r\n   */\r\n  function MAX_NUMBER_RESERVES() public view returns (uint256) {\r\n    return _maxNumberOfReserves;\r\n  }\r\n\r\n  /**\r\n   * @dev Validates and finalizes an aToken transfer\r\n   * - Only callable by the overlying aToken of the `asset`\r\n   * @param asset The address of the underlying asset of the aToken\r\n   * @param from The user from which the aTokens are transferred\r\n   * @param to The user receiving the aTokens\r\n   * @param amount The amount being transferred/withdrawn\r\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\r\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\r\n   */\r\n  function finalizeTransfer(\r\n    address asset,\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    uint256 balanceFromBefore,\r\n    uint256 balanceToBefore\r\n  ) external override whenNotPaused {\r\n    require(msg.sender == _reserves[asset].aTokenAddress, Errors.LP_CALLER_MUST_BE_AN_ATOKEN);\r\n\r\n    ValidationLogic.validateTransfer(\r\n      from,\r\n      _reserves,\r\n      _usersConfig[from],\r\n      _reservesList,\r\n      _reservesCount,\r\n      _addressesProvider.getPriceOracle()\r\n    );\r\n\r\n    uint256 reserveId = _reserves[asset].id;\r\n\r\n    if (from != to) {\r\n      if (balanceFromBefore.sub(amount) == 0) {\r\n        DataTypes.UserConfigurationMap storage fromConfig = _usersConfig[from];\r\n        fromConfig.setUsingAsCollateral(reserveId, false);\r\n        emit ReserveUsedAsCollateralDisabled(asset, from);\r\n      }\r\n\r\n      if (balanceToBefore == 0 && amount != 0) {\r\n        DataTypes.UserConfigurationMap storage toConfig = _usersConfig[to];\r\n        toConfig.setUsingAsCollateral(reserveId, true);\r\n        emit ReserveUsedAsCollateralEnabled(asset, to);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Initializes a reserve, activating it, assigning an aToken and debt tokens and an\r\n   * interest rate strategy\r\n   * - Only callable by the LendingPoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\r\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\r\n   * @param aTokenAddress The address of the VariableDebtToken that will be assigned to the reserve\r\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\r\n   **/\r\n  function initReserve(\r\n    address asset,\r\n    address aTokenAddress,\r\n    address stableDebtAddress,\r\n    address variableDebtAddress,\r\n    address interestRateStrategyAddress\r\n  ) external override onlyLendingPoolConfigurator {\r\n    require(Address.isContract(asset), Errors.LP_NOT_CONTRACT);\r\n    _reserves[asset].init(\r\n      aTokenAddress,\r\n      stableDebtAddress,\r\n      variableDebtAddress,\r\n      interestRateStrategyAddress\r\n    );\r\n    _addReserveToList(asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the address of the interest rate strategy contract\r\n   * - Only callable by the LendingPoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param rateStrategyAddress The address of the interest rate strategy contract\r\n   **/\r\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\r\n    external\r\n    override\r\n    onlyLendingPoolConfigurator\r\n  {\r\n    _reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the configuration bitmap of the reserve as a whole\r\n   * - Only callable by the LendingPoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param configuration The new configuration bitmap\r\n   **/\r\n  function setConfiguration(address asset, uint256 configuration)\r\n    external\r\n    override\r\n    onlyLendingPoolConfigurator\r\n  {\r\n    _reserves[asset].configuration.data = configuration;\r\n  }\r\n\r\n  /**\r\n   * @dev Set the _pause state of a reserve\r\n   * - Only callable by the LendingPoolConfigurator contract\r\n   * @param val `true` to pause the reserve, `false` to un-pause it\r\n   */\r\n  function setPause(bool val) external override onlyLendingPoolConfigurator {\r\n    _paused = val;\r\n    if (_paused) {\r\n      emit Paused();\r\n    } else {\r\n      emit Unpaused();\r\n    }\r\n  }\r\n\r\n  struct ExecuteBorrowParams {\r\n    address asset;\r\n    address user;\r\n    address onBehalfOf;\r\n    uint256 amount;\r\n    uint256 interestRateMode;\r\n    address aTokenAddress;\r\n    uint16 referralCode;\r\n    bool releaseUnderlying;\r\n  }\r\n\r\n  function _executeBorrow(ExecuteBorrowParams memory vars) internal {\r\n    DataTypes.ReserveData storage reserve = _reserves[vars.asset];\r\n    DataTypes.UserConfigurationMap storage userConfig = _usersConfig[vars.onBehalfOf];\r\n\r\n    address oracle = _addressesProvider.getPriceOracle();\r\n\r\n    uint256 amountInETH =\r\n      IPriceOracleGetter(oracle).getAssetPrice(vars.asset).mul(vars.amount).div(\r\n        10**reserve.configuration.getDecimals()\r\n      );\r\n\r\n    ValidationLogic.validateBorrow(\r\n      vars.asset,\r\n      reserve,\r\n      vars.onBehalfOf,\r\n      vars.amount,\r\n      amountInETH,\r\n      vars.interestRateMode,\r\n      _maxStableRateBorrowSizePercent,\r\n      _reserves,\r\n      userConfig,\r\n      _reservesList,\r\n      _reservesCount,\r\n      oracle\r\n    );\r\n\r\n    reserve.updateState();\r\n\r\n    uint256 currentStableRate = 0;\r\n\r\n    bool isFirstBorrowing = false;\r\n    if (DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE) {\r\n      currentStableRate = reserve.currentStableBorrowRate;\r\n\r\n      isFirstBorrowing = IStableDebtToken(reserve.stableDebtTokenAddress).mint(\r\n        vars.user,\r\n        vars.onBehalfOf,\r\n        vars.amount,\r\n        currentStableRate\r\n      );\r\n    } else {\r\n      isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\r\n        vars.user,\r\n        vars.onBehalfOf,\r\n        vars.amount,\r\n        reserve.variableBorrowIndex\r\n      );\r\n    }\r\n\r\n    if (isFirstBorrowing) {\r\n      userConfig.setBorrowing(reserve.id, true);\r\n    }\r\n\r\n    reserve.updateInterestRates(\r\n      vars.asset,\r\n      vars.aTokenAddress,\r\n      0,\r\n      vars.releaseUnderlying ? vars.amount : 0\r\n    );\r\n\r\n    if (vars.releaseUnderlying) {\r\n      IAToken(vars.aTokenAddress).transferUnderlyingTo(vars.user, vars.amount);\r\n    }\r\n\r\n    emit Borrow(\r\n      vars.asset,\r\n      vars.user,\r\n      vars.onBehalfOf,\r\n      vars.amount,\r\n      vars.interestRateMode,\r\n      DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE\r\n        ? currentStableRate\r\n        : reserve.currentVariableBorrowRate,\r\n      vars.referralCode\r\n    );\r\n  }\r\n\r\n  function _addReserveToList(address asset) internal {\r\n    uint256 reservesCount = _reservesCount;\r\n\r\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\r\n\r\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\r\n\r\n    if (!reserveAlreadyAdded) {\r\n      _reserves[asset].id = uint8(reservesCount);\r\n      _reservesList[reservesCount] = asset;\r\n\r\n      _reservesCount = reservesCount + 1;\r\n    }\r\n  }\r\n}\r\n"
      },
      "contracts/interfaces/IExchangeAdapter.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\r\n\r\ninterface IExchangeAdapter {\r\n  event Exchange(\r\n    address indexed from,\r\n    address indexed to,\r\n    address indexed platform,\r\n    uint256 fromAmount,\r\n    uint256 toAmount\r\n  );\r\n\r\n  function approveExchange(IERC20[] calldata tokens) external;\r\n\r\n  function exchange(\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    uint256 maxSlippage\r\n  ) external returns (uint256);\r\n}\r\n"
      },
      "contracts/mocks/tokens/MintableDelegationERC20.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {ERC20} from '../../dependencies/openzeppelin/contracts/ERC20.sol';\r\n\r\n/**\r\n * @title ERC20Mintable\r\n * @dev ERC20 minting logic\r\n */\r\ncontract MintableDelegationERC20 is ERC20 {\r\n  address public delegatee;\r\n\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint8 decimals\r\n  ) public ERC20(name, symbol) {\r\n    _setupDecimals(decimals);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokensp\r\n   * @param value The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(uint256 value) public returns (bool) {\r\n    _mint(msg.sender, value);\r\n    return true;\r\n  }\r\n\r\n  function delegate(address delegateeAddress) external {\r\n    delegatee = delegateeAddress;\r\n  }\r\n}\r\n"
      },
      "contracts/mocks/swap/MockUniswapV2Router02.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {IUniswapV2Router02} from '../../interfaces/IUniswapV2Router02.sol';\r\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\r\nimport {MintableERC20} from '../tokens/MintableERC20.sol';\r\n\r\ncontract MockUniswapV2Router02 is IUniswapV2Router02 {\r\n  mapping(address => uint256) internal _amountToReturn;\r\n  mapping(address => uint256) internal _amountToSwap;\r\n  mapping(address => mapping(address => mapping(uint256 => uint256))) internal _amountsIn;\r\n  mapping(address => mapping(address => mapping(uint256 => uint256))) internal _amountsOut;\r\n  uint256 internal defaultMockValue;\r\n\r\n  function setAmountToReturn(address reserve, uint256 amount) public {\r\n    _amountToReturn[reserve] = amount;\r\n  }\r\n\r\n  function setAmountToSwap(address reserve, uint256 amount) public {\r\n    _amountToSwap[reserve] = amount;\r\n  }\r\n\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256, /* amountOutMin */\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 /* deadline */\r\n  ) external override returns (uint256[] memory amounts) {\r\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\r\n\r\n    MintableERC20(path[1]).mint(_amountToReturn[path[0]]);\r\n    IERC20(path[1]).transfer(to, _amountToReturn[path[0]]);\r\n\r\n    amounts = new uint256[](path.length);\r\n    amounts[0] = amountIn;\r\n    amounts[1] = _amountToReturn[path[0]];\r\n  }\r\n\r\n  function swapTokensForExactTokens(\r\n    uint256 amountOut,\r\n    uint256, /* amountInMax */\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 /* deadline */\r\n  ) external override returns (uint256[] memory amounts) {\r\n    IERC20(path[0]).transferFrom(msg.sender, address(this), _amountToSwap[path[0]]);\r\n\r\n    MintableERC20(path[1]).mint(amountOut);\r\n    IERC20(path[1]).transfer(to, amountOut);\r\n\r\n    amounts = new uint256[](path.length);\r\n    amounts[0] = _amountToSwap[path[0]];\r\n    amounts[1] = amountOut;\r\n  }\r\n\r\n  function setAmountOut(\r\n    uint256 amountIn,\r\n    address reserveIn,\r\n    address reserveOut,\r\n    uint256 amountOut\r\n  ) public {\r\n    _amountsOut[reserveIn][reserveOut][amountIn] = amountOut;\r\n  }\r\n\r\n  function setAmountIn(\r\n    uint256 amountOut,\r\n    address reserveIn,\r\n    address reserveOut,\r\n    uint256 amountIn\r\n  ) public {\r\n    _amountsIn[reserveIn][reserveOut][amountOut] = amountIn;\r\n  }\r\n\r\n  function setDefaultMockValue(uint256 value) public {\r\n    defaultMockValue = value;\r\n  }\r\n\r\n  function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256[] memory)\r\n  {\r\n    uint256[] memory amounts = new uint256[](path.length);\r\n    amounts[0] = amountIn;\r\n    amounts[1] = _amountsOut[path[0]][path[1]][amountIn] > 0\r\n      ? _amountsOut[path[0]][path[1]][amountIn]\r\n      : defaultMockValue;\r\n    return amounts;\r\n  }\r\n\r\n  function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256[] memory)\r\n  {\r\n    uint256[] memory amounts = new uint256[](path.length);\r\n    amounts[0] = _amountsIn[path[0]][path[1]][amountOut] > 0\r\n      ? _amountsIn[path[0]][path[1]][amountOut]\r\n      : defaultMockValue;\r\n    amounts[1] = amountOut;\r\n    return amounts;\r\n  }\r\n}\r\n"
      },
      "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
      },
      "contracts/adapters/UniswapLiquiditySwapAdapter.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {BaseUniswapAdapter} from './BaseUniswapAdapter.sol';\r\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol';\r\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\r\n\r\n/**\r\n * @title UniswapLiquiditySwapAdapter\r\n * @notice Uniswap V2 Adapter to swap liquidity.\r\n * @author Aave\r\n **/\r\ncontract UniswapLiquiditySwapAdapter is BaseUniswapAdapter {\r\n  struct PermitParams {\r\n    uint256[] amount;\r\n    uint256[] deadline;\r\n    uint8[] v;\r\n    bytes32[] r;\r\n    bytes32[] s;\r\n  }\r\n\r\n  struct SwapParams {\r\n    address[] assetToSwapToList;\r\n    uint256[] minAmountsToReceive;\r\n    bool[] swapAllBalance;\r\n    PermitParams permitParams;\r\n    bool[] useEthPath;\r\n  }\r\n\r\n  constructor(\r\n    ILendingPoolAddressesProvider addressesProvider,\r\n    IUniswapV2Router02 uniswapRouter,\r\n    address wethAddress\r\n  ) public BaseUniswapAdapter(addressesProvider, uniswapRouter, wethAddress) {}\r\n\r\n  /**\r\n   * @dev Swaps the received reserve amount from the flash loan into the asset specified in the params.\r\n   * The received funds from the swap are then deposited into the protocol on behalf of the user.\r\n   * The user should give this contract allowance to pull the ATokens in order to withdraw the underlying asset and\r\n   * repay the flash loan.\r\n   * @param assets Address of asset to be swapped\r\n   * @param amounts Amount of the asset to be swapped\r\n   * @param premiums Fee of the flash loan\r\n   * @param initiator Address of the user\r\n   * @param params Additional variadic field to include extra params. Expected parameters:\r\n   *   address[] assetToSwapToList List of the addresses of the reserve to be swapped to and deposited\r\n   *   uint256[] minAmountsToReceive List of min amounts to be received from the swap\r\n   *   bool[] swapAllBalance Flag indicating if all the user balance should be swapped\r\n   *   uint256[] permitAmount List of amounts for the permit signature\r\n   *   uint256[] deadline List of deadlines for the permit signature\r\n   *   uint8[] v List of v param for the permit signature\r\n   *   bytes32[] r List of r param for the permit signature\r\n   *   bytes32[] s List of s param for the permit signature\r\n   */\r\n  function executeOperation(\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata premiums,\r\n    address initiator,\r\n    bytes calldata params\r\n  ) external override returns (bool) {\r\n    require(msg.sender == address(LENDING_POOL), 'CALLER_MUST_BE_LENDING_POOL');\r\n\r\n    SwapParams memory decodedParams = _decodeParams(params);\r\n\r\n    require(\r\n      assets.length == decodedParams.assetToSwapToList.length &&\r\n        assets.length == decodedParams.minAmountsToReceive.length &&\r\n        assets.length == decodedParams.swapAllBalance.length &&\r\n        assets.length == decodedParams.permitParams.amount.length &&\r\n        assets.length == decodedParams.permitParams.deadline.length &&\r\n        assets.length == decodedParams.permitParams.v.length &&\r\n        assets.length == decodedParams.permitParams.r.length &&\r\n        assets.length == decodedParams.permitParams.s.length &&\r\n        assets.length == decodedParams.useEthPath.length,\r\n      'INCONSISTENT_PARAMS'\r\n    );\r\n\r\n    for (uint256 i = 0; i < assets.length; i++) {\r\n      _swapLiquidity(\r\n        assets[i],\r\n        decodedParams.assetToSwapToList[i],\r\n        amounts[i],\r\n        premiums[i],\r\n        initiator,\r\n        decodedParams.minAmountsToReceive[i],\r\n        decodedParams.swapAllBalance[i],\r\n        PermitSignature(\r\n          decodedParams.permitParams.amount[i],\r\n          decodedParams.permitParams.deadline[i],\r\n          decodedParams.permitParams.v[i],\r\n          decodedParams.permitParams.r[i],\r\n          decodedParams.permitParams.s[i]\r\n        ),\r\n        decodedParams.useEthPath[i]\r\n      );\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  struct SwapAndDepositLocalVars {\r\n    uint256 i;\r\n    uint256 aTokenInitiatorBalance;\r\n    uint256 amountToSwap;\r\n    uint256 receivedAmount;\r\n    address aToken;\r\n  }\r\n\r\n  /**\r\n   * @dev Swaps an amount of an asset to another and deposits the new asset amount on behalf of the user without using\r\n   * a flash loan. This method can be used when the temporary transfer of the collateral asset to this contract\r\n   * does not affect the user position.\r\n   * The user should give this contract allowance to pull the ATokens in order to withdraw the underlying asset and\r\n   * perform the swap.\r\n   * @param assetToSwapFromList List of addresses of the underlying asset to be swap from\r\n   * @param assetToSwapToList List of addresses of the underlying asset to be swap to and deposited\r\n   * @param amountToSwapList List of amounts to be swapped. If the amount exceeds the balance, the total balance is used for the swap\r\n   * @param minAmountsToReceive List of min amounts to be received from the swap\r\n   * @param permitParams List of struct containing the permit signatures\r\n   *   uint256 permitAmount Amount for the permit signature\r\n   *   uint256 deadline Deadline for the permit signature\r\n   *   uint8 v param for the permit signature\r\n   *   bytes32 r param for the permit signature\r\n   *   bytes32 s param for the permit signature\r\n   * @param useEthPath true if the swap needs to occur using ETH in the routing, false otherwise\r\n   */\r\n  function swapAndDeposit(\r\n    address[] calldata assetToSwapFromList,\r\n    address[] calldata assetToSwapToList,\r\n    uint256[] calldata amountToSwapList,\r\n    uint256[] calldata minAmountsToReceive,\r\n    PermitSignature[] calldata permitParams,\r\n    bool[] calldata useEthPath\r\n  ) external {\r\n    require(\r\n      assetToSwapFromList.length == assetToSwapToList.length &&\r\n        assetToSwapFromList.length == amountToSwapList.length &&\r\n        assetToSwapFromList.length == minAmountsToReceive.length &&\r\n        assetToSwapFromList.length == permitParams.length,\r\n      'INCONSISTENT_PARAMS'\r\n    );\r\n\r\n    SwapAndDepositLocalVars memory vars;\r\n\r\n    for (vars.i = 0; vars.i < assetToSwapFromList.length; vars.i++) {\r\n      vars.aToken = _getReserveData(assetToSwapFromList[vars.i]).aTokenAddress;\r\n\r\n      vars.aTokenInitiatorBalance = IERC20(vars.aToken).balanceOf(msg.sender);\r\n      vars.amountToSwap = amountToSwapList[vars.i] > vars.aTokenInitiatorBalance\r\n        ? vars.aTokenInitiatorBalance\r\n        : amountToSwapList[vars.i];\r\n\r\n      _pullAToken(\r\n        assetToSwapFromList[vars.i],\r\n        vars.aToken,\r\n        msg.sender,\r\n        vars.amountToSwap,\r\n        permitParams[vars.i]\r\n      );\r\n\r\n      vars.receivedAmount = _swapExactTokensForTokens(\r\n        assetToSwapFromList[vars.i],\r\n        assetToSwapToList[vars.i],\r\n        vars.amountToSwap,\r\n        minAmountsToReceive[vars.i],\r\n        useEthPath[vars.i]\r\n      );\r\n\r\n      // Deposit new reserve\r\n      IERC20(assetToSwapToList[vars.i]).safeApprove(address(LENDING_POOL), 0);\r\n      IERC20(assetToSwapToList[vars.i]).safeApprove(address(LENDING_POOL), vars.receivedAmount);\r\n      LENDING_POOL.deposit(assetToSwapToList[vars.i], vars.receivedAmount, msg.sender, 0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Swaps an `amountToSwap` of an asset to another and deposits the funds on behalf of the initiator.\r\n   * @param assetFrom Address of the underlying asset to be swap from\r\n   * @param assetTo Address of the underlying asset to be swap to and deposited\r\n   * @param amount Amount from flash loan\r\n   * @param premium Premium of the flash loan\r\n   * @param minAmountToReceive Min amount to be received from the swap\r\n   * @param swapAllBalance Flag indicating if all the user balance should be swapped\r\n   * @param permitSignature List of struct containing the permit signature\r\n   * @param useEthPath true if the swap needs to occur using ETH in the routing, false otherwise\r\n   */\r\n\r\n  struct SwapLiquidityLocalVars {\r\n    address aToken;\r\n    uint256 aTokenInitiatorBalance;\r\n    uint256 amountToSwap;\r\n    uint256 receivedAmount;\r\n    uint256 flashLoanDebt;\r\n    uint256 amountToPull;\r\n  }\r\n\r\n  function _swapLiquidity(\r\n    address assetFrom,\r\n    address assetTo,\r\n    uint256 amount,\r\n    uint256 premium,\r\n    address initiator,\r\n    uint256 minAmountToReceive,\r\n    bool swapAllBalance,\r\n    PermitSignature memory permitSignature,\r\n    bool useEthPath\r\n  ) internal {\r\n    SwapLiquidityLocalVars memory vars;\r\n\r\n    vars.aToken = _getReserveData(assetFrom).aTokenAddress;\r\n\r\n    vars.aTokenInitiatorBalance = IERC20(vars.aToken).balanceOf(initiator);\r\n    vars.amountToSwap = swapAllBalance && vars.aTokenInitiatorBalance.sub(premium) <= amount\r\n      ? vars.aTokenInitiatorBalance.sub(premium)\r\n      : amount;\r\n\r\n    vars.receivedAmount = _swapExactTokensForTokens(\r\n      assetFrom,\r\n      assetTo,\r\n      vars.amountToSwap,\r\n      minAmountToReceive,\r\n      useEthPath\r\n    );\r\n\r\n    // Deposit new reserve\r\n    IERC20(assetTo).safeApprove(address(LENDING_POOL), 0);\r\n    IERC20(assetTo).safeApprove(address(LENDING_POOL), vars.receivedAmount);\r\n    LENDING_POOL.deposit(assetTo, vars.receivedAmount, initiator, 0);\r\n\r\n    vars.flashLoanDebt = amount.add(premium);\r\n    vars.amountToPull = vars.amountToSwap.add(premium);\r\n\r\n    _pullAToken(assetFrom, vars.aToken, initiator, vars.amountToPull, permitSignature);\r\n\r\n    // Repay flash loan\r\n    IERC20(assetFrom).safeApprove(address(LENDING_POOL), 0);\r\n    IERC20(assetFrom).safeApprove(address(LENDING_POOL), vars.flashLoanDebt);\r\n  }\r\n\r\n  /**\r\n   * @dev Decodes the information encoded in the flash loan params\r\n   * @param params Additional variadic field to include extra params. Expected parameters:\r\n   *   address[] assetToSwapToList List of the addresses of the reserve to be swapped to and deposited\r\n   *   uint256[] minAmountsToReceive List of min amounts to be received from the swap\r\n   *   bool[] swapAllBalance Flag indicating if all the user balance should be swapped\r\n   *   uint256[] permitAmount List of amounts for the permit signature\r\n   *   uint256[] deadline List of deadlines for the permit signature\r\n   *   uint8[] v List of v param for the permit signature\r\n   *   bytes32[] r List of r param for the permit signature\r\n   *   bytes32[] s List of s param for the permit signature\r\n   *   bool[] useEthPath true if the swap needs to occur using ETH in the routing, false otherwise\r\n   * @return SwapParams struct containing decoded params\r\n   */\r\n  function _decodeParams(bytes memory params) internal pure returns (SwapParams memory) {\r\n    (\r\n      address[] memory assetToSwapToList,\r\n      uint256[] memory minAmountsToReceive,\r\n      bool[] memory swapAllBalance,\r\n      uint256[] memory permitAmount,\r\n      uint256[] memory deadline,\r\n      uint8[] memory v,\r\n      bytes32[] memory r,\r\n      bytes32[] memory s,\r\n      bool[] memory useEthPath\r\n    ) =\r\n      abi.decode(\r\n        params,\r\n        (address[], uint256[], bool[], uint256[], uint256[], uint8[], bytes32[], bytes32[], bool[])\r\n      );\r\n\r\n    return\r\n      SwapParams(\r\n        assetToSwapToList,\r\n        minAmountsToReceive,\r\n        swapAllBalance,\r\n        PermitParams(permitAmount, deadline, v, r, s),\r\n        useEthPath\r\n      );\r\n  }\r\n}\r\n"
      },
      "contracts/adapters/FlashLiquidationAdapter.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {BaseUniswapAdapter} from './BaseUniswapAdapter.sol';\r\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\r\nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol';\r\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\r\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\r\nimport {Helpers} from '../protocol/libraries/helpers/Helpers.sol';\r\nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol';\r\nimport {IAToken} from '../interfaces/IAToken.sol';\r\nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol';\r\n\r\n/**\r\n * @title UniswapLiquiditySwapAdapter\r\n * @notice Uniswap V2 Adapter to swap liquidity.\r\n * @author Aave\r\n **/\r\ncontract FlashLiquidationAdapter is BaseUniswapAdapter {\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n  uint256 internal constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 5000;\r\n\r\n  struct LiquidationParams {\r\n    address collateralAsset;\r\n    address borrowedAsset;\r\n    address user;\r\n    uint256 debtToCover;\r\n    bool useEthPath;\r\n  }\r\n\r\n  struct LiquidationCallLocalVars {\r\n    uint256 initFlashBorrowedBalance;\r\n    uint256 diffFlashBorrowedBalance;\r\n    uint256 initCollateralBalance;\r\n    uint256 diffCollateralBalance;\r\n    uint256 flashLoanDebt;\r\n    uint256 soldAmount;\r\n    uint256 remainingTokens;\r\n    uint256 borrowedAssetLeftovers;\r\n  }\r\n\r\n  constructor(\r\n    ILendingPoolAddressesProvider addressesProvider,\r\n    IUniswapV2Router02 uniswapRouter,\r\n    address wethAddress\r\n  ) public BaseUniswapAdapter(addressesProvider, uniswapRouter, wethAddress) {}\r\n\r\n  /**\r\n   * @dev Liquidate a non-healthy position collateral-wise, with a Health Factor below 1, using Flash Loan and Uniswap to repay flash loan premium.\r\n   * - The caller (liquidator) with a flash loan covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk minus the flash loan premium.\r\n   * @param assets Address of asset to be swapped\r\n   * @param amounts Amount of the asset to be swapped\r\n   * @param premiums Fee of the flash loan\r\n   * @param initiator Address of the caller\r\n   * @param params Additional variadic field to include extra params. Expected parameters:\r\n   *   address collateralAsset The collateral asset to release and will be exchanged to pay the flash loan premium\r\n   *   address borrowedAsset The asset that must be covered\r\n   *   address user The user address with a Health Factor below 1\r\n   *   uint256 debtToCover The amount of debt to cover\r\n   *   bool useEthPath Use WETH as connector path between the collateralAsset and borrowedAsset at Uniswap\r\n   */\r\n  function executeOperation(\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata premiums,\r\n    address initiator,\r\n    bytes calldata params\r\n  ) external override returns (bool) {\r\n    require(msg.sender == address(LENDING_POOL), 'CALLER_MUST_BE_LENDING_POOL');\r\n\r\n    LiquidationParams memory decodedParams = _decodeParams(params);\r\n\r\n    require(assets.length == 1 && assets[0] == decodedParams.borrowedAsset, 'INCONSISTENT_PARAMS');\r\n\r\n    _liquidateAndSwap(\r\n      decodedParams.collateralAsset,\r\n      decodedParams.borrowedAsset,\r\n      decodedParams.user,\r\n      decodedParams.debtToCover,\r\n      decodedParams.useEthPath,\r\n      amounts[0],\r\n      premiums[0],\r\n      initiator\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev\r\n   * @param collateralAsset The collateral asset to release and will be exchanged to pay the flash loan premium\r\n   * @param borrowedAsset The asset that must be covered\r\n   * @param user The user address with a Health Factor below 1\r\n   * @param debtToCover The amount of debt to coverage, can be max(-1) to liquidate all possible debt\r\n   * @param useEthPath true if the swap needs to occur using ETH in the routing, false otherwise\r\n   * @param flashBorrowedAmount Amount of asset requested at the flash loan to liquidate the user position\r\n   * @param premium Fee of the requested flash loan\r\n   * @param initiator Address of the caller\r\n   */\r\n  function _liquidateAndSwap(\r\n    address collateralAsset,\r\n    address borrowedAsset,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool useEthPath,\r\n    uint256 flashBorrowedAmount,\r\n    uint256 premium,\r\n    address initiator\r\n  ) internal {\r\n    LiquidationCallLocalVars memory vars;\r\n    vars.initCollateralBalance = IERC20(collateralAsset).balanceOf(address(this));\r\n    if (collateralAsset != borrowedAsset) {\r\n      vars.initFlashBorrowedBalance = IERC20(borrowedAsset).balanceOf(address(this));\r\n\r\n      // Track leftover balance to rescue funds in case of external transfers into this contract\r\n      vars.borrowedAssetLeftovers = vars.initFlashBorrowedBalance.sub(flashBorrowedAmount);\r\n    }\r\n    vars.flashLoanDebt = flashBorrowedAmount.add(premium);\r\n\r\n    // Approve LendingPool to use debt token for liquidation\r\n    IERC20(borrowedAsset).approve(address(LENDING_POOL), debtToCover);\r\n\r\n    // Liquidate the user position and release the underlying collateral\r\n    LENDING_POOL.liquidationCall(collateralAsset, borrowedAsset, user, debtToCover, false);\r\n\r\n    // Discover the liquidated tokens\r\n    uint256 collateralBalanceAfter = IERC20(collateralAsset).balanceOf(address(this));\r\n\r\n    // Track only collateral released, not current asset balance of the contract\r\n    vars.diffCollateralBalance = collateralBalanceAfter.sub(vars.initCollateralBalance);\r\n\r\n    if (collateralAsset != borrowedAsset) {\r\n      // Discover flash loan balance after the liquidation\r\n      uint256 flashBorrowedAssetAfter = IERC20(borrowedAsset).balanceOf(address(this));\r\n\r\n      // Use only flash loan borrowed assets, not current asset balance of the contract\r\n      vars.diffFlashBorrowedBalance = flashBorrowedAssetAfter.sub(vars.borrowedAssetLeftovers);\r\n\r\n      // Swap released collateral into the debt asset, to repay the flash loan\r\n      vars.soldAmount = _swapTokensForExactTokens(\r\n        collateralAsset,\r\n        borrowedAsset,\r\n        vars.diffCollateralBalance,\r\n        vars.flashLoanDebt.sub(vars.diffFlashBorrowedBalance),\r\n        useEthPath\r\n      );\r\n      vars.remainingTokens = vars.diffCollateralBalance.sub(vars.soldAmount);\r\n    } else {\r\n      vars.remainingTokens = vars.diffCollateralBalance.sub(premium);\r\n    }\r\n\r\n    // Allow repay of flash loan\r\n    IERC20(borrowedAsset).approve(address(LENDING_POOL), vars.flashLoanDebt);\r\n\r\n    // Transfer remaining tokens to initiator\r\n    if (vars.remainingTokens > 0) {\r\n      IERC20(collateralAsset).transfer(initiator, vars.remainingTokens);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Decodes the information encoded in the flash loan params\r\n   * @param params Additional variadic field to include extra params. Expected parameters:\r\n   *   address collateralAsset The collateral asset to claim\r\n   *   address borrowedAsset The asset that must be covered and will be exchanged to pay the flash loan premium\r\n   *   address user The user address with a Health Factor below 1\r\n   *   uint256 debtToCover The amount of debt to cover\r\n   *   bool useEthPath Use WETH as connector path between the collateralAsset and borrowedAsset at Uniswap\r\n   * @return LiquidationParams struct containing decoded params\r\n   */\r\n  function _decodeParams(bytes memory params) internal pure returns (LiquidationParams memory) {\r\n    (\r\n      address collateralAsset,\r\n      address borrowedAsset,\r\n      address user,\r\n      uint256 debtToCover,\r\n      bool useEthPath\r\n    ) = abi.decode(params, (address, address, address, uint256, bool));\r\n\r\n    return LiquidationParams(collateralAsset, borrowedAsset, user, debtToCover, useEthPath);\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/upgradeability/InitializableAdminUpgradeabilityProxy.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport './BaseAdminUpgradeabilityProxy.sol';\r\nimport './InitializableUpgradeabilityProxy.sol';\r\n\r\n/**\r\n * @title InitializableAdminUpgradeabilityProxy\r\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for\r\n * initializing the implementation, admin, and init data.\r\n */\r\ncontract InitializableAdminUpgradeabilityProxy is\r\n  BaseAdminUpgradeabilityProxy,\r\n  InitializableUpgradeabilityProxy\r\n{\r\n  /**\r\n   * Contract initializer.\r\n   * @param logic address of the initial implementation.\r\n   * @param admin Address of the proxy administrator.\r\n   * @param data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n  function initialize(\r\n    address logic,\r\n    address admin,\r\n    bytes memory data\r\n  ) public payable {\r\n    require(_implementation() == address(0));\r\n    InitializableUpgradeabilityProxy.initialize(logic, data);\r\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\r\n    _setAdmin(admin);\r\n  }\r\n\r\n  /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\r\n    BaseAdminUpgradeabilityProxy._willFallback();\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/upgradeability/BaseAdminUpgradeabilityProxy.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport './UpgradeabilityProxy.sol';\r\n\r\n/**\r\n * @title BaseAdminUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks.\r\n * All external functions in this contract must be guarded by the\r\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n  /**\r\n   * @dev Emitted when the administration has been transferred.\r\n   * @param previousAdmin Address of the previous admin.\r\n   * @param newAdmin Address of the new admin.\r\n   */\r\n  event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n  /**\r\n   * @dev Storage slot with the admin of the contract.\r\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 internal constant ADMIN_SLOT =\r\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n  /**\r\n   * @dev Modifier to check whether the `msg.sender` is the admin.\r\n   * If it is, it will run the function. Otherwise, it will delegate the call\r\n   * to the implementation.\r\n   */\r\n  modifier ifAdmin() {\r\n    if (msg.sender == _admin()) {\r\n      _;\r\n    } else {\r\n      _fallback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return The address of the proxy admin.\r\n   */\r\n  function admin() external ifAdmin returns (address) {\r\n    return _admin();\r\n  }\r\n\r\n  /**\r\n   * @return The address of the implementation.\r\n   */\r\n  function implementation() external ifAdmin returns (address) {\r\n    return _implementation();\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the admin of the proxy.\r\n   * Only the current admin can call this function.\r\n   * @param newAdmin Address to transfer proxy administration to.\r\n   */\r\n  function changeAdmin(address newAdmin) external ifAdmin {\r\n    require(newAdmin != address(0), 'Cannot change the admin of a proxy to the zero address');\r\n    emit AdminChanged(_admin(), newAdmin);\r\n    _setAdmin(newAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy.\r\n   * Only the admin can call this function.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function upgradeTo(address newImplementation) external ifAdmin {\r\n    _upgradeTo(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy and call a function\r\n   * on the new implementation.\r\n   * This is useful to initialize the proxied contract.\r\n   * @param newImplementation Address of the new implementation.\r\n   * @param data Data to send as msg.data in the low level call.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   */\r\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\r\n    external\r\n    payable\r\n    ifAdmin\r\n  {\r\n    _upgradeTo(newImplementation);\r\n    (bool success, ) = newImplementation.delegatecall(data);\r\n    require(success);\r\n  }\r\n\r\n  /**\r\n   * @return adm The admin slot.\r\n   */\r\n  function _admin() internal view returns (address adm) {\r\n    bytes32 slot = ADMIN_SLOT;\r\n    //solium-disable-next-line\r\n    assembly {\r\n      adm := sload(slot)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the address of the proxy admin.\r\n   * @param newAdmin Address of the new proxy admin.\r\n   */\r\n  function _setAdmin(address newAdmin) internal {\r\n    bytes32 slot = ADMIN_SLOT;\r\n    //solium-disable-next-line\r\n    assembly {\r\n      sstore(slot, newAdmin)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n  function _willFallback() internal virtual override {\r\n    require(msg.sender != _admin(), 'Cannot call fallback function from the proxy admin');\r\n    super._willFallback();\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/upgradeability/UpgradeabilityProxy.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport './BaseUpgradeabilityProxy.sol';\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\r\n * implementation and init data.\r\n */\r\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n  /**\r\n   * @dev Contract constructor.\r\n   * @param _logic Address of the initial implementation.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n  constructor(address _logic, bytes memory _data) public payable {\r\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\r\n    _setImplementation(_logic);\r\n    if (_data.length > 0) {\r\n      (bool success, ) = _logic.delegatecall(_data);\r\n      require(success);\r\n    }\r\n  }\r\n}\r\n"
      },
      "contracts/dependencies/openzeppelin/upgradeability/AdminUpgradeabilityProxy.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport './BaseAdminUpgradeabilityProxy.sol';\r\n\r\n/**\r\n * @title AdminUpgradeabilityProxy\r\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for\r\n * initializing the implementation, admin, and init data.\r\n */\r\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\r\n  /**\r\n   * Contract constructor.\r\n   * @param _logic address of the initial implementation.\r\n   * @param _admin Address of the proxy administrator.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n  constructor(\r\n    address _logic,\r\n    address _admin,\r\n    bytes memory _data\r\n  ) public payable UpgradeabilityProxy(_logic, _data) {\r\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\r\n    _setAdmin(_admin);\r\n  }\r\n\r\n  /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\r\n    BaseAdminUpgradeabilityProxy._willFallback();\r\n  }\r\n}\r\n"
      },
      "contracts/protocol/configuration/LendingPoolAddressesProvider.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\r\n\r\n// Prettier ignore to prevent buidler flatter bug\r\n// prettier-ignore\r\nimport {InitializableImmutableAdminUpgradeabilityProxy} from '../libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol';\r\n\r\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider {\r\n  string private _marketId;\r\n  mapping(bytes32 => address) private _addresses;\r\n\r\n  bytes32 private constant LENDING_POOL = 'LENDING_POOL';\r\n  bytes32 private constant LENDING_POOL_CONFIGURATOR = 'LENDING_POOL_CONFIGURATOR';\r\n  bytes32 private constant POOL_ADMIN = 'POOL_ADMIN';\r\n  bytes32 private constant EMERGENCY_ADMIN = 'EMERGENCY_ADMIN';\r\n  bytes32 private constant LENDING_POOL_COLLATERAL_MANAGER = 'COLLATERAL_MANAGER';\r\n  bytes32 private constant PRICE_ORACLE = 'PRICE_ORACLE';\r\n  bytes32 private constant LENDING_RATE_ORACLE = 'LENDING_RATE_ORACLE';\r\n\r\n  constructor(string memory marketId) public {\r\n    _setMarketId(marketId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the id of the Aave market to which this contracts points to\r\n   * @return The market id\r\n   **/\r\n  function getMarketId() external view override returns (string memory) {\r\n    return _marketId;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows to set the market which this LendingPoolAddressesProvider represents\r\n   * @param marketId The market id\r\n   */\r\n  function setMarketId(string memory marketId) external override onlyOwner {\r\n    _setMarketId(marketId);\r\n  }\r\n\r\n  /**\r\n   * @dev General function to update the implementation of a proxy registered with\r\n   * certain `id`. If there is no proxy registered, it will instantiate one and\r\n   * set as implementation the `implementationAddress`\r\n   * IMPORTANT Use this function carefully, only for ids that don't have an explicit\r\n   * setter function, in order to avoid unexpected consequences\r\n   * @param id The id\r\n   * @param implementationAddress The address of the new implementation\r\n   */\r\n  function setAddressAsProxy(bytes32 id, address implementationAddress)\r\n    external\r\n    override\r\n    onlyOwner\r\n  {\r\n    _updateImpl(id, implementationAddress);\r\n    emit AddressSet(id, implementationAddress, true);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets an address for an id replacing the address saved in the addresses map\r\n   * IMPORTANT Use this function carefully, as it will do a hard replacement\r\n   * @param id The id\r\n   * @param newAddress The address to set\r\n   */\r\n  function setAddress(bytes32 id, address newAddress) external override onlyOwner {\r\n    _addresses[id] = newAddress;\r\n    emit AddressSet(id, newAddress, false);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an address by id\r\n   * @return The address\r\n   */\r\n  function getAddress(bytes32 id) public view override returns (address) {\r\n    return _addresses[id];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the LendingPool proxy\r\n   * @return The LendingPool proxy address\r\n   **/\r\n  function getLendingPool() external view override returns (address) {\r\n    return getAddress(LENDING_POOL);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the implementation of the LendingPool, or creates the proxy\r\n   * setting the new `pool` implementation on the first time calling it\r\n   * @param pool The new LendingPool implementation\r\n   **/\r\n  function setLendingPoolImpl(address pool) external override onlyOwner {\r\n    _updateImpl(LENDING_POOL, pool);\r\n    emit LendingPoolUpdated(pool);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the LendingPoolConfigurator proxy\r\n   * @return The LendingPoolConfigurator proxy address\r\n   **/\r\n  function getLendingPoolConfigurator() external view override returns (address) {\r\n    return getAddress(LENDING_POOL_CONFIGURATOR);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the implementation of the LendingPoolConfigurator, or creates the proxy\r\n   * setting the new `configurator` implementation on the first time calling it\r\n   * @param configurator The new LendingPoolConfigurator implementation\r\n   **/\r\n  function setLendingPoolConfiguratorImpl(address configurator) external override onlyOwner {\r\n    _updateImpl(LENDING_POOL_CONFIGURATOR, configurator);\r\n    emit LendingPoolConfiguratorUpdated(configurator);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the LendingPoolCollateralManager. Since the manager is used\r\n   * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\r\n   * the addresses are changed directly\r\n   * @return The address of the LendingPoolCollateralManager\r\n   **/\r\n\r\n  function getLendingPoolCollateralManager() external view override returns (address) {\r\n    return getAddress(LENDING_POOL_COLLATERAL_MANAGER);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the address of the LendingPoolCollateralManager\r\n   * @param manager The new LendingPoolCollateralManager address\r\n   **/\r\n  function setLendingPoolCollateralManager(address manager) external override onlyOwner {\r\n    _addresses[LENDING_POOL_COLLATERAL_MANAGER] = manager;\r\n    emit LendingPoolCollateralManagerUpdated(manager);\r\n  }\r\n\r\n  /**\r\n   * @dev The functions below are getters/setters of addresses that are outside the context\r\n   * of the protocol hence the upgradable proxy pattern is not used\r\n   **/\r\n\r\n  function getPoolAdmin() external view override returns (address) {\r\n    return getAddress(POOL_ADMIN);\r\n  }\r\n\r\n  function setPoolAdmin(address admin) external override onlyOwner {\r\n    _addresses[POOL_ADMIN] = admin;\r\n    emit ConfigurationAdminUpdated(admin);\r\n  }\r\n\r\n  function getEmergencyAdmin() external view override returns (address) {\r\n    return getAddress(EMERGENCY_ADMIN);\r\n  }\r\n\r\n  function setEmergencyAdmin(address emergencyAdmin) external override onlyOwner {\r\n    _addresses[EMERGENCY_ADMIN] = emergencyAdmin;\r\n    emit EmergencyAdminUpdated(emergencyAdmin);\r\n  }\r\n\r\n  function getPriceOracle() external view override returns (address) {\r\n    return getAddress(PRICE_ORACLE);\r\n  }\r\n\r\n  function setPriceOracle(address priceOracle) external override onlyOwner {\r\n    _addresses[PRICE_ORACLE] = priceOracle;\r\n    emit PriceOracleUpdated(priceOracle);\r\n  }\r\n\r\n  function getLendingRateOracle() external view override returns (address) {\r\n    return getAddress(LENDING_RATE_ORACLE);\r\n  }\r\n\r\n  function setLendingRateOracle(address lendingRateOracle) external override onlyOwner {\r\n    _addresses[LENDING_RATE_ORACLE] = lendingRateOracle;\r\n    emit LendingRateOracleUpdated(lendingRateOracle);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to update the implementation of a specific proxied component of the protocol\r\n   * - If there is no proxy registered in the given `id`, it creates the proxy setting `newAdress`\r\n   *   as implementation and calls the initialize() function on the proxy\r\n   * - If there is already a proxy registered, it just updates the implementation to `newAddress` and\r\n   *   calls the initialize() function via upgradeToAndCall() in the proxy\r\n   * @param id The id of the proxy to be updated\r\n   * @param newAddress The address of the new implementation\r\n   **/\r\n  function _updateImpl(bytes32 id, address newAddress) internal {\r\n    address payable proxyAddress = payable(_addresses[id]);\r\n\r\n    InitializableImmutableAdminUpgradeabilityProxy proxy =\r\n      InitializableImmutableAdminUpgradeabilityProxy(proxyAddress);\r\n    bytes memory params = abi.encodeWithSignature('initialize(address)', address(this));\r\n\r\n    if (proxyAddress == address(0)) {\r\n      proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this));\r\n      proxy.initialize(newAddress, params);\r\n      _addresses[id] = address(proxy);\r\n      emit ProxyCreated(id, address(proxy));\r\n    } else {\r\n      proxy.upgradeToAndCall(newAddress, params);\r\n    }\r\n  }\r\n\r\n  function _setMarketId(string memory marketId) internal {\r\n    _marketId = marketId;\r\n    emit MarketIdSet(marketId);\r\n  }\r\n}\r\n"
      },
      "contracts/deployments/ATokensAndRatesHelper.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {LendingPool} from '../protocol/lendingpool/LendingPool.sol';\r\nimport {\r\n  LendingPoolAddressesProvider\r\n} from '../protocol/configuration/LendingPoolAddressesProvider.sol';\r\nimport {LendingPoolConfigurator} from '../protocol/lendingpool/LendingPoolConfigurator.sol';\r\nimport {AToken} from '../protocol/tokenization/AToken.sol';\r\nimport {\r\n  DefaultReserveInterestRateStrategy\r\n} from '../protocol/lendingpool/DefaultReserveInterestRateStrategy.sol';\r\nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol';\r\nimport {StringLib} from './StringLib.sol';\r\n\r\ncontract ATokensAndRatesHelper is Ownable {\r\n  address payable private pool;\r\n  address private addressesProvider;\r\n  address private poolConfigurator;\r\n  event deployedContracts(address aToken, address strategy);\r\n\r\n  struct InitDeploymentInput {\r\n    address asset;\r\n    uint256[6] rates;\r\n  }\r\n\r\n  struct ConfigureReserveInput {\r\n    address asset;\r\n    uint256 baseLTV;\r\n    uint256 liquidationThreshold;\r\n    uint256 liquidationBonus;\r\n    uint256 reserveFactor;\r\n    bool stableBorrowingEnabled;\r\n  }\r\n\r\n  constructor(\r\n    address payable _pool,\r\n    address _addressesProvider,\r\n    address _poolConfigurator\r\n  ) public {\r\n    pool = _pool;\r\n    addressesProvider = _addressesProvider;\r\n    poolConfigurator = _poolConfigurator;\r\n  }\r\n\r\n  function initDeployment(InitDeploymentInput[] calldata inputParams) external onlyOwner {\r\n    for (uint256 i = 0; i < inputParams.length; i++) {\r\n      emit deployedContracts(\r\n        address(new AToken()),\r\n        address(\r\n          new DefaultReserveInterestRateStrategy(\r\n            LendingPoolAddressesProvider(addressesProvider),\r\n            inputParams[i].rates[0],\r\n            inputParams[i].rates[1],\r\n            inputParams[i].rates[2],\r\n            inputParams[i].rates[3],\r\n            inputParams[i].rates[4],\r\n            inputParams[i].rates[5]\r\n          )\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  function configureReserves(ConfigureReserveInput[] calldata inputParams) external onlyOwner {\r\n    LendingPoolConfigurator configurator = LendingPoolConfigurator(poolConfigurator);\r\n    for (uint256 i = 0; i < inputParams.length; i++) {\r\n      configurator.configureReserveAsCollateral(\r\n        inputParams[i].asset,\r\n        inputParams[i].baseLTV,\r\n        inputParams[i].liquidationThreshold,\r\n        inputParams[i].liquidationBonus\r\n      );\r\n\r\n      configurator.enableBorrowingOnReserve(\r\n        inputParams[i].asset,\r\n        inputParams[i].stableBorrowingEnabled\r\n      );\r\n      configurator.setReserveFactor(inputParams[i].asset, inputParams[i].reserveFactor);\r\n    }\r\n  }\r\n}\r\n"
      },
      "contracts/deployments/StringLib.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nlibrary StringLib {\r\n  function concat(string memory a, string memory b) internal pure returns (string memory) {\r\n    return string(abi.encodePacked(a, b));\r\n  }\r\n}\r\n"
      },
      "contracts/deployments/StableAndVariableTokensHelper.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {StableDebtToken} from '../protocol/tokenization/StableDebtToken.sol';\r\nimport {VariableDebtToken} from '../protocol/tokenization/VariableDebtToken.sol';\r\nimport {LendingRateOracle} from '../mocks/oracle/LendingRateOracle.sol';\r\nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol';\r\nimport {StringLib} from './StringLib.sol';\r\n\r\ncontract StableAndVariableTokensHelper is Ownable {\r\n  address payable private pool;\r\n  address private addressesProvider;\r\n  event deployedContracts(address stableToken, address variableToken);\r\n\r\n  constructor(address payable _pool, address _addressesProvider) public {\r\n    pool = _pool;\r\n    addressesProvider = _addressesProvider;\r\n  }\r\n\r\n  function initDeployment(address[] calldata tokens, string[] calldata symbols) external onlyOwner {\r\n    require(tokens.length == symbols.length, 'Arrays not same length');\r\n    require(pool != address(0), 'Pool can not be zero address');\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      emit deployedContracts(address(new StableDebtToken()), address(new VariableDebtToken()));\r\n    }\r\n  }\r\n\r\n  function setOracleBorrowRates(\r\n    address[] calldata assets,\r\n    uint256[] calldata rates,\r\n    address oracle\r\n  ) external onlyOwner {\r\n    require(assets.length == rates.length, 'Arrays not same length');\r\n\r\n    for (uint256 i = 0; i < assets.length; i++) {\r\n      // LendingRateOracle owner must be this contract\r\n      LendingRateOracle(oracle).setMarketBorrowRate(assets[i], rates[i]);\r\n    }\r\n  }\r\n\r\n  function setOracleOwnership(address oracle, address admin) external onlyOwner {\r\n    require(admin != address(0), 'owner can not be zero');\r\n    require(LendingRateOracle(oracle).owner() == address(this), 'helper is not owner');\r\n    LendingRateOracle(oracle).transferOwnership(admin);\r\n  }\r\n}\r\n"
      },
      "contracts/mocks/oracle/LendingRateOracle.sol": {
        "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\n\r\nimport {ILendingRateOracle} from '../../interfaces/ILendingRateOracle.sol';\r\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\r\n\r\ncontract LendingRateOracle is ILendingRateOracle, Ownable {\r\n  mapping(address => uint256) borrowRates;\r\n  mapping(address => uint256) liquidityRates;\r\n\r\n  function getMarketBorrowRate(address _asset) external view override returns (uint256) {\r\n    return borrowRates[_asset];\r\n  }\r\n\r\n  function setMarketBorrowRate(address _asset, uint256 _rate) external override onlyOwner {\r\n    borrowRates[_asset] = _rate;\r\n  }\r\n\r\n  function getMarketLiquidityRate(address _asset) external view returns (uint256) {\r\n    return liquidityRates[_asset];\r\n  }\r\n\r\n  function setMarketLiquidityRate(address _asset, uint256 _rate) external onlyOwner {\r\n    liquidityRates[_asset] = _rate;\r\n  }\r\n}\r\n"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "evmVersion": "istanbul",
      "outputSelection": {
        "*": {
          "*": [
            "metadata",
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers"
          ],
          "": ["ast"]
        }
      }
    }
  },
  "output": {
    "contracts": {
      "contracts/protocol/lendingpool/LendingPool.sol": {
        "LendingPool": {
          "metadata": "{\"compiler\":{\"version\":\"0.6.12+commit.27d51765\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowRateMode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"referral\",\"type\":\"uint16\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"referral\",\"type\":\"uint16\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"referralCode\",\"type\":\"uint16\"}],\"name\":\"FlashLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"debtAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtToCover\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidatedCollateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"receiveAToken\",\"type\":\"bool\"}],\"name\":\"LiquidationCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RebalanceStableBorrowRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"repayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stableBorrowRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"variableBorrowRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"variableBorrowIndex\",\"type\":\"uint256\"}],\"name\":\"ReserveDataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ReserveUsedAsCollateralDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ReserveUsedAsCollateralEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateMode\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FLASHLOAN_PREMIUM_TOTAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LENDINGPOOL_REVISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_NUMBER_RESERVES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_STABLE_RATE_BORROW_SIZE_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRateMode\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"referralCode\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"referralCode\",\"type\":\"uint16\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceFromBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceToBefore\",\"type\":\"uint256\"}],\"name\":\"finalizeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"modes\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"referralCode\",\"type\":\"uint16\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddressesProvider\",\"outputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getConfiguration\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.ReserveConfigurationMap\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getReserveData\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.ReserveConfigurationMap\",\"name\":\"configuration\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"liquidityIndex\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"variableBorrowIndex\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentLiquidityRate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentVariableBorrowRate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentStableBorrowRate\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"aTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stableDebtTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"variableDebtTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interestRateStrategyAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"internalType\":\"struct DataTypes.ReserveData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getReserveNormalizedIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getReserveNormalizedVariableDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReservesList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserAccountData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCollateralETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebtETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableBorrowsETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLiquidationThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"healthFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserConfiguration\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.UserConfigurationMap\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stableDebtAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"variableDebtAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interestRateStrategyAddress\",\"type\":\"address\"}],\"name\":\"initReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"debtAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtToCover\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"receiveAToken\",\"type\":\"bool\"}],\"name\":\"liquidationCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"rebalanceStableBorrowRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateMode\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"}],\"name\":\"repay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"configuration\",\"type\":\"uint256\"}],\"name\":\"setConfiguration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rateStrategyAddress\",\"type\":\"address\"}],\"name\":\"setReserveInterestRateStrategyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useAsCollateral\",\"type\":\"bool\"}],\"name\":\"setUserUseReserveAsCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rateMode\",\"type\":\"uint256\"}],\"name\":\"swapBorrowRateMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Aave*\",\"details\":\"Main point of interaction with an Aave protocol's market - Users can:   # Deposit   # Withdraw   # Borrow   # Repay   # Swap their loans between variable and stable rate   # Enable/disable their deposits as collateral rebalance stable rate borrow positions   # Liquidate positions   # Execute Flash Loans - To be covered by a proxy contract, owned by the LendingPoolAddressesProvider of the specific market - All admin functions are callable by the LendingPoolConfigurator contract defined also in the   LendingPoolAddressesProvider\",\"kind\":\"dev\",\"methods\":{\"FLASHLOAN_PREMIUM_TOTAL()\":{\"details\":\"Returns the fee on flash loans \"},\"MAX_NUMBER_RESERVES()\":{\"details\":\"Returns the maximum number of reserves supported to be listed in this LendingPool\"},\"MAX_STABLE_RATE_BORROW_SIZE_PERCENT()\":{\"details\":\"Returns the percentage of available liquidity that can be borrowed at once at stable rate\"},\"borrow(address,uint256,uint256,uint16,address)\":{\"details\":\"Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower already deposited enough collateral, or he was given enough allowance by a credit delegator on the corresponding debt token (StableDebtToken or VariableDebtToken) - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet   and 100 stable/variable debt tokens, depending on the `interestRateMode`\",\"params\":{\"amount\":\"The amount to be borrowed\",\"asset\":\"The address of the underlying asset to borrow\",\"interestRateMode\":\"The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\",\"onBehalfOf\":\"Address of the user who will receive the debt. Should be the address of the borrower itself calling the function if he wants to borrow against his own collateral, or the address of the credit delegator if he has been given credit delegation allowance*\",\"referralCode\":\"Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man\"}},\"deposit(address,uint256,address,uint16)\":{\"details\":\"Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens. - E.g. User deposits 100 USDC and gets in return 100 aUSDC\",\"params\":{\"amount\":\"The amount to be deposited\",\"asset\":\"The address of the underlying asset to deposit\",\"onBehalfOf\":\"The address that will receive the aTokens, same as msg.sender if the user   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens   is a different wallet\",\"referralCode\":\"Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man*\"}},\"finalizeTransfer(address,address,address,uint256,uint256,uint256)\":{\"details\":\"Validates and finalizes an aToken transfer - Only callable by the overlying aToken of the `asset`\",\"params\":{\"amount\":\"The amount being transferred/withdrawn\",\"asset\":\"The address of the underlying asset of the aToken\",\"balanceFromBefore\":\"The aToken balance of the `from` user before the transfer\",\"balanceToBefore\":\"The aToken balance of the `to` user before the transfer\",\"from\":\"The user from which the aTokens are transferred\",\"to\":\"The user receiving the aTokens\"}},\"flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16)\":{\"details\":\"Allows smartcontracts to access the liquidity of the pool within one transaction, as long as the amount taken plus a fee is returned. IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration. For further details please visit https://developers.aave.com\",\"params\":{\"amounts\":\"The amounts amounts being flash-borrowed\",\"assets\":\"The addresses of the assets being flash-borrowed\",\"modes\":\"Types of the debt to open if the flash loan is not returned:   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\",\"onBehalfOf\":\"The address  that will receive the debt in the case of using on `modes` 1 or 2\",\"params\":\"Variadic packed params to pass to the receiver as extra information\",\"receiverAddress\":\"The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\",\"referralCode\":\"Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man*\"}},\"getAddressesProvider()\":{\"details\":\"Returns the cached LendingPoolAddressesProvider connected to this contract*\"},\"getConfiguration(address)\":{\"details\":\"Returns the configuration of the reserve\",\"params\":{\"asset\":\"The address of the underlying asset of the reserve\"},\"returns\":{\"_0\":\"The configuration of the reserve*\"}},\"getReserveData(address)\":{\"details\":\"Returns the state and configuration of the reserve\",\"params\":{\"asset\":\"The address of the underlying asset of the reserve\"},\"returns\":{\"_0\":\"The state of the reserve*\"}},\"getReserveNormalizedIncome(address)\":{\"details\":\"Returns the normalized income per unit of asset\",\"params\":{\"asset\":\"The address of the underlying asset of the reserve\"},\"returns\":{\"_0\":\"The reserve's normalized income\"}},\"getReserveNormalizedVariableDebt(address)\":{\"details\":\"Returns the normalized variable debt per unit of asset\",\"params\":{\"asset\":\"The address of the underlying asset of the reserve\"},\"returns\":{\"_0\":\"The reserve normalized variable debt\"}},\"getReservesList()\":{\"details\":\"Returns the list of the initialized reserves*\"},\"getUserAccountData(address)\":{\"details\":\"Returns the user account data across all the reserves\",\"params\":{\"user\":\"The address of the user\"},\"returns\":{\"availableBorrowsETH\":\"the borrowing power left of the user\",\"currentLiquidationThreshold\":\"the liquidation threshold of the user\",\"healthFactor\":\"the current health factor of the user*\",\"ltv\":\"the loan to value of the user\",\"totalCollateralETH\":\"the total collateral in ETH of the user\",\"totalDebtETH\":\"the total debt in ETH of the user\"}},\"getUserConfiguration(address)\":{\"details\":\"Returns the configuration of the user across all the reserves\",\"params\":{\"user\":\"The user address\"},\"returns\":{\"_0\":\"The configuration of the user*\"}},\"initReserve(address,address,address,address,address)\":{\"details\":\"Initializes a reserve, activating it, assigning an aToken and debt tokens and an interest rate strategy - Only callable by the LendingPoolConfigurator contract\",\"params\":{\"aTokenAddress\":\"The address of the VariableDebtToken that will be assigned to the reserve\",\"asset\":\"The address of the underlying asset of the reserve\",\"interestRateStrategyAddress\":\"The address of the interest rate strategy contract*\",\"stableDebtAddress\":\"The address of the StableDebtToken that will be assigned to the reserve\"}},\"initialize(address)\":{\"details\":\"Function is invoked by the proxy contract when the LendingPool contract is added to the LendingPoolAddressesProvider of the market. - Caching the address of the LendingPoolAddressesProvider in order to reduce gas consumption   on subsequent operations\",\"params\":{\"provider\":\"The address of the LendingPoolAddressesProvider*\"}},\"liquidationCall(address,address,address,uint256,bool)\":{\"details\":\"Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1 - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\",\"params\":{\"collateralAsset\":\"The address of the underlying asset used as collateral, to receive as result of the liquidation\",\"debtAsset\":\"The address of the underlying borrowed asset to be repaid with the liquidation\",\"debtToCover\":\"The debt amount of borrowed `asset` the liquidator wants to cover\",\"receiveAToken\":\"`true` if the liquidators wants to receive the collateral aTokens, `false` if he wants to receive the underlying collateral asset directly*\",\"user\":\"The address of the borrower getting liquidated\"}},\"paused()\":{\"details\":\"Returns if the LendingPool is paused\"},\"rebalanceStableBorrowRate(address,address)\":{\"details\":\"Rebalances the stable interest rate of a user to the current stable rate defined on the reserve. - Users can be rebalanced if the following conditions are satisfied:     1. Usage ratio is above 95%     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been        borrowed at a stable rate and depositors are not earning enough\",\"params\":{\"asset\":\"The address of the underlying asset borrowed\",\"user\":\"The address of the user to be rebalanced*\"}},\"repay(address,uint256,uint256,address)\":{\"params\":{\"amount\":\"The amount to repay - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\",\"asset\":\"The address of the borrowed underlying asset previously borrowed\",\"onBehalfOf\":\"Address of the user who will get his debt reduced/removed. Should be the address of the user calling the function if he wants to reduce/remove his own debt, or the address of any other other borrower whose debt should be removed\",\"rateMode\":\"The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\"},\"returns\":{\"_0\":\"The final amount repaid*\"}},\"setConfiguration(address,uint256)\":{\"details\":\"Sets the configuration bitmap of the reserve as a whole - Only callable by the LendingPoolConfigurator contract\",\"params\":{\"asset\":\"The address of the underlying asset of the reserve\",\"configuration\":\"The new configuration bitmap*\"}},\"setPause(bool)\":{\"details\":\"Set the _pause state of a reserve - Only callable by the LendingPoolConfigurator contract\",\"params\":{\"val\":\"`true` to pause the reserve, `false` to un-pause it\"}},\"setReserveInterestRateStrategyAddress(address,address)\":{\"details\":\"Updates the address of the interest rate strategy contract - Only callable by the LendingPoolConfigurator contract\",\"params\":{\"asset\":\"The address of the underlying asset of the reserve\",\"rateStrategyAddress\":\"The address of the interest rate strategy contract*\"}},\"setUserUseReserveAsCollateral(address,bool)\":{\"details\":\"Allows depositors to enable/disable a specific deposited asset as collateral\",\"params\":{\"asset\":\"The address of the underlying asset deposited\",\"useAsCollateral\":\"`true` if the user wants to use the deposit as collateral, `false` otherwise*\"}},\"swapBorrowRateMode(address,uint256)\":{\"details\":\"Allows a borrower to swap his debt between stable and variable mode, or viceversa\",\"params\":{\"asset\":\"The address of the underlying asset borrowed\",\"rateMode\":\"The rate mode that the user wants to swap to*\"}},\"withdraw(address,uint256,address)\":{\"details\":\"Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\",\"params\":{\"amount\":\"The underlying amount to be withdrawn   - Send the value type(uint256).max in order to withdraw the whole aToken balance\",\"asset\":\"The address of the underlying asset to withdraw\",\"to\":\"Address that will receive the underlying, same as msg.sender if the user   wants to receive it on his own wallet, or a different address if the beneficiary is a   different wallet\"},\"returns\":{\"_0\":\"The final amount withdrawn*\"}}},\"title\":\"LendingPool contract\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"repay(address,uint256,uint256,address)\":{\"notice\":\"Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/lendingpool/LendingPool.sol\":\"LendingPool\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/dependencies/openzeppelin/contracts/Address.sol\":{\"keccak256\":\"0x71a8ea40617f961a5aef4129be273aaf285eb3a1fa6ad66a53aeec0768fea56b\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://4f4ebe707d00ef5573795c4020df59fe131799b0c39a4e44a79567f249287b66\",\"dweb:/ipfs/QmdjsoYUuKKkUjkjxf97SjkLNGYbaU6PDXkerhb7P83uuh\"]},\"contracts/dependencies/openzeppelin/contracts/IERC20.sol\":{\"keccak256\":\"0xe9d8994b4b126042dd702600c37635bb16a379a658bc0248bedb951befb95df7\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://895dd646d5fd895512ece68ad3faa3fa515130f2d1e4f103c83db32758ca369e\",\"dweb:/ipfs/QmRGGCniMXoig91GemkXb8ookxDy8dx2WCfwWwivuFXGVN\"]},\"contracts/dependencies/openzeppelin/contracts/SafeERC20.sol\":{\"keccak256\":\"0xd2f21401b1f030221da8eb167adb22a1cff47d7f2ef23dd34a72f05543d23aca\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://24b5c9a940febf40712ce6d9b21dc6e84e6f8112e8e8bcee811520e9df33ec27\",\"dweb:/ipfs/QmV23WWJ55wLuWKigdR1cFQYQJaBnQhEWrUrm7o4kx6stC\"]},\"contracts/dependencies/openzeppelin/contracts/SafeMath.sol\":{\"keccak256\":\"0x491d2b7ab89a7acf1f305dc70cc3a933136bd62c6e49cfa4e70e3fd2e8dce58d\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://9031f0f7a8e1394b7f75bf5a6bfa22eddbbb8e4e7716cb31f11a90645d5cde19\",\"dweb:/ipfs/QmRFfZbPnosAXi31crVuus7cTwu8FoJK1gfaKnNZX22J33\"]},\"contracts/flashloan/interfaces/IFlashLoanReceiver.sol\":{\"keccak256\":\"0xe1c2f302af5a79dcf290e08d0f8b8d6b91283ede7b1f855f6786bd92c4ec470f\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://7a203b669e2bb5290d5ab004efd5aa78ec3d68d1ab786c4f34dd85fbe421e79d\",\"dweb:/ipfs/QmQ6zxo5Qa3d8eC3DfnN9VgcVct7mFT1QSLFpMrBPo66do\"]},\"contracts/interfaces/IAToken.sol\":{\"keccak256\":\"0x29dcaf9dec145b318caebd1a1545734ebae5b2e1d2f9e3750f39f57382ddff34\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://5d769acdd7c9fd1a64f68b809a72a5eaa1977bb81acd093dd07f788f522614db\",\"dweb:/ipfs/QmURP4LVbyxc9FwcjHGoJpP655vdPsz2oGksU61iCt7LMZ\"]},\"contracts/interfaces/IAaveIncentivesController.sol\":{\"keccak256\":\"0xc9d3e3471450a33f0966db6e760980ed3c9f0d7d94bdddf65844555b901065e2\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://6f6ec86eb241d9c56bb6a6e79fce09056c5c08a5c232a8ac8e210f8909e883cd\",\"dweb:/ipfs/QmS3NcFHek6GK5m8DVfBahazikX3hQzgfsSLZ3KV8to1Yv\"]},\"contracts/interfaces/IInitializableAToken.sol\":{\"keccak256\":\"0x1200a1b2aefcee481fbdcda5017bce8edff8072e8e543c68144f687c11e0d45f\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://d7dadeaf90754265d7f1dfdc0f229950d400ebf81ab4b5f62fc9e087ea2b7c50\",\"dweb:/ipfs/QmQGS3qoBD8wpFchuD4H79MkuAGvY71yrJfT3uCLpN1JwZ\"]},\"contracts/interfaces/IInitializableDebtToken.sol\":{\"keccak256\":\"0x81138cd58dfee7d2917b7ac215dde9153f8f7f3fa6130ec3ef9a0484782d910f\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://7fa584bbae040701d0650143bc7cfd17768d393ff790ca9c174b44af2b821f4b\",\"dweb:/ipfs/QmUvS8FL73GfQ9aHwZqb5N6qgtUvZKCMGGJ1Rv837naD2h\"]},\"contracts/interfaces/ILendingPool.sol\":{\"keccak256\":\"0xc89e087e3c8b3b8f5c536e5d4341c85449c176deb695200c99fb4eeb92093d8d\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://6ffe338e88a1a19c2d6e9539bdc8190fc41e0b626059236e12a875c59ea64045\",\"dweb:/ipfs/QmW1sqddCUcJQGG81gtYZYRc6PRMmvfp62KhhVEmVUNKF3\"]},\"contracts/interfaces/ILendingPoolAddressesProvider.sol\":{\"keccak256\":\"0xb11c734236fb9f38a88162b487be7eea4a344b925a9c8ecf550ac2bd1b590b1c\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://b7a9d03cbf8007f82fdb0bdbd703afa6eef644e05f95bc2c4625c46279e61b19\",\"dweb:/ipfs/QmQ48r9jZMyjjynXTdnvBEajnQXAs6xEuJx7LzJAnaa2iW\"]},\"contracts/interfaces/IPriceOracleGetter.sol\":{\"keccak256\":\"0x29106cf3c1d26c868870f128bb6e7f41b2b57a79882177fe8061919680d6ccee\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://151c38c46401cd52e1cdc2d7afc531ae36e96e74fa8e90c1508549bd2c24fe6e\",\"dweb:/ipfs/QmSXA7HWy56BRipEpyp8T3TrqtV3p7X5Ant6ixksKscADS\"]},\"contracts/interfaces/IReserveInterestRateStrategy.sol\":{\"keccak256\":\"0x0ab046c2e0e37b742d7224033bf4005b9d78ddfc9b1f7a5a8528c07091d3f08e\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://3b216c57478c3ee9140f01fcbf76adbf2264830d9de1bf1ebae6579759c4e549\",\"dweb:/ipfs/QmV66iyNj8nhzQMJNJK4gqm2XVSwDkFegn8v2Y3fiTCqrc\"]},\"contracts/interfaces/IScaledBalanceToken.sol\":{\"keccak256\":\"0x8a30667a00d1d6f95f4a44cf33d1f5869153325395fee603957882ba0a5734ed\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://cfeae32aa78f6f52fdda54dd6536b0fb5d341f8341353b40271f03a8fe957fab\",\"dweb:/ipfs/QmPq5x5kxQr3NSJhBj4F2fYEUeMja4NW48LB5XHAsJJ4XY\"]},\"contracts/interfaces/IStableDebtToken.sol\":{\"keccak256\":\"0x72ad72d5d442b637ad08aee86e6aa3091db623c717cb4ffb2b76e826e6fcb097\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://1b682b64bf0594f2063a7ed196a2f6a1c76c35cc315ea447e650d3042c93dda6\",\"dweb:/ipfs/QmQ15ky7qKHAvcg9qEiSgpsiV2H2mJ4mzFHkctghq6ksNB\"]},\"contracts/interfaces/IVariableDebtToken.sol\":{\"keccak256\":\"0xe881d8a4659119d87c5a9f55bd53d05e6e9c23d943519e03195575d1d6146531\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://dcbacfbaccd453f57df15dc489a43a1304e16f0c5d77b3cc8b0b650ab6e027ca\",\"dweb:/ipfs/QmXyLiEfXkdYHqtw8vkjhRKgPV8d4bgVVL2Ep6JQqd1TuZ\"]},\"contracts/protocol/lendingpool/LendingPool.sol\":{\"keccak256\":\"0xd76a4e477ba30669059b80f7ae1f911baf60bdac2faa7af0a1bfc371ac695994\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://8c20cf4ab811a3bb45c4e0893bd6f1f043d1336601685f005604e306651dc7a3\",\"dweb:/ipfs/QmZjt81s8y7texgEyKp1k1GzGYvuziHUB8Cdy1qgHftKLL\"]},\"contracts/protocol/lendingpool/LendingPoolStorage.sol\":{\"keccak256\":\"0xf752436a4a44721be2185f04c2b87a12b26100480d5eecb696c6d36d38a48b4c\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://7a8e0460593807f790afc066c461718e75303d824005dbf70582cfaf1157b59f\",\"dweb:/ipfs/QmRo6iEMXKoxsYVLLpc5QwZbRWNA1YA9hXYQpkN7BHzTH1\"]},\"contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol\":{\"keccak256\":\"0x316b26239f6e8059b75ddb7437a840ef85eae15802d653d11f81ccee00b1be25\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://9f1c759a8a51da7f5778d77b6fd9b1124465358596d6ea93b6c274b876153126\",\"dweb:/ipfs/QmQFp6h52he8DVE4JNMDHCHh8dKngvWSTJmxc2L3QYg6WD\"]},\"contracts/protocol/libraries/configuration/ReserveConfiguration.sol\":{\"keccak256\":\"0x124285f1252cb46e9cd89b2590cebb1cfdbd1af774db939d37a0b2129e303fab\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://bff49de86e978ed1fbc553b9fb24370a34af0b3c15b6e2749c2b37f94538c4cc\",\"dweb:/ipfs/QmZeEiLm8Lr9q8XB5yMVGu8TNGyZ6UYLwt3csJgBamQ2g3\"]},\"contracts/protocol/libraries/configuration/UserConfiguration.sol\":{\"keccak256\":\"0x53c4afcea96b2cb7b11d71bc7d58f0cce9d2fdf93018d2297544afb7d55ed805\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://b30ce71881b90092856126295cc494b0e1074a019dda3c1cd2cd2c6160c0aa12\",\"dweb:/ipfs/Qme36YprHFbqcd1n26Xg1HQ3SVBKXdhSkyXdqVw2FDrFcb\"]},\"contracts/protocol/libraries/helpers/Errors.sol\":{\"keccak256\":\"0xa7c9fa7a4ab679ac293d28fd4a1cfb0ab1fba157ab2665b6969076f37aea5539\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://393460ee111be40884096d511eda7013903fd96b9eb00225359d0ceca173bf27\",\"dweb:/ipfs/QmQUDMp3ja41iCppkT7vgkQJTFLmo4Kz2hTsDsydxMJgUT\"]},\"contracts/protocol/libraries/helpers/Helpers.sol\":{\"keccak256\":\"0xeb3b1daae775e1bcd7fcda0fa21500279fffbb615e84cd3d04da806304a244d9\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://f3d8d4fb79d770c038c6331660dc2c4df1f8413b445d934634c368c853e2c1d8\",\"dweb:/ipfs/QmaUUAp9iiDi1VuxKA86X97GZ1FPZWTwxmMBjxCQddFGrX\"]},\"contracts/protocol/libraries/logic/GenericLogic.sol\":{\"keccak256\":\"0x3d7a092555708cf13a430d8f78c6989535c258d413eef1726f1df44734c5122b\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://609f0f63abab8e2b49e0cc31fb3ae1b45d6805636ddf133e691e3c18df3c13e9\",\"dweb:/ipfs/QmYXYAHimJWzu29FM5AjVQAFRKP4wPTsDgZmPpoV9P9xUU\"]},\"contracts/protocol/libraries/logic/ReserveLogic.sol\":{\"keccak256\":\"0x3d525227caef23a05d5653067f49dba59795978e60cd9a85d6e76ca3b9fa67f1\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://2ba201c983524c2d03ea9337dcfde52e6dc1160d2dc3c3375983e521b0bb4dca\",\"dweb:/ipfs/QmTGBA9o9wDnqP1XEm65FowaLLgYYRzENeFEk7kpYgmzEX\"]},\"contracts/protocol/libraries/logic/ValidationLogic.sol\":{\"keccak256\":\"0x635ed57302c0a73954d0122aebe4e4b80c2287186c65008629d7420134d127b5\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://102380f2b97b4ce3938936bc988e93eefd44bb37ac03953bc0ec078393bb4b42\",\"dweb:/ipfs/QmVPBcgTwr3DFjeW3JgnLMJhwnDm6Tni1Y8AB3gFEZjhVJ\"]},\"contracts/protocol/libraries/math/MathUtils.sol\":{\"keccak256\":\"0x385815535695c27ceaa95b34aeab677b96a17c0d88621ddb92b543a64075ce10\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://115d2558f1c8886d832b239956cc1a3f3a07915f08521581fe09192619a8dca6\",\"dweb:/ipfs/QmUnMAM7YYT5nZV3W62SFu5ufX8uN8yciXcUiiQWFo399g\"]},\"contracts/protocol/libraries/math/PercentageMath.sol\":{\"keccak256\":\"0xcb555ab691219a42c47239dfe1af7394e1aa8e68161c8bc1286d447044e9d09a\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://3bf3aa963bda262d86736f614d1d5e10b2f95db39dc502da0a265a696931560b\",\"dweb:/ipfs/QmatiGsUZGHvmazuuMACeX44auMsoWMzTLpUbHBrdHb7eD\"]},\"contracts/protocol/libraries/math/WadRayMath.sol\":{\"keccak256\":\"0x3c2ac11df412318dd8dec98c6d5500d03999c42806b0051e7424e61a12be38d4\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://7b6d9cbb2408593c3ad2b920e568757a3926aa89c623749c64045b191d6bf3e3\",\"dweb:/ipfs/QmPvcwrnj6KXYEZRGKHisCnHujTPXdKEvzz1RzgTPPFUa9\"]},\"contracts/protocol/libraries/types/DataTypes.sol\":{\"keccak256\":\"0xf645d3e560cec23f2e1c0367e474efa9db1e85fda88bc54fec7a925366a93540\",\"license\":\"agpl-3.0\",\"urls\":[\"bzz-raw://e60e7eb473dfcf2e762d1cb08d6cd00608d2e50410368d07fa3be5e14dd2d8ed\",\"dweb:/ipfs/QmWY2YwVS4ViqeRkjQkwTHdZANsdAitDdhbzHvafdg3HyR\"]}},\"version\":1}"
        }
      }
    }
  }
}
